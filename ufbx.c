#include "ufbx.h"

#ifndef UFBX_UFBX_C_INLCUDED
#define UFBX_UFBX_C_INLCUDED

// -- Configuration

#define UFBXI_MAX_NODE_DEPTH 64
#define UFBXI_MAX_STRINGS 0x100000
#define UFBXI_MAX_STRING_LENGTH 0x100000
#define UFBXI_MAX_ALLOCATION_SIZE 0x10000000
#define UFBXI_MAX_NODE_CHILDREN 0x10000000
#define UFBXI_DEFAULT_MAX_MEMORY 0x10000000

#define UFBXI_READ_BUFFER_SIZE 4096

#define UFBXI_MAX_NON_ARRAY_VALUES 7

#define UFBXI_ASCII_MAX_TOKEN_LENGTH 1024
#define UFBXI_ASCII_MAX_STACK_SIZE 64

// -- Headers

#include <string.h>
#include <stdlib.h>
#include <stdio.h>

// -- Platform

#if defined(_MSC_VER)
	#define ufbxi_noinline __declspec(noinline)
	#define ufbxi_forceinline __forceinline
	#if defined(__cplusplus) && _MSC_VER >= 1900
		#define ufbxi_nodiscard [[nodiscard]]
	#else
		#define ufbxi_nodiscard
	#endif
#elif defined(__GNUC__) || defined(__clang__)
	#define ufbxi_noinline __attribute__((noinline))
	#define ufbxi_forceinline inline __attribute__((always_inline))
	#define ufbxi_nodiscard __attribute__((warn_unused_result))
#else
	#define ufbxi_noinline
	#define ufbxi_forceinline
	#define ufbxi_nodiscard
#endif

#if defined(_MSC_VER)
	#pragma warning(push)
	#pragma warning(disable: 4200) // nonstandard extension used: zero-sized array in struct/union
	#pragma warning(disable: 4201) // nonstandard extension used: nameless struct/union
	#pragma warning(disable: 4127) // conditional expression is constant
#endif

#ifndef ufbx_assert
#include <assert.h>
#define ufbx_assert(cond) assert(cond)
#endif

#if !defined(ufbx_static_assert)
	#define ufbx_static_assert(desc, cond) typedef char ufbxi_static_assert_##desc[(cond)?1:-1]
#endif

#define ufbxi_arraycount(arr) (sizeof(arr) / sizeof(*(arr)))

#define ufbxi_ignore(cond) (void)(cond)

// TODO: Unaligned loads for some platforms
#define ufbxi_read_u8(ptr) (*(const uint8_t*)(ptr))
#define ufbxi_read_u16(ptr) (*(const uint16_t*)(ptr))
#define ufbxi_read_u32(ptr) (*(const uint32_t*)(ptr))
#define ufbxi_read_u64(ptr) (*(const uint64_t*)(ptr))
#define ufbxi_read_f32(ptr) (*(const float*)(ptr))
#define ufbxi_read_f64(ptr) (*(const double*)(ptr))
#define ufbxi_read_i8(ptr) (int8_t)(ufbxi_read_u8(ptr))
#define ufbxi_read_i16(ptr) (int16_t)(ufbxi_read_u16(ptr))
#define ufbxi_read_i32(ptr) (int32_t)(ufbxi_read_u32(ptr))
#define ufbxi_read_i64(ptr) (int64_t)(ufbxi_read_u64(ptr))

#define ufbxi_write_u8(ptr, val) (*(uint8_t*)(ptr) = (uint8_t)(val))
#define ufbxi_write_u16(ptr, val) (*(uint16_t*)(ptr) = (uint16_t)(val))
#define ufbxi_write_u32(ptr, val) (*(uint32_t*)(ptr) = (uint32_t)(val))
#define ufbxi_write_u64(ptr, val) (*(uint64_t*)(ptr) = (uint64_t)(val))
#define ufbxi_write_f32(ptr, val) (*(float*)(ptr) = (float)(val))
#define ufbxi_write_f64(ptr, val) (*(double*)(ptr) = (double)(val))
#define ufbxi_write_i8(ptr, val) ufbxi_write_u8(ptr, val)
#define ufbxi_write_i16(ptr, val) ufbxi_write_u16(ptr, val)
#define ufbxi_write_i32(ptr, val) ufbxi_write_u32(ptr, val)

#define ufbxi_for(m_type, m_name, m_begin, m_num) for (m_type *m_name = m_begin, *m_name##_end = m_name + (m_num); m_name != m_name##_end; m_name++)

#ifdef __cplusplus
extern "C" {
#endif

// -- Platform checks

ufbx_static_assert(sizeof_bool, sizeof(bool) == 1);
ufbx_static_assert(sizeof_i8, sizeof(int8_t) == 1);
ufbx_static_assert(sizeof_i16, sizeof(int16_t) == 2);
ufbx_static_assert(sizeof_i32, sizeof(int32_t) == 4);
ufbx_static_assert(sizeof_i64, sizeof(int64_t) == 8);
ufbx_static_assert(sizeof_u8, sizeof(uint8_t) == 1);
ufbx_static_assert(sizeof_u16, sizeof(uint16_t) == 2);
ufbx_static_assert(sizeof_u32, sizeof(uint32_t) == 4);
ufbx_static_assert(sizeof_u64, sizeof(uint64_t) == 8);
ufbx_static_assert(sizeof_f32, sizeof(float) == 4);
ufbx_static_assert(sizeof_f64, sizeof(double) == 8);

// -- General utility

static ufbxi_forceinline uint32_t ufbxi_min32(uint32_t a, uint32_t b) { return a < b ? a : b; }
static ufbxi_forceinline uint32_t ufbxi_max32(uint32_t a, uint32_t b) { return a < b ? b : a; }
static ufbxi_forceinline uint64_t ufbxi_min64(uint64_t a, uint64_t b) { return a < b ? a : b; }
static ufbxi_forceinline uint64_t ufbxi_max64(uint64_t a, uint64_t b) { return a < b ? b : a; }
static ufbxi_forceinline size_t ufbxi_min_sz(size_t a, size_t b) { return a < b ? a : b; }
static ufbxi_forceinline size_t ufbxi_max_sz(size_t a, size_t b) { return a < b ? b : a; }

// -- DEFLATE implementation
// Pretty much based on Sean Barrett's `stb_image` deflate

#if !defined(ufbx_inflate)

// Lookup data: [0:13] extra mask [13:17] extra bits [17:32] base value
// Generated by `misc/deflate_lut.py`
static const uint32_t ufbxi_deflate_length_lut[] = {
	0x00060000, 0x00080000, 0x000a0000, 0x000c0000, 0x000e0000, 0x00100000, 0x00120000, 0x00140000, 
	0x00162001, 0x001a2001, 0x001e2001, 0x00222001, 0x00264003, 0x002e4003, 0x00364003, 0x003e4003, 
	0x00466007, 0x00566007, 0x00666007, 0x00766007, 0x0086800f, 0x00a6800f, 0x00c6800f, 0x00e6800f, 
	0x0106a01f, 0x0146a01f, 0x0186a01f, 0x01c6a01f, 0x02040000, 0x00000000, 0x00000000, 
};
static const uint32_t ufbxi_deflate_dist_lut[] = {
	0x00020000, 0x00040000, 0x00060000, 0x00080000, 0x000a2001, 0x000e2001, 0x00124003, 0x001a4003, 
	0x00226007, 0x00326007, 0x0042800f, 0x0062800f, 0x0082a01f, 0x00c2a01f, 0x0102c03f, 0x0182c03f, 
	0x0202e07f, 0x0302e07f, 0x040300ff, 0x060300ff, 0x080321ff, 0x0c0321ff, 0x100343ff, 0x180343ff, 
	0x200367ff, 0x300367ff, 0x40038fff, 0x60038fff, 0x8003bfff, 0xc003bfff, 
};

static const uint8_t ufbxi_deflate_code_length_permutation[] = {
	16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15,
};

#define UFBXI_HUFF_MAX_BITS 16
#define UFBXI_HUFF_MAX_VALUE 288
#define UFBXI_HUFF_FAST_BITS 9
#define UFBXI_HUFF_FAST_SIZE (1 << UFBXI_HUFF_FAST_BITS)
#define UFBXI_HUFF_FAST_MASK (UFBXI_HUFF_FAST_SIZE - 1)

typedef struct {
	char local_buffer[64];

	char *buffer;
	size_t buffer_size;

	ufbx_read_fn *read_fn;
	void *read_user;
	size_t input_left;

	const char *chunk_begin;
	const char *chunk_ptr;
	const char *chunk_end;
	const char *chunk_real_end;

	uint64_t bits;
	size_t left;
} ufbxi_bit_stream;

typedef struct {
	uint32_t num_symbols;

	uint16_t sorted_to_sym[UFBXI_HUFF_MAX_VALUE]; // < Sorted symbol index to symbol
	uint16_t past_max_code[UFBXI_HUFF_MAX_BITS];  // < One past maximum code value per bit length
	int16_t code_to_sorted[UFBXI_HUFF_MAX_BITS];  // < Code to sorted symbol index per bit length
	uint16_t fast_sym[UFBXI_HUFF_FAST_SIZE];      // < Fast symbol lookup [0:12] symbol [12:16] bits
} ufbxi_huff_tree;

typedef struct {
	ufbxi_huff_tree lit_length;
	ufbxi_huff_tree dist;
} ufbxi_trees;

typedef struct {
	bool initialized;
	ufbxi_trees static_trees;
} ufbxi_inflate_retain_imp;

ufbx_static_assert(inflate_retain_size, sizeof(ufbxi_inflate_retain_imp) <= sizeof(ufbx_inflate_retain));

typedef struct {
	ufbxi_bit_stream stream;

	char *out_begin;
	char *out_ptr;
	char *out_end;
} ufbxi_deflate_context;

static ufbxi_forceinline uint32_t
ufbxi_bit_reverse(uint32_t mask, uint32_t num_bits)
{
	ufbx_assert(num_bits <= 16);
	uint32_t x = mask;
    x = (((x & 0xaaaa) >> 1) | ((x & 0x5555) << 1));
    x = (((x & 0xcccc) >> 2) | ((x & 0x3333) << 2));
    x = (((x & 0xf0f0) >> 4) | ((x & 0x0f0f) << 4));
	x = (((x & 0xff00) >> 8) | ((x & 0x00ff) << 8));
	return x >> (16 - num_bits);
}

static ufbxi_noinline const char *
ufbxi_bit_chunk_refill(ufbxi_bit_stream *s, const char *ptr)
{
	size_t left = s->chunk_real_end - ptr;
	ufbx_assert(left < 64);

	memcpy(s->buffer, ptr, left);
	if (s->read_fn) {
		size_t to_read = ufbxi_min_sz(s->input_left, s->buffer_size - left);
		if (to_read > 0) {
			size_t num_read = s->read_fn(s->read_user, s->buffer + left, to_read);
			s->input_left -= num_read;
			left += num_read;
		}
	}
	if (left < 64) {
		memset(s->buffer + left, 0, 64 - left);
		left = 64;
	}

	s->chunk_begin = s->buffer;
	s->chunk_ptr = s->buffer;
	s->chunk_end = s->buffer + left - 8;
	s->chunk_real_end = s->buffer + left;
	return s->buffer;
}

static void
ufbxi_bit_stream_init(ufbxi_bit_stream *s, const ufbx_inflate_input *input)
{
	s->read_fn = input->read_fn;
	s->read_user = input->read_user;
	s->chunk_begin = (const char*)input->data;
	s->chunk_ptr = (const char*)input->data;
	s->chunk_end = (const char*)input->data + input->data_size - 8;
	s->chunk_real_end = (const char*)input->data + input->data_size;
	s->input_left = input->total_size - input->data_size;

	if (input->buffer_size >= 64) {
		s->buffer = (char*)input->buffer;
		s->buffer_size = input->buffer_size;
	} else {
		s->buffer = s->local_buffer;
		s->buffer_size = sizeof(s->local_buffer);
	}

	s->bits = 0;
	s->left = 0;

	if (input->data_size < 64) {
		ufbxi_bit_chunk_refill(s, s->chunk_begin);
	}
}

static ufbxi_forceinline void
ufbxi_bit_refill(uint64_t *p_bits, size_t *p_left, const char **p_data, ufbxi_bit_stream *s)
{
	if (*p_data > s->chunk_end) {
		*p_data = ufbxi_bit_chunk_refill(s, *p_data);
	}

	*p_bits |= ufbxi_read_u64(*p_data) << *p_left;
	*p_data += (63 - *p_left) >> 3;
	*p_left |= 56;
}

static int
ufbxi_bit_copy_bytes(void *dst, ufbxi_bit_stream *s, size_t len)
{
	ufbx_assert(s->left % 8 == 0);
	char *ptr = (char*)dst;

	// Copy the buffered bits first
	while (len > 0 && s->left > 0) {
		*ptr++ = (char)(uint8_t)s->bits;
		len -= 1;
		s->bits >>= 8;
		s->left -= 8;
	}

	// Copy the current chunk
	size_t chunk_left = s->chunk_real_end - s->chunk_ptr;
	if (chunk_left >= len) {
		memcpy(ptr, s->chunk_ptr, len);
		s->chunk_ptr += len;
		return 0;
	} else {
		memcpy(ptr, s->chunk_ptr, chunk_left);
		s->chunk_ptr += chunk_left;
		ptr += chunk_left;
	}

	// Read extra bytes from user
	size_t num_read = 0;
	if (s->read_fn) {
		num_read = s->read_fn(s->read_user, ptr, len);
	}
	return num_read == len;
}

// 0: Success
// -1: Overfull
// -2: Underfull
static ufbxi_noinline ptrdiff_t
ufbxi_huff_build(ufbxi_huff_tree *tree, uint8_t *sym_bits, uint32_t sym_count)
{
	ufbx_assert(sym_count <= UFBXI_HUFF_MAX_VALUE);
	tree->num_symbols = sym_count;

	uint32_t bits_counts[UFBXI_HUFF_MAX_BITS];
	memset(bits_counts, 0, sizeof(bits_counts));
	for (uint32_t i = 0; i < sym_count; i++) {
		uint32_t bits = sym_bits[i];
		ufbx_assert(bits <= UFBXI_HUFF_MAX_BITS);
		bits_counts[bits]++;
	}
	uint32_t nonzero_sym_count = sym_count - bits_counts[0];

	uint32_t total_syms[UFBXI_HUFF_MAX_BITS];
	uint32_t first_code[UFBXI_HUFF_MAX_BITS];

	tree->code_to_sorted[0] = INT16_MAX;
	tree->past_max_code[0] = 0;
	total_syms[0] = 0;

	{
		int num_codes_left = 1;
		uint32_t code = 0;
		uint32_t prev_count = 0;
		for (uint32_t bits = 1; bits < UFBXI_HUFF_MAX_BITS; bits++) {
			uint32_t count = bits_counts[bits];
			code = (code + prev_count) << 1;
			first_code[bits] = code;
			tree->past_max_code[bits] = (uint16_t)(code + count);

			uint32_t prev_syms = total_syms[bits - 1];
			total_syms[bits] = prev_syms + count;

			// Each bit level doubles the amount of codes and potentially removes some
			num_codes_left = (num_codes_left << 1) - count;
			if (num_codes_left < 0) {
				return -1;
			}

			if (count > 0) {
				tree->code_to_sorted[bits] = (int16_t)((int)prev_syms - (int)code);
			} else {
				tree->code_to_sorted[bits] = INT16_MAX;
			}
			prev_count = count;
		}

		// All codes should be used if there's more than one symbol
		if (nonzero_sym_count > 1 && num_codes_left != 0) {
			return -2;
		}
	}

	memset(tree->fast_sym, 0, sizeof(tree->fast_sym));

	uint32_t bits_index[UFBXI_HUFF_MAX_BITS];
	memset(bits_index, 0, sizeof(bits_index));
	memset(tree->sorted_to_sym, 0xff, sizeof(tree->sorted_to_sym));
	for (uint32_t i = 0; i < sym_count; i++) {
		uint32_t bits = sym_bits[i];
		if (bits == 0) continue;

		uint32_t index = bits_index[bits]++;
		uint32_t sorted = total_syms[bits - 1] + index;
		tree->sorted_to_sym[sorted] = (uint16_t)i;

		uint32_t code = first_code[bits] + index;
		uint32_t rev_code = ufbxi_bit_reverse(code, bits);

		if (bits <= UFBXI_HUFF_FAST_BITS) {
			uint16_t fast_sym = (uint16_t)(i | bits << 12);
			uint32_t hi_max = 1 << (UFBXI_HUFF_FAST_BITS - bits);
			for (uint32_t hi = 0; hi < hi_max; hi++) {
				ufbx_assert(tree->fast_sym[rev_code | hi << bits] == 0);
				tree->fast_sym[rev_code | hi << bits] = fast_sym;
			}
		}
	}

	return 0;
}

static ufbxi_forceinline uint32_t
ufbxi_huff_decode_bits(const ufbxi_huff_tree *tree, uint64_t *p_bits, size_t *p_left)
{
	uint32_t fast_sym_bits = tree->fast_sym[*p_bits & UFBXI_HUFF_FAST_MASK];
	if (fast_sym_bits != 0) {
		uint32_t bits = fast_sym_bits >> 12;
		*p_bits >>= bits;
		*p_left -= bits;
		return fast_sym_bits & 0x3ff;
	}

	uint32_t code = ufbxi_bit_reverse((uint32_t)*p_bits, UFBXI_HUFF_FAST_BITS + 1);
	*p_bits >>= UFBXI_HUFF_FAST_BITS + 1;
	*p_left -= UFBXI_HUFF_FAST_BITS + 1;
	for (uint32_t bits = UFBXI_HUFF_FAST_BITS + 1; bits < UFBXI_HUFF_MAX_BITS; bits++) {
		if (code < tree->past_max_code[bits]) {
			uint32_t sorted = code + tree->code_to_sorted[bits];
			if (sorted >= tree->num_symbols) return ~0u;
			return tree->sorted_to_sym[sorted];
		}
		code = code << 1 | (*p_bits & 1);
		*p_bits >>= 1;
		*p_left -= 1;
	}

	return ~0u;
}

static void
ufbxi_init_static_huff(ufbxi_trees *trees)
{
	ptrdiff_t err = 0;

	uint8_t lit_length_bits[288];
	memset(lit_length_bits +   0, 8, 144 -   0);
	memset(lit_length_bits + 144, 9, 256 - 144);
	memset(lit_length_bits + 256, 7, 280 - 256);
	memset(lit_length_bits + 280, 8, 288 - 280);
	err |= ufbxi_huff_build(&trees->lit_length, lit_length_bits, sizeof(lit_length_bits));

	uint8_t dist_bits[32];
	memset(dist_bits + 0, 5, 32 - 0);
	err |= ufbxi_huff_build(&trees->dist, dist_bits, sizeof(dist_bits));

	ufbx_assert(err == 0);
}

// 0: Success
// -1: Huffman Overfull
// -2: Huffman Underfull
// -3: Code 16 repeat overflow
// -4: Code 17 repeat overflow
// -5: Code 18 repeat overflow
// -6: Bad length code
static ufbxi_noinline ptrdiff_t
ufbxi_init_dynamic_huff_tree(ufbxi_deflate_context *dc, const ufbxi_huff_tree *huff_code_length,
	ufbxi_huff_tree *tree, uint32_t num_symbols)
{
	uint8_t code_lengths[UFBXI_HUFF_MAX_VALUE];
	ufbx_assert(num_symbols <= UFBXI_HUFF_MAX_VALUE);

	uint64_t bits = dc->stream.bits;
	size_t left = dc->stream.left;
	const char *data = dc->stream.chunk_ptr;

	uint32_t symbol_index = 0;
	uint8_t prev = 0;
	while (symbol_index < num_symbols) {
		ufbxi_bit_refill(&bits, &left, &data, &dc->stream);

		uint32_t inst = ufbxi_huff_decode_bits(huff_code_length, &bits, &left);
		if (inst <= 15) {
			prev = (uint8_t)inst;
			code_lengths[symbol_index++] = (uint8_t)inst;
		} else if (inst == 16) {
			uint32_t num = 3 + ((uint32_t)bits & 0x3);
			bits >>= 2;
			left -= 2;
			if (symbol_index + num > num_symbols) return -3;
			memset(code_lengths + symbol_index, prev, num);
			symbol_index += num;
		} else if (inst == 17) {
			uint32_t num = 3 + ((uint32_t)bits & 0x7);
			bits >>= 3;
			left -= 3;
			if (symbol_index + num > num_symbols) return -4;
			memset(code_lengths + symbol_index, 0, num);
			symbol_index += num;
			prev = 0;
		} else if (inst == 18) {
			uint32_t num = 11 + ((uint32_t)bits & 0x7f);
			bits >>= 7;
			left -= 7;
			if (symbol_index + num > num_symbols) return -5;
			memset(code_lengths + symbol_index, 0, num);
			symbol_index += num;
			prev = 0;
		} else {
			return -6;
		}
	}

	ptrdiff_t err = ufbxi_huff_build(tree, code_lengths, num_symbols);
	if (err != 0) return err;

	dc->stream.bits = bits;
	dc->stream.left = left;
	dc->stream.chunk_ptr = data;

	return 0;
}

static ptrdiff_t
ufbxi_init_dynamic_huff(ufbxi_deflate_context *dc, ufbxi_trees *trees)
{
	uint64_t bits = dc->stream.bits;
	size_t left = dc->stream.left;
	const char *data = dc->stream.chunk_ptr;
	ufbxi_bit_refill(&bits, &left, &data, &dc->stream);

	uint32_t num_lit_lengths = 257 + (bits & 0x1f);
	uint32_t num_dists = 1 + (bits >> 5 & 0x1f);
	uint32_t num_code_lengths = 4 + (bits >> 10 & 0xf);
	bits >>= 14;
	left -= 14;

	uint8_t code_lengths[19];
	memset(code_lengths, 0, sizeof(code_lengths));

	uint32_t len_i = 0;
	if (num_code_lengths >= 18) {
		ufbxi_bit_refill(&bits, &left, &data, &dc->stream);
		for (; len_i < 18; len_i++) {
			code_lengths[ufbxi_deflate_code_length_permutation[len_i]] = (uint32_t)bits & 0x7;
			bits >>= 3;
			left -= 3;
		}
	}

	ufbxi_bit_refill(&bits, &left, &data, &dc->stream);
	for (; len_i < num_code_lengths; len_i++) {
		code_lengths[ufbxi_deflate_code_length_permutation[len_i]] = (uint32_t)bits & 0x7;
		bits >>= 3;
		left -= 3;
	}

	dc->stream.bits = bits;
	dc->stream.left = left;
	dc->stream.chunk_ptr = data;

	ufbxi_huff_tree huff_code_length;
	ptrdiff_t err;
	err = ufbxi_huff_build(&huff_code_length, code_lengths, ufbxi_arraycount(code_lengths));
	if (err) return -14 + 1 + err;
	err = ufbxi_init_dynamic_huff_tree(dc, &huff_code_length, &trees->lit_length, num_lit_lengths);
	if (err) return -16 + 1 + err;
	err = ufbxi_init_dynamic_huff_tree(dc, &huff_code_length, &trees->dist, num_dists);
	if (err) return -22 + 1 + err;

	return 0;
}


static uint32_t
ufbxi_adler32(const void *data, size_t size)
{
	size_t a = 1, b = 0;
	const size_t num_before_wrap = sizeof(size_t) == 8 ? 380368439u : 5552u;

	const char *p = (const char*)data;

	size_t size_left = size;
	while (size_left > 0) {
		size_t num = size_left <= num_before_wrap ? size_left : num_before_wrap;
		size_left -= num;
		const char *end = p + num;

		while (end - p >= 8) {
			a += (size_t)(uint8_t)p[0]; b += a;
			a += (size_t)(uint8_t)p[1]; b += a;
			a += (size_t)(uint8_t)p[2]; b += a;
			a += (size_t)(uint8_t)p[3]; b += a;
			a += (size_t)(uint8_t)p[4]; b += a;
			a += (size_t)(uint8_t)p[5]; b += a;
			a += (size_t)(uint8_t)p[6]; b += a;
			a += (size_t)(uint8_t)p[7]; b += a;
			p += 8;
		}

		while (p != end) {
			a += (size_t)(uint8_t)p[0]; b += a;
			p++;
		}

		a %= 65521u;
		b %= 65521u;
	}

	return (uint32_t)((b << 16) | (a & 0xffff));
}

static int
ufbxi_inflate_block(ufbxi_deflate_context *dc, ufbxi_trees *trees)
{
	char *out_ptr = dc->out_ptr;
	char *const out_begin = dc->out_begin;
	char *const out_end = dc->out_end;

	uint64_t bits = dc->stream.bits;
	size_t left = dc->stream.left;
	const char *data = dc->stream.chunk_ptr;

	for (;;) {
		ufbxi_bit_refill(&bits, &left, &data, &dc->stream);

		// Decode literal/length value from input stream
		uint32_t lit_length = ufbxi_huff_decode_bits(&trees->lit_length, &bits, &left);

		// If value < 256: copy value (literal byte) to output stream
		if (lit_length < 256) {
			if (out_ptr == out_end) {
				return -10;
			}
			*out_ptr++ = (char)lit_length;
		} else if (lit_length - 257 <= 285 - 257) {
			// If value = 257..285: Decode extra length and distance
			uint32_t length, distance;

			// Length
			{
				uint32_t lut = ufbxi_deflate_length_lut[lit_length - 257];
				uint32_t base = lut >> 17;
				uint32_t offset = ((uint32_t)bits & lut & 0x1fff);
				uint32_t offset_bits = (lut >> 13) & 0xf;
				bits >>= offset_bits;
				left -= offset_bits;
				length = base + offset;
			}

			// Distance
			{
				uint32_t dist = ufbxi_huff_decode_bits(&trees->dist, &bits, &left);
				if (dist >= 30) {
					return -11;
				}
				uint32_t lut = ufbxi_deflate_dist_lut[dist];
				uint32_t base = lut >> 17;
				uint32_t offset = ((uint32_t)bits & lut & 0x1fff);
				uint32_t offset_bits = (lut >> 13) & 0xf;
				bits >>= offset_bits;
				left -= offset_bits;
				distance = base + offset;
			}

			if ((ptrdiff_t)distance > out_ptr - out_begin || (ptrdiff_t)length > out_end - out_ptr) {
				return -12;
			}

			ufbx_assert(length > 0);
			const char *src = out_ptr - distance;
			char *dst = out_ptr;
			out_ptr += length;
			{
				// TODO: Do something better than per-byte copy
				char *end = dst + length;

				while (end - dst >= 4) {
					dst[0] = src[0];
					dst[1] = src[1];
					dst[2] = src[2];
					dst[3] = src[3];
					dst += 4;
					src += 4;
				}

				while (dst != end) {
					*dst++ = *src++;
				}
			}
		} else if (lit_length == 256) {
			break;
		} else {
			return -13;
		}
	}

	dc->out_ptr = out_ptr;
	dc->stream.bits = bits;
	dc->stream.left = left;
	dc->stream.chunk_ptr = data;

	return 0;
}

// TODO: Error codes should have a quick test if the destination buffer overflowed
// Returns actual number of decompressed bytes or negative error:
// -1: Bad compression method (ZLIB header)
// -2: Requires dictionary (ZLIB header)
// -3: Bad FCHECK (ZLIB header)
// -4: Bad NLEN (Uncompressed LEN != ~NLEN)
// -5: Uncompressed source overflow
// -6: Uncompressed destination overflow
// -7: Bad block type
// -8: Truncated checksum
// -9: Checksum mismatch
// -10: Literal destination overflow
// -11: Bad distance code or distance of (30..31)
// -12: Match out of bounds
// -13: Bad lit/length code
// -14: Codelen Huffman Overfull
// -15: Codelen Huffman Underfull
// -16 - -21: Litlen Huffman: Overfull / Underfull / Repeat 16/17/18 overflow / Bad length code
// -22 - -27: Distance Huffman: Overfull / Underfull / Repeat 16/17/18 overflow / Bad length code
ptrdiff_t ufbx_inflate(void *dst, size_t dst_size, const ufbx_inflate_input *input, ufbx_inflate_retain *retain)
{
	ufbxi_inflate_retain_imp *ret_imp = (ufbxi_inflate_retain_imp*)retain;

	ptrdiff_t err;
	ufbxi_deflate_context dc;
	ufbxi_bit_stream_init(&dc.stream, input);
	dc.out_begin = (char*)dst;
	dc.out_ptr = (char*)dst;
	dc.out_end = (char*)dst + dst_size;

	uint64_t bits = dc.stream.bits;
	size_t left = dc.stream.left;
	const char *data = dc.stream.chunk_ptr;

	ufbxi_bit_refill(&bits, &left, &data, &dc.stream);

	// Zlib header
	{
		size_t cmf = (size_t)(bits & 0xff);
		size_t flg = (size_t)(bits >> 8) & 0xff;
		bits >>= 16;
		left -= 16;

		if ((cmf & 0xf) != 0x8) return -1;
		if ((flg & 0x20) != 0) return -2;
		if ((cmf << 8 | flg) % 31u != 0) return -3;
	}

	for (;;) { 
		ufbxi_bit_refill(&bits, &left, &data, &dc.stream);

		// Block header: [0:1] BFINAL [1:3] BTYPE
		size_t header = (size_t)bits & 0x7;
		bits >>= 3;
		left -= 3;

		size_t type = header >> 1;
		if (type == 0) {

			// Round up to the next byte
			size_t align_bits = left & 0x7;
			bits >>= align_bits;
			left -= align_bits;

			size_t len = (size_t)(bits & 0xffff);
			size_t nlen = (size_t)((bits >> 16) & 0xffff);
			if ((len ^ nlen) != 0xffff) return -4;
			if (dc.out_end - dc.out_ptr < (ptrdiff_t)len) return -6;
			bits >>= 32;
			left -= 32;

			dc.stream.bits = bits;
			dc.stream.left = left;
			dc.stream.chunk_ptr = data;

			// Copy literal data (skipping header) and advance
			if (!ufbxi_bit_copy_bytes(dc.out_ptr, &dc.stream, len)) return -5;

			dc.out_ptr += len;

		} else if (type <= 2) {

			dc.stream.bits = bits;
			dc.stream.left = left;
			dc.stream.chunk_ptr = data;

			ufbxi_trees tree_data;
			ufbxi_trees *trees;
			if (type == 1) {
				if (!ret_imp->initialized) {
					ufbxi_init_static_huff(&ret_imp->static_trees);
					ret_imp->initialized = true;
				}
				trees = &ret_imp->static_trees;
			} else { 
				err = ufbxi_init_dynamic_huff(&dc, &tree_data);
				if (err) return err;
				trees = &tree_data;
			}

			err = ufbxi_inflate_block(&dc, trees);
			if (err) return err;

		} else {
			// 0b11 - reserved (error)
			return -7;
		}

		bits = dc.stream.bits;
		left = dc.stream.left;
		data = dc.stream.chunk_ptr;

		// BFINAL: End of stream
		if (header & 1) break;
	}

	// Check Adler-32
	{
		// Round up to the next byte
		size_t align_bits = left & 0x7;
		bits >>= align_bits;
		left -= align_bits;
		ufbxi_bit_refill(&bits, &left, &data, &dc.stream);

		uint32_t ref = (uint32_t)bits;
		ref = (ref>>24) | (ref>>8)&0xff00 | (ref<<8)&0xff0000 | (ref<<24);

		uint32_t checksum = ufbxi_adler32(dc.out_begin, dc.out_ptr - dc.out_begin);
		if (ref != checksum) {
			return -9;
		}
	}

	return dc.out_ptr - dc.out_begin;
}

#endif // !defined(ufbx_inflate)

// -- Errors

static ufbxi_noinline int ufbxi_fail_imp_err(ufbx_error *err, const char *cond, const char *func, uint32_t line)
{
	if (err->stack_size < UFBX_ERROR_STACK_MAX_DEPTH) {
		ufbx_error_frame *frame = &err->stack[err->stack_size++];
		frame->description = cond;
		frame->function = func;
		frame->source_line = line;
	}
	return 0;
}

#define ufbxi_check_return_err(err, cond, ret) do { if (!(cond)) { ufbxi_fail_imp_err((err), "ufbxi_check_return_err(" #err ", " #cond ", " #ret ")", __FUNCTION__, __LINE__); return ret; } } while (0)
#define ufbxi_fail_err(err, desc) return ufbxi_fail_imp_err(err, desc, __FUNCTION__, __LINE__)

// -- Allocator

typedef struct {
	ufbx_error *error;
	size_t current_size;
	size_t max_size;
	ufbx_allocator ator;
} ufbxi_allocator;

static ufbxi_forceinline bool ufbxi_check_overflow(size_t total, size_t a, size_t b)
{
	// If `a` and `b` have at most 4 bits per `size_t` byte, the product can't overflow.
	if (((a | b) >> sizeof(size_t)*4) != 0) {
		if (a != 0 && total / a != b) return false;
	}
	return true;
}

static void *ufbxi_alloc_uninit_size(ufbxi_allocator *ator, size_t size, size_t n)
{
	size_t total = size * n;
	ufbxi_check_return_err(ator->error, ufbxi_check_overflow(total, size, n), NULL);
	ufbxi_check_return_err(ator->error, total <= UFBXI_MAX_ALLOCATION_SIZE, NULL);
	ufbxi_check_return_err(ator->error, total <= ator->max_size - ator->current_size, NULL);

	ator->current_size += total;

	if (ator->ator.alloc_fn) {
		return ator->ator.alloc_fn(ator->ator.user, total);
	} else {
		return malloc(total);
	}
}

static ufbxi_forceinline void *ufbxi_alloc_zero_size(ufbxi_allocator *ator, size_t size, size_t n)
{
	void *ptr = ufbxi_alloc_uninit_size(ator, size, n);
	if (ptr) memset(ptr, 0, size * n);
	return ptr;
}

static void ufbxi_free_size(ufbxi_allocator *ator, size_t size, void *ptr, size_t n);
static void *ufbxi_realloc_uninit_size(ufbxi_allocator *ator, size_t size, void *old_ptr, size_t old_n, size_t n)
{
	if (old_n == 0) return ufbxi_alloc_uninit_size(ator, size, n);
	if (n == 0) {
		ufbxi_free_size(ator, size, old_ptr, old_n);
		return NULL;
	}

	size_t old_total = size * old_n;
	size_t total = size * n;

	ufbx_assert(ufbxi_check_overflow(old_total, size, old_n));
	ufbx_assert(old_total <= UFBXI_MAX_ALLOCATION_SIZE);
	ufbx_assert(old_total <= ator->current_size);

	ufbxi_check_return_err(ator->error, ufbxi_check_overflow(total, size, n), NULL);
	ufbxi_check_return_err(ator->error, total <= UFBXI_MAX_ALLOCATION_SIZE, NULL);
	ufbxi_check_return_err(ator->error, total <= ator->max_size - ator->current_size, NULL);

	ator->current_size += total;
	ator->current_size -= old_total;

	if (ator->ator.realloc_fn) {
		return ator->ator.realloc_fn(ator->ator.user, old_ptr, old_total, total);
	} else if (ator->ator.alloc_fn) {
		void *ptr = ator->ator.alloc_fn(ator->ator.user, total);
		memcpy(ptr, old_ptr, old_total);
		if (ator->ator.free_fn) {
			ator->ator.free_fn(ator->ator.user, old_ptr, old_total);
		}
		return ptr;
	} else {
		return realloc(old_ptr, total);
	}
}

static ufbxi_forceinline void *ufbxi_realloc_zero_size(ufbxi_allocator *ator, size_t size, void *old_ptr, size_t old_n, size_t n)
{
	void *ptr = ufbxi_realloc_uninit_size(ator, size, old_ptr, old_n, n);
	if (ptr && n > old_n) memset((char*)ptr + size*old_n, 0, size*(n - old_n));
	return ptr;
}

static void ufbxi_free_size(ufbxi_allocator *ator, size_t size, void *ptr, size_t n)
{
	if (n == 0) return;

	size_t total = size * n;
	ufbx_assert(ufbxi_check_overflow(total, size, n));
	ufbx_assert(total <= UFBXI_MAX_ALLOCATION_SIZE);
	ufbx_assert(total <= ator->current_size);

	ator->current_size -= total;

	if (ator->ator.alloc_fn) {
		if (ator->ator.free_fn) {
			ator->ator.free_fn(ator->ator.user, ptr, total);
		}
	} else {
		free(ptr);
	}
}

static bool ufbxi_grow_array_uninit_size(ufbxi_allocator *ator, size_t size, void *p_ptr, size_t *p_cap, size_t n)
{
	void *ptr = *(void**)p_ptr;
	size_t old_n = *p_cap;
	size_t new_n = ufbxi_max_sz(old_n * 2, n);
	void *new_ptr = ufbxi_realloc_uninit_size(ator, size, ptr, old_n, new_n);
	if (!new_ptr) return false;
	*(void**)p_ptr = new_ptr;
	*p_cap = new_n;
	return true;
}

static bool ufbxi_grow_array_zero_size(ufbxi_allocator *ator, size_t size, void *p_ptr, size_t *p_cap, size_t n)
{
	void *ptr = *(void**)p_ptr;
	size_t old_n = *p_cap;
	size_t new_n = ufbxi_max_sz(old_n * 2, n);
	void *new_ptr = ufbxi_realloc_zero_size(ator, size, ptr, old_n, new_n);
	if (!new_ptr) return false;
	*(void**)p_ptr = new_ptr;
	*p_cap = new_n;
	return true;
}

#define ufbxi_alloc_uninit(ator, type, n) (type*)ufbxi_alloc_uninit_size((ator), sizeof(type), (n))
#define ufbxi_alloc_zero(ator, type, n) (type*)ufbxi_alloc_zero_size((ator), sizeof(type), (n))
#define ufbxi_realloc_uninit(ator, type, old_ptr, old_n, n) (type*)ufbxi_realloc_uninit_size((ator), sizeof(type), (old_ptr), (old_n), (n))
#define ufbxi_realloc_zero(ator, type, old_ptr, old_n, n) (type*)ufbxi_realloc_zero_size((ator), sizeof(type), (old_ptr), (old_n), (n))
#define ufbxi_free(ator, type, ptr, n) ufbxi_free_size((ator), sizeof(type), (ptr), (n))

#define ufbxi_grow_array_uninit(ator, p_ptr, p_cap, n) ufbxi_grow_array_uninit_size((ator), sizeof(**(p_ptr)), (p_ptr), (p_cap), (n))
#define ufbxi_grow_array_zero(ator, p_ptr, p_cap, n) ufbxi_grow_array_zero_size((ator), sizeof(**(p_ptr)), (p_ptr), (p_cap), (n))

// -- General purpose chunked buffer

typedef struct ufbxi_buf_chunk ufbxi_buf_chunk;

struct ufbxi_buf_chunk {
	ufbxi_buf_chunk *root;
	ufbxi_buf_chunk *prev;
	ufbxi_buf_chunk *next;
	void *align_0;

	uint32_t pushed_pos;
	uint32_t size;
	uint32_t next_size;
	uint32_t align_1;

	char data[];
};

ufbx_static_assert(buf_chunk_align, offsetof(ufbxi_buf_chunk, data) % 8 == 0);

typedef struct {
	ufbxi_allocator *ator;

	ufbxi_buf_chunk *chunk;
	uint32_t pos, size;
	size_t num_items;
} ufbxi_buf;

static void *ufbxi_push_size_uninit_new_block(ufbxi_buf *b, size_t size)
{
	ufbxi_buf_chunk *chunk = b->chunk;
	if (chunk) {
		// Store the final position for the retired chunk
		chunk->pushed_pos = b->pos;

		// Try to re-use old chunks first
		ufbxi_buf_chunk *next;
		while ((next = chunk->next) != NULL) {
			chunk = next;
			if (size <= chunk->size) {
				b->chunk = chunk;
				b->pos = (uint32_t)size;
				b->size = chunk->size;
				return chunk->data;
			} else {
				// Didn't fit, skip the whole chunk
				chunk->pushed_pos = 0;
			}
		}
	}

	// Allocate a new chunk, grow `next_size` geometrically but don't double
	// the current or previous user sizes if they are larger.
	uint32_t next_size = chunk ? chunk->next_size * 2 : 4096;
	uint32_t chunk_size = next_size - sizeof(ufbxi_buf_chunk);
	if (chunk_size < size) chunk_size = (uint32_t)size;
	ufbxi_buf_chunk *new_chunk = (ufbxi_buf_chunk*)ufbxi_alloc_uninit_size(b->ator, 1, sizeof(ufbxi_buf_chunk) + chunk_size);
	if (!new_chunk) return NULL;

	new_chunk->prev = chunk;
	new_chunk->next = NULL;
	new_chunk->size = chunk_size;
	new_chunk->next_size = next_size;

	// Link the chunk to the list and set it as the active one
	if (chunk) {
		chunk->next = new_chunk;
		new_chunk->root = chunk->root;
	} else {
		new_chunk->root = new_chunk;
	}

	b->chunk = new_chunk;
	b->pos = (uint32_t)size;
	b->size = chunk_size;

	return new_chunk->data;
}

static ufbxi_forceinline uint32_t ufbxi_align_to_mask(uint32_t value, uint32_t align_mask)
{
	return value + ((uint32_t)-(int32_t)value & align_mask);
}

static ufbxi_forceinline uint32_t ufbxi_size_align_mask(size_t size)
{
	// Align to the all bits below the lowest set one in `size`
	// up to a maximum of 0x7 (align to 8 bytes).
	return ((size ^ (size - 1)) >> 1) & 0x7;
}

static ufbxi_forceinline void *ufbxi_push_size_uninit(ufbxi_buf *b, size_t size, size_t n)
{
	b->num_items += n;

	uint32_t align_mask = ufbxi_size_align_mask(size);
	uint32_t pos = ufbxi_align_to_mask(b->pos, align_mask);
	uint32_t push_size = (uint32_t)(size * n);
	uint32_t end = pos + push_size;
	if (end <= b->size) {
		b->pos = end;
		return b->chunk->data + pos;
	} else {
		return ufbxi_push_size_uninit_new_block(b, push_size);
	}
}

static ufbxi_forceinline void *ufbxi_push_size_zero(ufbxi_buf *b, size_t size, size_t n)
{
	void *ptr = ufbxi_push_size_uninit(b, size, n);
	if (ptr) memset(ptr, 0, size * n);
	return ptr;
}

ufbxi_nodiscard static ufbxi_forceinline void *ufbxi_push_size_copy(ufbxi_buf *b, size_t size, size_t n, const void *data)
{
	void *ptr = ufbxi_push_size_uninit(b, size, n);
	if (ptr) memcpy(ptr, data, size * n);
	return ptr;
}

static void ufbxi_pop_size(ufbxi_buf *b, size_t size, size_t n, void *dst)
{
	b->num_items -= n;

	char *ptr = (char*)dst;
	size_t bytes_left = size * n;
	if (ufbxi_check_overflow(bytes_left, size, n)) {
		if (ptr) {
			ptr += bytes_left;
			uint32_t pos = b->pos;
			for (;;) {
				ufbxi_buf_chunk *chunk = b->chunk;
				if (bytes_left <= pos) {
					// Rest of the data is in this single chunk
					pos -= (uint32_t)bytes_left;
					b->pos = pos;
					ptr -= bytes_left;
					memcpy(ptr, chunk->data + pos, bytes_left);
					return;
				} else {
					// Pop the whole chunk
					ptr -= pos;
					bytes_left -= pos;
					memcpy(ptr, chunk->data, pos);
					chunk = chunk->prev;
					b->chunk = chunk;
					b->size = chunk->size;
					pos = chunk->pushed_pos;
				}
			}
		} else {
			uint32_t pos = b->pos;
			for (;;) {
				ufbxi_buf_chunk *chunk = b->chunk;
				if (bytes_left <= pos) {
					// Rest of the data is in this single chunk
					pos -= (uint32_t)bytes_left;
					b->pos = pos;
					return;
				} else {
					// Pop the whole chunk
					bytes_left -= pos;
					chunk = chunk->prev;
					b->chunk = chunk;
					b->size = chunk->size;
					pos = chunk->pushed_pos;
				}
			}
		}
	} else {
		// Slow path, equivalent to the branch above
		if (ptr) {
			for (size_t i = 0; i < n; i++) ptr += size;
		}
		while (n > 0) {
			ufbx_assert(b->chunk);
			while (b->pos == 0) {
				ufbx_assert(b->chunk->prev);
				b->chunk = b->chunk->prev;
				b->pos = b->chunk->pushed_pos;
				b->size = b->chunk->size;
			}
			ufbx_assert(b->pos >= size);
			b->pos -= (uint32_t)size;
			if (ptr) {
				ptr -= size;
				memcpy(ptr, b->chunk->data + b->pos, size);
			}
		}
	}
}

static void *ufbxi_push_pop_size(ufbxi_buf *dst, ufbxi_buf *src, size_t size, size_t n)
{
	void *data = ufbxi_push_size_uninit(dst, size, n);
	if (!data) return NULL;
	ufbxi_pop_size(src, size, n, data);
	return data;
}

static void *ufbxi_make_array_size(ufbxi_buf *b, size_t size, size_t n)
{
	size_t total = size * n;
	if (!ufbxi_check_overflow(total, size, n)) return NULL;

	if (total <= b->pos) {
		return b->chunk->data + b->pos - total;
	} else {
		// Make a local copy of the current buffer state, push the
		// whole array contiguously to the buffer, and pop the values
		// from the local copy.
		ufbxi_buf tmp = *b;
		void *dst = ufbxi_push_size_uninit(b, size, n);
		if (dst) {
			ufbxi_pop_size(&tmp, size, n, dst);
		}
		return dst;
	}
}

static void ufbxi_buf_free(ufbxi_buf *buf)
{
	ufbxi_buf_chunk *chunk = buf->chunk;
	while (chunk) {
		ufbxi_buf_chunk *next = chunk->prev;
		ufbxi_free_size(buf->ator, 1, chunk, sizeof(ufbxi_buf_chunk) + buf->size);
		chunk = next;
	}
	memset(buf, 0, sizeof(ufbxi_buf));
}

static void ufbxi_buf_clear(ufbxi_buf *buf)
{
	ufbxi_buf_chunk *chunk = buf->chunk;
	if (chunk) {
		buf->chunk = chunk->root;
		buf->pos = 0;
		buf->size = chunk->size;
		buf->num_items = 0;
	}
}

#define ufbxi_push_uninit(b, type, n) (type*)ufbxi_push_size_uninit((b), sizeof(type), (n))
#define ufbxi_push_zero(b, type, n) (type*)ufbxi_push_size_zero((b), sizeof(type), (n))
#define ufbxi_push_copy(b, type, n, data) (type*)ufbxi_push_size_copy((b), sizeof(type), (n), (data))
#define ufbxi_pop(b, type, n, dst) ufbxi_pop_size((b), sizeof(type), (n), (dst))
#define ufbxi_push_pop(dst, src, type, n) (type*)ufbxi_push_pop_size((dst), (src), sizeof(type), (n))
#define ufbxi_make_array(b, type, n) (type*)ufbxi_make_array_size((b), sizeof(type), (n))

// -- (Uint)Pointer map

typedef struct {
	uintptr_t key;
	uintptr_t val;
} ufbxi_ptr_map_entry;

typedef struct {
	ufbxi_ptr_map_entry *entries;
	uint32_t map_size;
} ufbxi_ptr_map;

static uint32_t ufbxi_ceil_pow2(uint32_t v)
{
	// https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
	v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++;
	return v > 0 ? v : 1;
}

static uint32_t ufbxi_uintptr_hash(uintptr_t up)
{
	// TODO: 64-bit hash?
	uint32_t x = (uint32_t)up;
    x ^= x >> 16;
    x *= UINT32_C(0x7feb352d);
    x ^= x >> 15;
    x *= UINT32_C(0x846ca68b);
    x ^= x >> 16;
    return x;
}

ufbxi_nodiscard static int ufbxi_ptr_map_init(ufbxi_ptr_map *map, uint32_t size, ufbxi_allocator *ator)
{
	map->map_size = ufbxi_ceil_pow2(size * 2);
	map->entries = ufbxi_alloc_zero(ator, ufbxi_ptr_map_entry, map->map_size);
	return map->entries != NULL;
}

static uintptr_t ufbxi_ptr_map_insert_up(ufbxi_ptr_map *map, uintptr_t key, uintptr_t val)
{
	ufbx_assert(map->map_size > 0);
	uint32_t hash = ufbxi_uintptr_hash(key);
	ufbxi_ptr_map_entry *entries = map->entries;
	uint32_t mask = map->map_size - 1;
	for (uint32_t ix = hash; ; ix++) {
		ufbxi_ptr_map_entry *entry = &entries[ix & mask];
		if (entry->key == key) {
			return entry->val;
		} else if (entry->key == 0) {
			entry->key = key;
			entry->val = val;
			return val;
		}
	}
}

static uintptr_t ufbxi_ptr_map_find_up(ufbxi_ptr_map *map, uintptr_t key)
{
	ufbx_assert(map->map_size > 0);
	uint32_t hash = ufbxi_uintptr_hash(key);
	ufbxi_ptr_map_entry *entries = map->entries;
	uint32_t mask = map->map_size - 1;
	for (uint32_t ix = hash; ; ix++) {
		ufbxi_ptr_map_entry *entry = &entries[ix & mask];
		if (entry->key == key) {
			return entry->val;
		} else if (entry->key == 0) {
			return 0;
		}
	}
}

static void ufbxi_ptr_map_free(ufbxi_ptr_map *map, ufbxi_allocator *ator)
{
	ufbxi_free(ator, ufbxi_ptr_map_entry, map->entries, map->map_size);
	map->entries = NULL;
	map->map_size = 0;
}

#define ufbxi_ptr_map_insert(map, type, key, val) (type)ufbxi_ptr_map_insert_up((map), (uintptr_t)(key), (uintptr_t)(val))
#define ufbxi_ptr_map_find(map, type, key) (type)ufbxi_ptr_map_find_up((map), (uintptr_t)(key))

// -- String constants

static const char ufbxi_FBXHeaderExtension[] = "FBXHeaderExtension";
static const char ufbxi_FBXVersion[] = "FBXVersion";
static const char ufbxi_Definitions[] = "Definitions";
static const char ufbxi_Objects[] = "Objects";
static const char ufbxi_Model[] = "Model";
static const char ufbxi_Geometry[] = "Geometry";
static const char ufbxi_Vertices[] = "Vertices";
static const char ufbxi_PolygonVertexIndex[] = "PolygonVertexIndex";
static const char ufbxi_Edges[] = "Edges";

static ufbx_string ufbxi_strings[] = {
	{ ufbxi_FBXHeaderExtension, sizeof(ufbxi_FBXHeaderExtension) - 1 },
	{ ufbxi_FBXVersion, sizeof(ufbxi_FBXVersion) - 1 },
	{ ufbxi_Definitions, sizeof(ufbxi_Definitions) - 1 },
	{ ufbxi_Objects, sizeof(ufbxi_Objects) - 1 },
	{ ufbxi_Model, sizeof(ufbxi_Model) - 1 },
	{ ufbxi_Geometry, sizeof(ufbxi_Geometry) - 1 },
	{ ufbxi_Vertices, sizeof(ufbxi_Vertices) - 1 },
	{ ufbxi_PolygonVertexIndex, sizeof(ufbxi_PolygonVertexIndex) - 1 },
	{ ufbxi_Edges, sizeof(ufbxi_Edges) - 1 },
};

// -- Node state machine

typedef enum {
	UFBXI_PARSE_ROOT,
	UFBXI_PARSE_DEFINITIONS,
	UFBXI_PARSE_OBJECTS,
	UFBXI_PARSE_MODEL,
	UFBXI_PARSE_GEOMETRY,
	UFBXI_PARSE_UNKNOWN,
} ufbxi_parse_node;

typedef struct {
	char type;
	bool result;
} ufbxi_array_info;

static ufbxi_parse_node ufbxi_get_parse_node(ufbxi_parse_node node, const char *name)
{
	switch (node) {

	case UFBXI_PARSE_ROOT:
		if (name == ufbxi_Definitions) return UFBXI_PARSE_DEFINITIONS;
		if (name == ufbxi_Objects) return UFBXI_PARSE_OBJECTS;
		break;

	case UFBXI_PARSE_OBJECTS:
		if (name == ufbxi_Model) return UFBXI_PARSE_MODEL;
		if (name == ufbxi_Geometry) return UFBXI_PARSE_GEOMETRY;
		break;

	}

	return UFBXI_PARSE_UNKNOWN;
}

static bool ufbxi_is_array_node(ufbxi_parse_node node, const char *name, ufbxi_array_info *info)
{
	switch (node) {

	case UFBXI_PARSE_GEOMETRY:
	case UFBXI_PARSE_MODEL:
		if (name == ufbxi_Vertices) {
			info->type = 'r';
			info->result = true;
			return true;
		} else if (name == ufbxi_PolygonVertexIndex) {
			info->type = 'i';
			info->result = true;
			return true;
		} else if (name == ufbxi_Edges) {
			info->type = 'i';
			info->result = false;
			return true;
		}
		break;

	}

	return false;
}

// -- Type definitions

typedef struct {
	uint32_t hash;
	uint32_t length;
	const char *data;
} ufbxi_string_pool_entry;

typedef struct {
	ufbxi_string_pool_entry *entries;
	size_t map_size;
	size_t num_entries;
	size_t max_entries;
} ufbxi_string_pool;

typedef struct ufbxi_node ufbxi_node;

typedef enum {
	UFBXI_PROP_NONE,
	UFBXI_PROP_NUMBER,
	UFBXI_PROP_STRING,
	UFBXI_PROP_ARRAY,
} ufbxi_prop_type;

typedef union {
	struct { double f; int64_t i; }; // if `UFBXI_PROP_NUMBER`
	ufbx_string s;                   // if `UFBXI_PROP_STRING`
} ufbxi_prop_value;

typedef struct {
	void *data;
	size_t num_elements;
	char type;
} ufbxi_prop_array;

struct ufbxi_node {
	const char *name;
	uint32_t num_children;
	uint8_t name_len;
	uint16_t prop_type_mask;

	ufbxi_node *children;
	union {
		ufbxi_prop_array *prop_array; // if `prop_type_mask == UFBXI_PROP_ARRAY`
		ufbxi_prop_value *prop_val;   // otherwise
	};
};

typedef struct {

	uint32_t version;
	bool from_ascii;
	bool big_endian;

	ufbx_load_opts opts;

	// IO
	uint64_t data_offset;

	ufbx_read_fn *read_fn;
	void *read_user;

	char *read_buffer;
	size_t read_buffer_size;

	const char *data_begin;
	const char *data;
	size_t data_size;

	// Allocators
	ufbxi_allocator ator_result;
	ufbxi_allocator ator_tmp;

	// String pool
	ufbxi_string_pool string_pool;

	// Conversion source buffer
	char *convert_buf;
	size_t convert_buf_size;

	// Temporary buffers
	ufbxi_buf tmp;
	ufbxi_buf tmp_node;

	// Result buffers
	ufbxi_buf result;
	ufbxi_buf string_buf;

	ufbxi_node root;

	ufbx_error error;

	ufbx_inflate_retain *inflate_retain;

} ufbxi_context;

static ufbxi_noinline int ufbxi_fail_imp(ufbxi_context *uc, const char *cond, const char *func, uint32_t line)
{
	return ufbxi_fail_imp_err(&uc->error, cond, func, line);
}

#define ufbxi_check(cond) if (!(cond)) return ufbxi_fail_imp(uc, "ufbxi_check(" #cond ")", __FUNCTION__, __LINE__)
#define ufbxi_check_return(cond, ret) do { if (!(cond)) { ufbxi_fail_imp(uc, "ufbxi_check_return(" #cond ", " #ret ")", __FUNCTION__, __LINE__); return ret; } } while (0)

#define ufbxi_fail(desc) return ufbxi_fail_imp(uc, desc, __FUNCTION__, __LINE__)
#define ufbxi_fail_uc(uc, desc) return ufbxi_fail_imp(uc, desc, __FUNCTION__, __LINE__)

// -- String pool

static uint32_t ufbxi_string_hash(const char *str, size_t length)
{
	uint32_t hash = 0;
	uint32_t seed = UINT32_C(0x9e3779b9);
	if (length >= 4) {
		do {
			uint32_t word = ufbxi_read_u32(str);
			hash = ((hash << 5u | hash >> 27u) ^ word) * seed;
			str += 4;
			length -= 4;
		} while (length >= 4);

		uint32_t word = ufbxi_read_u32(str + length - 4);
		hash = ((hash << 5u | hash >> 27u) ^ word) * seed;
		return hash;
	} else {
		uint32_t word = 0;
		if (length >= 1) word |= (uint32_t)(uint8_t)str[0] << 0;
		if (length >= 2) word |= (uint32_t)(uint8_t)str[1] << 8;
		if (length >= 3) word |= (uint32_t)(uint8_t)str[2] << 16;
		hash = ((hash << 5u | hash >> 27u) ^ word) * seed;
		return hash;
	}
}

ufbxi_nodiscard static const char *ufbxi_push_string_imp(ufbxi_context *uc, const char *str, size_t length, bool copy)
{
	if (length == 0) return "";
	if (length >= UFBXI_MAX_STRING_LENGTH) return NULL;
	ufbxi_string_pool pool = uc->string_pool;

	// Re-hash the old string pool if necessary
	if (pool.num_entries == pool.max_entries) {
		// TODO: Set this number based on experimental data
		pool.map_size = ufbxi_max_sz(pool.map_size * 2, 512);
		pool.entries = ufbxi_alloc_zero(&uc->ator_tmp, ufbxi_string_pool_entry, pool.map_size);
		ufbxi_check_return(pool.entries, NULL);

		pool.max_entries = pool.map_size / 2;

		ufbxi_string_pool old_pool = uc->string_pool;
		for (size_t i = 0; i < old_pool.map_size; i++) {
			ufbxi_string_pool_entry *src = &old_pool.entries[i];
			if (!src->length) continue;
			for (uint32_t ix = src->hash; ; ix++) {
				ufbxi_string_pool_entry *dst = &pool.entries[ix & (pool.map_size - 1)];
				if (dst->length == 0) {
					*dst = *src;
					break;
				}
			}
		}
		ufbxi_free(&uc->ator_tmp, ufbxi_string_pool_entry, old_pool.entries, old_pool.map_size);

		uc->string_pool = pool;
	}

	if (pool.num_entries >= UFBXI_MAX_STRINGS) return NULL;

	uint32_t hash = ufbxi_string_hash(str, length);
	for (uint32_t ix = hash; ; ix++) {
		ufbxi_string_pool_entry *entry = &pool.entries[ix & (pool.map_size - 1)];
		if (entry->hash == hash && entry->length == length && !memcmp(str, entry->data, length)) {
			return entry->data;
		} else if (entry->length == 0) {
			uc->string_pool.num_entries = pool.num_entries + 1;

			const char *data;
			if (copy) {
				char *dst = ufbxi_push_uninit(&uc->string_buf, char, length + 1);
				ufbxi_check_return(dst, NULL);
				memcpy(dst, str, length);
				dst[length] = '\0';
				data = dst;
			} else {
				data = str;
			}

			entry->data = data;
			entry->hash = hash;
			entry->length = (uint32_t)length;
			return data;
		}
	}
}

ufbxi_nodiscard static ufbxi_forceinline const char *ufbxi_push_string(ufbxi_context *uc, const char *str, size_t length)
{
	return ufbxi_push_string_imp(uc, str, length, true);
}

ufbxi_nodiscard static ufbxi_forceinline int ufbxi_push_string_place(ufbxi_context *uc, const char **p_str, size_t length)
{
	const char *str = *p_str;
	ufbxi_check(str || length == 0);
	str = ufbxi_push_string(uc, str, length);
	ufbxi_check(str);
	*p_str = str;
	return 1;
}

ufbxi_nodiscard static ufbxi_forceinline int ufbxi_push_string_place_str(ufbxi_context *uc, ufbx_string *p_str)
{
	ufbxi_check(p_str);
	return ufbxi_push_string_place(uc, &p_str->data, p_str->length);
}

// -- IO

static ufbxi_noinline const char *ufbxi_refill(ufbxi_context *uc, size_t size)
{
	ufbx_assert(uc->data_size < size);
	ufbxi_check_return(uc->read_fn, NULL);

	if (size > uc->read_buffer_size) {
		size_t new_size = ufbxi_max_sz(size, UFBXI_READ_BUFFER_SIZE);
		ufbxi_check_return(ufbxi_grow_array_uninit(&uc->ator_tmp, &uc->read_buffer, &uc->read_buffer_size, new_size), NULL);
	}

	size_t num_read = uc->data_size;
	memmove(uc->read_buffer, uc->data, num_read);
	num_read += uc->read_fn(uc->read_user, uc->read_buffer + num_read, uc->read_buffer_size - num_read);
	ufbxi_check_return(num_read >= size, NULL);

	uc->data_offset += uc->data - uc->data_begin;
	uc->data_begin = uc->data = uc->read_buffer;
	uc->data_size = num_read;

	return uc->read_buffer;
}

static ufbxi_forceinline const char *ufbxi_peek_bytes(ufbxi_context *uc, size_t size)
{
	if (uc->data_size >= size) {
		return uc->data;
	} else {
		return ufbxi_refill(uc, size);
	}
}

static ufbxi_forceinline const char *ufbxi_read_bytes(ufbxi_context *uc, size_t size)
{
	const char *ret;
	if (uc->data_size >= size) {
		ret = uc->data;
	} else {
		ret = ufbxi_refill(uc, size);
		if (!ret) return NULL;
	}
	uc->data_size -= size;
	uc->data = ret + size;
	return ret;
}

static ufbxi_forceinline void ufbxi_consume_bytes(ufbxi_context *uc, size_t size)
{
	ufbx_assert(size <= uc->data_size);
	uc->data_size -= size;
	uc->data += size;
}


ufbxi_nodiscard static int ufbxi_skip_bytes(ufbxi_context *uc, uint64_t size)
{
	while (size > 0) {
		uint64_t to_skip = ufbxi_min64(size, UFBXI_READ_BUFFER_SIZE);
		ufbxi_check(ufbxi_read_bytes(uc, (size_t)to_skip));
		size -= to_skip;
	}

	return 1;
}

static int ufbxi_read_to(ufbxi_context *uc, void *dst, size_t size)
{
	char *ptr = (char*)dst;

	size_t len = ufbxi_min_sz(uc->data_size, size);
	memcpy(ptr, uc->data, len);
	uc->data += len;
	uc->data_size -= len;
	ptr += len;
	size -= len;

	if (size > 0) {
		uc->data_offset += uc->data - uc->data_begin;
		ufbxi_check(uc->read_fn);
		len = uc->read_fn(uc->read_user, ptr, size);
		ufbxi_check(len == size);
	}

	return 1;
}

static ufbxi_forceinline uint64_t ufbxi_get_read_offset(ufbxi_context *uc)
{
	return uc->data_offset + (uc->data - uc->data_begin);
}

static ufbxi_forceinline bool ufbxi_parse_bool(char c)
{
	// Treat \0, 'F', 'N' as falsey values, other values are true
	return (c == 0 || c == 'F' || c == 'N' || c == '0') ? 0 : 1;
}

// -- Node operations

static ufbxi_node *ufbxi_find_child(ufbxi_node *node, const char *name)
{
	ufbxi_for(ufbxi_node, c, node->children, node->num_children) {
		if (c->name == name) return c;
	}
	return NULL;
}

ufbxi_nodiscard ufbxi_forceinline static int ufbxi_get_val_at(ufbxi_node *node, size_t ix, char fmt, void *v)
{
	ufbxi_prop_type type = (ufbxi_prop_type)((node->prop_type_mask >> (ix*2)) & 0x3);
	switch (fmt) {
	case '_': return 1;
	case 'I': if (type == UFBXI_PROP_NUMBER) { *(int32_t*)v = (int32_t)node->prop_val[ix].i; return 1; } else return 0;
	case 'L': if (type == UFBXI_PROP_NUMBER) { *(int64_t*)v = (int64_t)node->prop_val[ix].i; return 1; } else return 0;
	case 'F': if (type == UFBXI_PROP_NUMBER) { *(float*)v = (float)node->prop_val[ix].i; return 1; } else return 0;
	case 'D': if (type == UFBXI_PROP_NUMBER) { *(double*)v = (double)node->prop_val[ix].i; return 1; } else return 0;
	case 'R': if (type == UFBXI_PROP_NUMBER) { *(ufbx_real*)v = (ufbx_real)node->prop_val[ix].i; return 1; } else return 0;
	case 'B': if (type == UFBXI_PROP_NUMBER) { *(bool*)v = node->prop_val[ix].i != 0; return 1; } else return 0;
	case 'S': if (type == UFBXI_PROP_STRING) { *(ufbx_string*)v = node->prop_val[ix].s; return 1; } else return 0;
	case 'C': if (type == UFBXI_PROP_STRING) { *(const char**)v = node->prop_val[ix].s.data; return 1; } else return 0;
	default:
		ufbx_assert(0 && "Bad format char");
		return 0;
	}
}

ufbxi_nodiscard static ufbxi_forceinline int ufbxi_get_val1(ufbxi_node *node, const char *fmt, void *v0)
{
	if (!ufbxi_get_val_at(node, 0, fmt[0], v0)) return 0;
	return 1;
}

ufbxi_nodiscard static ufbxi_forceinline int ufbxi_get_val2(ufbxi_node *node, const char *fmt, void *v0, void *v1)
{
	if (!ufbxi_get_val_at(node, 0, fmt[0], v0)) return 0;
	if (!ufbxi_get_val_at(node, 1, fmt[1], v1)) return 0;
	return 1;
}

ufbxi_nodiscard static ufbxi_forceinline int ufbxi_get_val3(ufbxi_node *node, const char *fmt, void *v0, void *v1, void *v2)
{
	if (!ufbxi_get_val_at(node, 0, fmt[0], v0)) return 0;
	if (!ufbxi_get_val_at(node, 1, fmt[1], v1)) return 0;
	if (!ufbxi_get_val_at(node, 2, fmt[2], v2)) return 0;
	return 1;
}

ufbxi_nodiscard static ufbxi_forceinline int ufbxi_find_val1(ufbxi_node *node, const char *name, const char *fmt, void *v0)
{
	ufbxi_node *child = ufbxi_find_child(node, name);
	if (!child) return 0;
	if (!ufbxi_get_val_at(child, 0, fmt[0], v0)) return 0;
	return 1;
}

ufbxi_nodiscard static ufbxi_forceinline int ufbxi_find_val2(ufbxi_node *node, const char *name, const char *fmt, void *v0, void *v1)
{
	ufbxi_node *child = ufbxi_find_child(node, name);
	if (!child) return 0;
	if (!ufbxi_get_val_at(child, 0, fmt[0], v0)) return 0;
	if (!ufbxi_get_val_at(child, 1, fmt[1], v1)) return 0;
	return 1;
}

// -- Binary parsing

static char ufbxi_normalize_array_type(char type) {
	switch (type) {
	case 'r': return sizeof(ufbx_real) == sizeof(float) ? 'f' : 'd';
	case 'c': return 'b';
	default: return type;
	}
}

size_t ufbxi_array_type_size(char type)
{
	switch (type) {
	case 'r': return sizeof(ufbx_real);
	case 'b': return sizeof(bool);
	case 'i': return sizeof(int32_t);
	case 'l': return sizeof(int64_t);
	case 'f': return sizeof(float);
	case 'd': return sizeof(double);
	default: return 1;
	}
}

ufbxi_nodiscard static ufbxi_noinline int ufbxi_convert_array(ufbxi_context *uc, char src_type, char dst_type, const void *src, void *dst, size_t size)
{
	switch (dst_type)
	{

	#define ufbxi_convert_loop(m_dst, m_size, m_expr) { \
		const char *val = (const char*)src, *val_end = val + size*m_size; \
		m_dst *d = (m_dst*)dst; \
		while (val != val_end) { *d++ = (m_dst)(m_expr); val += m_size; } }

	#define ufbxi_convert_switch(m_dst) \
		switch (src_type) { \
		case 'b': ufbxi_convert_loop(m_dst, 1, ufbxi_parse_bool(*val)); break; \
		case 'i': ufbxi_convert_loop(m_dst, 4, ufbxi_read_i32(val)); break; \
		case 'l': ufbxi_convert_loop(m_dst, 8, ufbxi_read_i64(val)); break; \
		case 'f': ufbxi_convert_loop(m_dst, 4, ufbxi_read_f32(val)); break; \
		case 'd': ufbxi_convert_loop(m_dst, 8, ufbxi_read_f64(val)); break; \
		default: ufbxi_fail("Bad array source type"); \
		} \
		break; \

	case 'b':
		switch (src_type) {
		case 'b': ufbxi_convert_loop(char, 1, ufbxi_parse_bool(*val)); break;
		case 'i': ufbxi_convert_loop(char, 4, ufbxi_read_i32(val) != 0); break;
		case 'l': ufbxi_convert_loop(char, 8, ufbxi_read_i64(val) != 0); break;
		case 'f': ufbxi_convert_loop(char, 4, ufbxi_read_f32(val) != 0); break;
		case 'd': ufbxi_convert_loop(char, 8, ufbxi_read_f64(val) != 0); break;
		default: ufbxi_fail("Bad array source type");
		}
		break;

	case 'i': ufbxi_convert_switch(int32_t); break;
	case 'l': ufbxi_convert_switch(int64_t); break;
	case 'f': ufbxi_convert_switch(float); break;
	case 'd': ufbxi_convert_switch(double); break;

	default: return 0;

	}

	return 1;
}

ufbxi_nodiscard static ufbxi_noinline int ufbxi_parse_multivalue_array(ufbxi_context *uc, char dst_type, void *dst, size_t size)
{
	if (size == 0) return 1;
	const char *val;
	size_t val_size;

	switch (dst_type)
	{

	#define ufbxi_convert_parse(m_dst, m_size, m_expr) \
		*d++ = (m_dst)(m_expr); val_size = m_size + 1; \

	#define ufbxi_convert_parse_switch(m_dst) { \
		m_dst *d = (m_dst*)dst; \
		for (size_t i = 0; i < size; i++) { \
			val = ufbxi_peek_bytes(uc, 13); \
			ufbxi_check(val); \
			switch (*val++) { \
				case 'C': \
				case 'B': ufbxi_convert_parse(m_dst, 1, ufbxi_parse_bool(*val)); break; \
				case 'Y': ufbxi_convert_parse(m_dst, 2, ufbxi_read_i16(val)); break; \
				case 'I': ufbxi_convert_parse(m_dst, 4, ufbxi_read_i32(val)); break; \
				case 'L': ufbxi_convert_parse(m_dst, 8, ufbxi_read_i64(val)); break; \
				case 'F': ufbxi_convert_parse(m_dst, 4, ufbxi_read_f32(val)); break; \
				case 'D': ufbxi_convert_parse(m_dst, 8, ufbxi_read_f64(val)); break; \
				default: ufbxi_fail("Bad multivalue array type"); \
			} \
			ufbxi_consume_bytes(uc, val_size); \
		} \
	} \

	case 'b':
	{
		char *d = (char*)dst;
		for (size_t i = 0; i < size; i++) {
			val = ufbxi_peek_bytes(uc, 13);
			ufbxi_check(val);
			switch (*val++) {
				case 'C':
				case 'B': ufbxi_convert_parse(char, 1, ufbxi_parse_bool(*val)); break;
				case 'Y': ufbxi_convert_parse(char, 2, ufbxi_read_i16(val) != 0); break;
				case 'I': ufbxi_convert_parse(char, 4, ufbxi_read_i32(val) != 0); break;
				case 'L': ufbxi_convert_parse(char, 8, ufbxi_read_i64(val) != 0); break;
				case 'F': ufbxi_convert_parse(char, 4, ufbxi_read_f32(val) != 0); break;
				case 'D': ufbxi_convert_parse(char, 8, ufbxi_read_f64(val) != 0); break;
				default: ufbxi_fail("Bad multivalue array type");
			}
			ufbxi_consume_bytes(uc, val_size);
		}
	}
	break;

	case 'i': ufbxi_convert_parse_switch(int32_t); break;
	case 'l': ufbxi_convert_parse_switch(int64_t); break;
	case 'f': ufbxi_convert_parse_switch(float); break;
	case 'd': ufbxi_convert_parse_switch(double); break;

	default: return 0;

	}

	return 1;
}

ufbxi_nodiscard static int ufbxi_binary_parse_node(ufbxi_context *uc, uint32_t depth, ufbxi_parse_node parent_parse_node, bool *p_end)
{
	ufbxi_check(depth < UFBXI_MAX_NODE_DEPTH);

	uint64_t end_offset, num_values, values_len;
	uint8_t name_len;

	// Parse the node header, FBX versions over 7500 use 64-bit values for
	// most fields.
	// https://code.blender.org/2013/08/fbx-binary-file-format-specification/#node-record-format
	size_t header_size = (uc->version >= 7500) ? 25 : 13;
	const char *header = ufbxi_read_bytes(uc, header_size);
	ufbxi_check(header);
	if (uc->version >= 7500) {
		end_offset = ufbxi_read_u64(header + 0);
		num_values = ufbxi_read_u64(header + 8);
		values_len = ufbxi_read_u64(header + 16);
		name_len = ufbxi_read_u8(header + 24);
	} else {
		end_offset = ufbxi_read_u32(header + 0);
		num_values = ufbxi_read_u32(header + 4);
		values_len = ufbxi_read_u32(header + 8);
		name_len = ufbxi_read_u8(header + 12);
	}

	if (end_offset == 0) {
		*p_end = true;
		return 1;
	}

	ufbxi_node *node = ufbxi_push_zero(&uc->tmp_node, ufbxi_node, 1);
	ufbxi_check(node);

	node->name_len = name_len;

	const char *name = ufbxi_read_bytes(uc, name_len);
	name = ufbxi_push_string(uc, name, name_len);
	ufbxi_check(name);
	node->name = name;

	uint64_t values_end_offset = ufbxi_get_read_offset(uc) + values_len;

	ufbxi_parse_node parse_node = ufbxi_get_parse_node(parent_parse_node, name);

	ufbxi_array_info arr_info;
	if (ufbxi_is_array_node(parent_parse_node, name, &arr_info)) {
		// Parse values as an array
		const char *data = ufbxi_peek_bytes(uc, 13);
		ufbxi_check(data);

		char dst_type = ufbxi_normalize_array_type(arr_info.type);
		size_t dst_elem_size = ufbxi_array_type_size(dst_type);

		ufbxi_prop_array *arr = ufbxi_push_uninit(&uc->tmp, ufbxi_prop_array, 1);
		ufbxi_check(arr);

		node->prop_array = arr;
		node->prop_type_mask = UFBXI_PROP_ARRAY;

		arr->type = dst_type;

		ufbxi_buf *buf = arr_info.result ? &uc->result : &uc->tmp;

		char c = data[0];
		if (c=='c' || c=='b' || c=='i' || c=='l' || c =='f' || c=='d') {

			char src_type = data[0];
			uint32_t size = ufbxi_read_u32(data + 1); 
			uint32_t encoding = ufbxi_read_u32(data + 5); 
			uint32_t encoded_size = ufbxi_read_u32(data + 9); 
			ufbxi_consume_bytes(uc, 13);

			char *arr_data = (char*)ufbxi_push_size_uninit(buf, dst_elem_size, size);
			ufbxi_check(arr_data);

			arr->data = arr_data;
			arr->num_elements = (size_t)size;

			// Don't normalize UFBX-specific "real" to f/d
			if (src_type != 'r') {
				src_type = ufbxi_normalize_array_type(src_type);
			}

			size_t src_elem_size = ufbxi_array_type_size(src_type);
			size_t src_data_size = src_elem_size * size;

			// If the source and destination types differ we need to read the array
			// into a temporary buffer first and then convert it to the final buffer.
			// If we are on a big endian machine we must run the convert loop even
			// on equal types to swap the bytes.
			void *src_data = arr_data;
			if (src_type != dst_type || uc->big_endian) {
				if (uc->convert_buf_size < src_data_size) {
					ufbxi_grow_array_uninit(&uc->ator_tmp, &uc->convert_buf, &uc->convert_buf_size, src_data_size);
				}
				src_data = uc->convert_buf;
			}

			if (encoding == 0) {
				// Encoding 0: Plain binary data
				if (uc->data_size >= encoded_size && src_data != arr_data) {
					src_data = (void*)uc->data;
					ufbxi_consume_bytes(uc, encoded_size);
				} else {
					ufbxi_check(ufbxi_read_to(uc, src_data, encoded_size));
				}
			} else if (encoding == 1) {
				// Encoding 1: DEFLATE
				if (uc->read_buffer_size < UFBXI_READ_BUFFER_SIZE) {
					size_t new_size = UFBXI_READ_BUFFER_SIZE;
					ufbxi_check(ufbxi_grow_array_uninit(&uc->ator_tmp, &uc->read_buffer, &uc->read_buffer_size, new_size));
				}

				ufbx_inflate_input input;
				input.total_size = encoded_size;
				input.data = uc->data;
				input.data_size = uc->data_size;
				input.buffer = uc->read_buffer;
				input.buffer_size = uc->read_buffer_size;
				input.read_fn = uc->read_fn;
				input.read_user = uc->read_user;

				ptrdiff_t res = ufbx_inflate(src_data, src_data_size, &input, uc->inflate_retain);
				ufbxi_check(res == src_data_size);

				if (encoded_size > input.data_size) {
					uc->data_offset += encoded_size - input.data_size;
					uc->data += input.data_size;
					uc->data_size = 0;
				} else {
					uc->data += encoded_size;
					uc->data_size -= encoded_size;
				}
			} else {
				ufbxi_fail("Bad array encoding");
			}

			if (src_type != dst_type || uc->big_endian) {
				ufbxi_check(ufbxi_convert_array(uc, src_type, dst_type, src_data, arr_data, size));
			} else if (dst_type == 'b') {
				// If we didn't perform conversion but use the "bool" type we need
				// to normalize the array contents afterwards.
				ufbxi_for(char, c, (char*)arr_data, size) {
					*c = (char)ufbxi_parse_bool(*c);
				}
			}

		} else {
			char *arr_data = (char*)ufbxi_push_size_uninit(buf, dst_elem_size, (size_t)num_values);
			ufbxi_check(arr_data);

			arr->data = arr_data;
			arr->num_elements = (size_t)num_values;

			// Parse single elements as an array
			ufbxi_check(ufbxi_parse_multivalue_array(uc, dst_type, arr_data, (size_t)num_values));
		}

	} else {
		// Parse values as normal values
		num_values = ufbxi_min64((size_t)num_values, UFBXI_MAX_NON_ARRAY_VALUES);
		ufbxi_prop_value *vals = ufbxi_push_uninit(&uc->tmp, ufbxi_prop_value, (size_t)num_values);
		ufbxi_check(vals);
		node->prop_val = vals;

		uint32_t prop_type_mask = 0;
		for (size_t i = 0; i < (size_t)num_values; i++) {
			// The file must end in at least a 13-byte NULL terminal node
			// so we can safely read at least 13 bytes
			const char *data = ufbxi_peek_bytes(uc, 13);
			ufbxi_check(data);

			switch (data[0]) {

			// TODO: Looks like old FBX files use 'C' with 'T'/'F' as well?
			case 'C': case 'B':
				prop_type_mask |= UFBXI_PROP_NUMBER << (i*2);
				vals[i].f = (double)(vals[i].i = ufbxi_parse_bool(data[1]));
				ufbxi_consume_bytes(uc, 2);
				break;

			case 'Y':
				prop_type_mask |= UFBXI_PROP_NUMBER << (i*2);
				vals[i].f = (double)(vals[i].i = ufbxi_read_i16(data + 1));
				ufbxi_consume_bytes(uc, 3);
				break;

			case 'I':
				prop_type_mask |= UFBXI_PROP_NUMBER << (i*2);
				vals[i].f = (double)(vals[i].i = ufbxi_read_i32(data + 1));
				ufbxi_consume_bytes(uc, 5);
				break;

			case 'L':
				prop_type_mask |= UFBXI_PROP_NUMBER << (i*2);
				vals[i].f = (double)(vals[i].i = ufbxi_read_i64(data + 1));
				ufbxi_consume_bytes(uc, 9);
				break;

			case 'F':
				prop_type_mask |= UFBXI_PROP_NUMBER << (i*2);
				vals[i].i = (int64_t)(vals[i].f = ufbxi_read_f32(data + 1));
				ufbxi_consume_bytes(uc, 5);
				break;

			case 'D':
				prop_type_mask |= UFBXI_PROP_NUMBER << (i*2);
				vals[i].i = (int64_t)(vals[i].f = ufbxi_read_f32(data + 1));
				ufbxi_consume_bytes(uc, 9);
				break;

			case 'S': case 'R':
			{
				size_t len = ufbxi_read_u32(data + 1);
				ufbxi_consume_bytes(uc, 5);
				vals[i].s.data = ufbxi_read_bytes(uc, len);
				vals[i].s.length = len;
				ufbxi_check(ufbxi_push_string_place_str(uc, &vals[i].s));
				prop_type_mask |= UFBXI_PROP_STRING << (i*2);
			}
			break;

			// Treat arrays as non-properties and skip them
			case 'c': case 'b': case 'i': case 'l': case 'f': case 'd':
			{
				uint32_t encoded_size = ufbxi_read_u32(data + 9);
				ufbxi_consume_bytes(uc, 13);
				ufbxi_check(ufbxi_skip_bytes(uc, encoded_size));
			}
			break;

			default:
				ufbxi_fail("Bad property type");

			}
		}

		node->prop_type_mask = (uint16_t)prop_type_mask;
	}

	// Skip remaining values if necessary
	uint64_t offset = ufbxi_get_read_offset(uc);
	ufbxi_check(offset <= values_end_offset);
	if (offset < values_end_offset) {
		ufbxi_skip_bytes(uc, values_end_offset - offset);
	}

	size_t num_children = 0;

	// Parse children
	for (;;) {

		// Stop at end offset
		uint64_t offset = ufbxi_get_read_offset(uc);
		if (offset >= end_offset) {
			ufbxi_check(offset == end_offset);
			break;
		}

		// Recursively read children
		bool end = false;
		ufbxi_check(ufbxi_binary_parse_node(uc, depth + 1, parse_node, &end));
		if (end) break;
		num_children++;
		ufbxi_check(num_children <= UFBXI_MAX_NODE_CHILDREN);
	}

	if (num_children) {
		node->num_children = (uint32_t)num_children;
		node->children = ufbxi_push_pop(&uc->tmp, &uc->tmp_node, ufbxi_node, num_children);
		ufbxi_check(node->children);
	}

	return 1;
}

#define UFBXI_BINARY_MAGIC_SIZE 23
#define UFBXI_BINARY_HEADER_SIZE 27
static const char ufbxi_binary_magic[] = "Kaydara FBX Binary  \x00\x1a\x00";

ufbxi_nodiscard static int ufbxi_binary_parse(ufbxi_context *uc)
{
	// Parse top-level nodes
	uint32_t num_nodes = 0;
	for (;;) {
		bool end = false;
		ufbxi_check(ufbxi_binary_parse_node(uc, 0, UFBXI_PARSE_ROOT, &end));
		if (end) break;
		num_nodes++;
	}

	// Pop top-level nodes from `tmp_node` to a contiguous array
	ufbxi_node *top_nodes = ufbxi_push_pop(&uc->tmp, &uc->tmp_node, ufbxi_node, num_nodes);
	ufbxi_check(top_nodes);

	ufbxi_buf_free(&uc->tmp_node);

	uc->root.children = top_nodes;
	uc->root.num_children = num_nodes;

	return 1;
}

// -- ASCII parsing

#define UFBXI_ASCII_END '\0'
#define UFBXI_ASCII_NAME 'N'
#define UFBXI_ASCII_BARE_WORD 'B'
#define UFBXI_ASCII_INT 'I'
#define UFBXI_ASCII_FLOAT 'F'
#define UFBXI_ASCII_STRING 'S'

typedef struct {
	char *str_data;
	size_t str_len;
	char type;
	union {
		double f64;
		int64_t i64;
		uint32_t name_len;
	} value;
} ufbxi_ascii_token;

typedef struct {
	ufbxi_context *uc;

	const char *src;
	const char *src_end;

	char token_str[2][UFBXI_ASCII_MAX_TOKEN_LENGTH];

	ufbxi_ascii_token prev_token;
	ufbxi_ascii_token token;
} ufbxi_ascii;

#define ufbxi_ascii_error(ua, desc) ufbxi_fail_uc((ua)->uc, desc)

static ufbxi_noinline char ufbxi_ascii_refill(ufbxi_ascii *ua)
{
	ufbxi_context *uc = ua->uc;
	if (uc->read_fn) {
		if (uc->read_buffer_size < UFBXI_READ_BUFFER_SIZE) {
			size_t new_size = UFBXI_READ_BUFFER_SIZE;
			ufbxi_check_return(ufbxi_grow_array_uninit(&uc->ator_tmp, &uc->read_buffer, &uc->read_buffer_size, new_size), '\0');
		}

		size_t num_read = uc->read_fn(uc->read_user, uc->read_buffer, uc->read_buffer_size);
		if (num_read == 0) return '\0';

		ua->src = uc->read_buffer;
		ua->src_end = uc->read_buffer + num_read;
		return *ua->src;
	} else {
		ua->src = "";
		ua->src_end = ua->src + 1;
		return '\0';
	}
}

static ufbxi_forceinline char ufbxi_ascii_peek(ufbxi_ascii *ua)
{
	if (ua->src == ua->src_end) return ufbxi_ascii_refill(ua);
	return *ua->src;
}

static ufbxi_forceinline char ufbxi_ascii_next(ufbxi_ascii *ua)
{
	if (ua->src == ua->src_end) return ufbxi_ascii_refill(ua);
	ua->src++;
	if (ua->src == ua->src_end) return ufbxi_ascii_refill(ua);
	return *ua->src;
}

static char ufbxi_ascii_skip_whitespace(ufbxi_ascii *ua)
{
	// Ignore whitespace
	char c = ufbxi_ascii_peek(ua);
	for (;;) {
		while (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
			c = ufbxi_ascii_next(ua);
		}
		if (c == ';') {
			c = ufbxi_ascii_next(ua);
			while (c != '\n' && c != '\0') {
				c = ufbxi_ascii_next(ua);
			}
		} else {
			break;
		}
	}
	return c;
}

ufbxi_nodiscard static int ufbxi_ascii_next_token(ufbxi_ascii *ua, ufbxi_ascii_token *token)
{
	char c = ufbxi_ascii_skip_whitespace(ua);
	token->str_len = 0;

	if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '_') {
		token->type = UFBXI_ASCII_BARE_WORD;
		uint32_t len = 0;
		while ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')
			|| (c >= '0' && c <= '9') || c == '_') {
			token->str_data[len++] = c;
			if (len >= UFBXI_ASCII_MAX_TOKEN_LENGTH) {
				ufbxi_ascii_error(ua, "Token too long");
			}
			c = ufbxi_ascii_next(ua);
		}

		token->str_len = len;

		// Skip whitespace to find if there's a following ':'
		c = ufbxi_ascii_skip_whitespace(ua);
		if (c == ':') {
			token->value.name_len = len;
			token->type = UFBXI_ASCII_NAME;
			ufbxi_ascii_next(ua);
		}
	} else if ((c >= '0' && c <= '9') || c == '-' || c == '+' || c == '.') {
		token->type = UFBXI_ASCII_INT;

		uint32_t len = 0;
		while ((c >= '0' && c <= '9') || c == '-' || c == '+' || c == '.' || c == 'e' || c == 'E') {
			if (c == '.' || c == 'e' || c == 'E') {
				token->type = UFBXI_ASCII_FLOAT;
			}
			if (len == UFBXI_ASCII_MAX_TOKEN_LENGTH - 1) {
				ufbxi_ascii_error(ua, "Number is too long");
			}
			token->str_data[len++] = c;
			c = ufbxi_ascii_next(ua);
		}
		token->str_data[len] = '\0';

		char *end;
		if (token->type == UFBXI_ASCII_INT) {
			token->value.i64 = strtoll(token->str_data, &end, 10);
			if (end != token->str_data + len) {
				ufbxi_ascii_error(ua, "Bad integer constant");
			}
		} else if (token->type == UFBXI_ASCII_FLOAT) {
			token->value.f64 = strtod(token->str_data, &end);
			if (end != token->str_data + len) {
				ufbxi_ascii_error(ua, "Bad float constant");
			}
		}
	} else if (c == '"') {
		token->type = UFBXI_ASCII_STRING;
		c = ufbxi_ascii_next(ua);
		uint32_t len = 0;
		while (c != '"') {
			token->str_data[len++] = c;
			c = ufbxi_ascii_next(ua);
			if (c == '\0') {
				ufbxi_ascii_error(ua, "Unclosed string");
			}
		}
		token->str_len = len;
		// Skip closing quote
		ufbxi_ascii_next(ua);
	} else {
		token->type = c;
		ufbxi_ascii_next(ua);
	}

	return 1;
}

ufbxi_nodiscard static int ufbxi_ascii_accept(ufbxi_ascii *ua, char type)
{
	if (ua->token.type == type) {
		char *swap_data = ua->prev_token.str_data;
		ua->prev_token = ua->token;
		ua->token.str_data = swap_data;
		if (!ufbxi_ascii_next_token(ua, &ua->token)) return 0;
		return 1;
	} else {
		return 0;
	}
}

ufbxi_nodiscard static int ufbxi_ascii_parse_node(ufbxi_ascii *ua, uint32_t depth, ufbxi_parse_node parent_parse_node)
{
	ufbxi_context *uc = ua->uc;

	if (depth >= UFBXI_ASCII_MAX_STACK_SIZE) {
		ufbxi_ascii_error(ua, "Too many nested nodes");
	}

	if (!ufbxi_ascii_accept(ua, UFBXI_ASCII_NAME)) {
		ufbxi_ascii_error(ua, "Expected node name");
	}

	uint32_t name_len = ua->prev_token.value.name_len;
	if (name_len > 0xff) {
		ufbxi_ascii_error(ua, "Node name is too long");
	}

	const char *name = ufbxi_push_string(uc, ua->prev_token.str_data, ua->prev_token.str_len);
	ufbxi_check(name);

	ufbxi_parse_node parse_node = ufbxi_get_parse_node(parent_parse_node, name);

	ufbxi_node *node = ufbxi_push_zero(&uc->tmp_node, ufbxi_node, 1);
	node->name = name;
	node->name_len = (uint8_t)name_len;

	int in_array = 0;
	size_t num_values = 0;
	uint32_t prop_type_mask = 0;

	int arr_type = 0;
	ufbxi_buf *arr_buf = NULL;

	ufbxi_array_info arr_info;
	if (ufbxi_is_array_node(parent_parse_node, name, &arr_info)) {
		arr_type = ufbxi_normalize_array_type(arr_info.type);
		arr_buf = arr_info.result ? &uc->result : &uc->tmp;

		ufbxi_prop_array *arr = ufbxi_push_uninit(&uc->tmp, ufbxi_prop_array, 1);
		ufbxi_check(arr);
		node->prop_array = arr;
		arr->type = arr_type;
	}

	ufbxi_prop_value prop_val[UFBXI_MAX_NON_ARRAY_VALUES];

	// NOTE: Infinite loop to allow skipping the comma parsing via `continue`.
	for (;;) {
		ufbxi_ascii_token *tok = &ua->prev_token;
		if (ufbxi_ascii_accept(ua, UFBXI_ASCII_STRING)) {

			if (num_values < UFBXI_MAX_NON_ARRAY_VALUES && !arr_type) {
				prop_type_mask |= UFBXI_PROP_STRING << (num_values*2);
				ufbxi_prop_value *val = &prop_val[num_values];
				val->s.data = tok->str_data;
				val->s.length = tok->str_len;
				ufbxi_check(ufbxi_push_string_place_str(uc, &val->s));
			}

		} else if (ufbxi_ascii_accept(ua, UFBXI_ASCII_INT)) {
			int64_t val = tok->value.i64;

			switch (arr_type) {

			case 0:
				if (num_values < UFBXI_MAX_NON_ARRAY_VALUES) {
					prop_type_mask |= UFBXI_PROP_NUMBER << (num_values*2);
					ufbxi_prop_value *v = &prop_val[num_values];
					v->f = (double)(v->i = val);
				}
				break;

			case 'b': { bool *v = ufbxi_push_uninit(arr_buf, bool, 1); ufbxi_check(v); *v = val != 0; } break;
			case 'i': { int32_t *v = ufbxi_push_uninit(arr_buf, int32_t, 1); ufbxi_check(v); *v = (int32_t)val; } break;
			case 'l': { int64_t *v = ufbxi_push_uninit(arr_buf, int64_t, 1); ufbxi_check(v); *v = (int64_t)val; } break;
			case 'f': { float *v = ufbxi_push_uninit(arr_buf, float, 1); ufbxi_check(v); *v = (float)val; } break;
			case 'd': { double *v = ufbxi_push_uninit(arr_buf, double, 1); ufbxi_check(v); *v = (double)val; } break;

			default:
				ufbxi_fail("Bad array dst type");

			}

		} else if (ufbxi_ascii_accept(ua, UFBXI_ASCII_FLOAT)) {
			double val = tok->value.f64;

			switch (arr_type) {

			case 0:
				if (num_values < UFBXI_MAX_NON_ARRAY_VALUES) {
					prop_type_mask |= UFBXI_PROP_NUMBER << (num_values*2);
					ufbxi_prop_value *v = &prop_val[num_values];
					v->i = (int64_t)(v->f = val);
				}
				break;

			case 'b': { bool *v = ufbxi_push_uninit(arr_buf, bool, 1); ufbxi_check(v); *v = val != 0; } break;
			case 'i': { int32_t *v = ufbxi_push_uninit(arr_buf, int32_t, 1); ufbxi_check(v); *v = (int32_t)val; } break;
			case 'l': { int64_t *v = ufbxi_push_uninit(arr_buf, int64_t, 1); ufbxi_check(v); *v = (int64_t)val; } break;
			case 'f': { float *v = ufbxi_push_uninit(arr_buf, float, 1); ufbxi_check(v); *v = (float)val; } break;
			case 'd': { double *v = ufbxi_push_uninit(arr_buf, double, 1); ufbxi_check(v); *v = (double)val; } break;

			default:
				ufbxi_fail("Bad array dst type");

			}

		} else if (ufbxi_ascii_accept(ua, UFBXI_ASCII_BARE_WORD)) {

			int64_t val = 0;
			if (tok->str_len == 1 && (tok->str_data[0] == 'Y' || tok->str_data[0] == 'T' || tok->str_data[0] == '1')) {
				val = 1;
			} else if (tok->str_len == 1 && (tok->str_data[0] == 'N' || tok->str_data[0] == 'F' || tok->str_data[0] == '0')) {
				val = 0;
			} else {
				// Ignore other bare words that tend to appear, treat them as 0
				// TODO: What does "Shading: W" mean?
			}

			switch (arr_type) {

			case 0:
				if (num_values < UFBXI_MAX_NON_ARRAY_VALUES) {
					prop_type_mask |= UFBXI_PROP_NUMBER << (num_values*2);
					ufbxi_prop_value *v = &prop_val[num_values];
					v->f = (double)(v->i = val);
				}
				break;

			case 'b': { bool *v = ufbxi_push_uninit(arr_buf, bool, 1); ufbxi_check(v); *v = val != 0; } break;
			case 'i': { int32_t *v = ufbxi_push_uninit(arr_buf, int32_t, 1); ufbxi_check(v); *v = (int32_t)val; } break;
			case 'l': { int64_t *v = ufbxi_push_uninit(arr_buf, int64_t, 1); ufbxi_check(v); *v = (int64_t)val; } break;
			case 'f': { float *v = ufbxi_push_uninit(arr_buf, float, 1); ufbxi_check(v); *v = (float)val; } break;
			case 'd': { double *v = ufbxi_push_uninit(arr_buf, double, 1); ufbxi_check(v); *v = (double)val; } break;

			}

		} else if (ufbxi_ascii_accept(ua, '*')) {
			if (in_array) {
				ufbxi_ascii_error(ua, "Nested array values");
			}
			if (!ufbxi_ascii_accept(ua, UFBXI_ASCII_INT)) {
				ufbxi_ascii_error(ua, "Expected array size");
			}
			if (ufbxi_ascii_accept(ua, '{')) {
				if (!ufbxi_ascii_accept(ua, UFBXI_ASCII_NAME)) {
					ufbxi_ascii_error(ua, "Expected array content name");
				}

				// NOTE: This `continue` skips incrementing `num_values` and parsing
				// a comma, continuing to parse the values in the array.
				in_array = 1;
				continue;
			}
		} else {
			break;
		}

		// Add value and keep parsing if there's a comma. This part may be
		// skipped if we enter an array block.
		num_values++;
		if (!ufbxi_ascii_accept(ua, ',')) break;
	}

	if (in_array) {
		if (!ufbxi_ascii_accept(ua, '}')) {
			ufbxi_ascii_error(ua, "Unclosed value array");
		}
	}

	if (arr_type) {
		size_t arr_elem_size = ufbxi_array_type_size(arr_type);
		void *arr_data = ufbxi_make_array_size(arr_buf, arr_elem_size, num_values);
		ufbxi_check(arr_data);
		node->prop_type_mask = UFBXI_PROP_ARRAY;
		node->prop_array->data = arr_data;
		node->prop_array->num_elements = num_values;
	} else {
		if (num_values > UFBXI_MAX_NON_ARRAY_VALUES) num_values = UFBXI_MAX_NON_ARRAY_VALUES;
		node->prop_type_mask = (uint16_t)prop_type_mask;
		node->prop_val = ufbxi_push_copy(&uc->tmp, ufbxi_prop_value, num_values, prop_val);
	}

	if (ufbxi_ascii_accept(ua, '{')) {
		size_t num_children = 0;
		while (!ufbxi_ascii_accept(ua, '}')) {
			ufbxi_check(num_children < UFBXI_MAX_NODE_CHILDREN);
			ufbxi_check(ufbxi_ascii_parse_node(ua, depth + 1, parse_node));
			num_children++;
		}

		node->children = ufbxi_push_pop(&uc->tmp, &uc->tmp_node, ufbxi_node, num_children);
		ufbxi_check(node->children);
		node->num_children = (uint32_t)num_children;
	} else {
		node->children = NULL;
		node->num_children = 0;
	}

	return 1;
}

ufbxi_nodiscard static int ufbxi_ascii_parse(ufbxi_context *uc)
{
	ufbxi_ascii ua = { 0 };
	ua.uc = uc;

	ua.src = uc->data;
	ua.src_end = uc->data + uc->data_size;
	ua.token.str_data = ua.token_str[0];
	ua.prev_token.str_data = ua.token_str[1];

	// Parse top-level nodes
	uint32_t num_nodes = 0;
	ufbxi_check(ufbxi_ascii_next_token(&ua, &ua.token));
	while (!ufbxi_ascii_accept(&ua, UFBXI_ASCII_END)) {
		ufbxi_check(num_nodes < UFBXI_MAX_NODE_CHILDREN);
		ufbxi_check(ufbxi_ascii_parse_node(&ua, 0, UFBXI_PARSE_ROOT));
		num_nodes++;
	}

	// Pop top-level nodes from `tmp_node` to a contiguous array
	ufbxi_node *top_nodes = ufbxi_push_pop(&uc->tmp, &uc->tmp_node, ufbxi_node, num_nodes);
	ufbxi_check(top_nodes);

	uc->root.children = top_nodes;
	uc->root.num_children = num_nodes;

	ufbxi_buf_free(&uc->tmp_node);

	return 1;
}


// -- Setup

ufbxi_nodiscard static int ufbxi_load_strings(ufbxi_context *uc)
{
	ufbxi_for(ufbx_string, str, ufbxi_strings, ufbxi_arraycount(ufbxi_strings)) {
		ufbxi_check(ufbxi_push_string_imp(uc, str->data, str->length, false));
	}

	return 1;
}

// -- General parsing

ufbxi_nodiscard static int ufbxi_parse(ufbxi_context *uc)
{
	const char *header = ufbxi_peek_bytes(uc, UFBXI_BINARY_HEADER_SIZE);
	ufbxi_check(header);

	if (!memcmp(header, ufbxi_binary_magic, UFBXI_BINARY_MAGIC_SIZE)) {
		uc->version = ufbxi_read_u32(header + UFBXI_BINARY_MAGIC_SIZE);
		ufbxi_consume_bytes(uc, UFBXI_BINARY_HEADER_SIZE);
		ufbxi_check(ufbxi_binary_parse(uc));
	} else {
		ufbxi_check(ufbxi_ascii_parse(uc));

		// Default to version 7400 if not found in header
		uc->version = 7400;

		// Try to get the version from the header
		ufbxi_node *header_extension = ufbxi_find_child(&uc->root, ufbxi_FBXHeaderExtension);
		if (header_extension) {
			// Doesn't matter if it's not found
			ufbxi_ignore(ufbxi_find_val1(header_extension, ufbxi_FBXVersion, "I", &uc->version));
		}
	}

	return 1;
}

// -- Loading

ufbxi_nodiscard static int ufbxi_load_imp(ufbxi_context *uc)
{
	ufbxi_check(ufbxi_load_strings(uc));
	ufbxi_check(ufbxi_parse(uc));

	return 1;
}

static ufbx_scene *ufbxi_load(ufbxi_context *uc, const ufbx_load_opts *opts, ufbx_error *p_error)
{
	// Test endianness
	{
		uint8_t buf[2];
		uint16_t val = 0xbbaa;
		memcpy(buf, &val, 2);
		uc->big_endian = buf[0] == 0xbb;
	}

	ufbx_load_opts default_opts;
	if (!opts) {
		memset(&default_opts, 0, sizeof(default_opts));
		opts = &default_opts;
	}

	ufbx_inflate_retain inflate_retain;
	inflate_retain.initialized = false;

	// Setup allocators
	uc->ator_tmp.error = &uc->error;
	uc->ator_tmp.ator = opts->temp_allocator;
	uc->ator_tmp.max_size = opts->max_temp_memory ? opts->max_temp_memory : UFBXI_DEFAULT_MAX_MEMORY;
	uc->ator_result.error = &uc->error;
	uc->ator_result.ator = opts->result_allocator;
	uc->ator_result.max_size = opts->max_result_memory ? opts->max_result_memory : UFBXI_DEFAULT_MAX_MEMORY;

	uc->tmp.ator = &uc->ator_tmp;
	uc->tmp_node.ator = &uc->ator_tmp;

	uc->result.ator = &uc->ator_result;
	uc->string_buf.ator = &uc->ator_result;

	uc->inflate_retain = &inflate_retain;

	if (ufbxi_load_imp(uc)) {
		// TODO
	}

	if (p_error) {
		*p_error = uc->error;
	}

	return NULL;
}

// -- File IO

size_t ufbxi_file_read(void *user, void *data, size_t max_size)
{
	FILE *file = (FILE*)user;
	return fread(data, 1, max_size, file);
}

// -- API

ufbx_scene *ufbx_load_memory(const void *data, size_t size, const ufbx_load_opts *opts, ufbx_error *error)
{
	ufbxi_context uc = { 0 };
	uc.data_begin = uc.data = (const char *)data;
	uc.data_size = size;
	return ufbxi_load(&uc, opts, error);
}

ufbx_scene *ufbx_load_file(const char *filename, const ufbx_load_opts *opts, ufbx_error *error)
{
	FILE *file;
	#ifdef _WIN32
		if (fopen_s(&file, filename, "rb")) return NULL;
	#else
		file = fopen(filename, "rb");
	#endif
	if (!file) return NULL;

	ufbxi_context uc = { 0 };
	uc.read_fn = &ufbxi_file_read;
	uc.read_user = file;
	ufbx_scene *scene = ufbxi_load(&uc, opts, error);

	fclose(file);

	return scene;
}

#endif // ndef UFBX_UFBX_C_INLCUDED
