#include "ufbx.h"

#ifndef UFBX_UFBX_C_INLCUDED
#define UFBX_UFBX_C_INLCUDED

// -- Configuration

#define UFBXI_MAX_DEPTH 32
#define UFBXI_MAX_CHILDREN 0x100000
#define UFBXI_MAX_STRINGS 0x100000
#define UFBXI_MAX_STRING_LENGTH 0x100000
#define UFBXI_MAX_ARRAY_SIZE 0x1000000
#define UFBXI_MAX_ALLOCATION_SIZE 0x10000000
#define UFBXI_MAX_ARRAY_SIZE_BYTES 0x10000000
#define UFBXI_MAX_BUFFER_SIZE 0x1000000
#define UFBXI_MAX_READ_BUFFER_SIZE 0x1000000
#define UFBXI_MAX_PROPERTIES 0x1000
#define UFBXI_READ_BUFFER_SIZE 4096

#define UFBXI_ASCII_MAX_TOKEN_LENGTH 1024
#define UFBXI_ASCII_MAX_STACK_SIZE 64

#define UFBXI_MAX_NON_ARRAY_VALUES 7

// -- Includes

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

// -- Platform

#if defined(_MSC_VER)
	#define ufbxi_noinline __declspec(noinline)
	#define ufbxi_forceinline __forceinline
	#if defined(__cplusplus) && _MSC_VER >= 1900
		#define ufbxi_nodiscard [[nodiscard]]
	#else
		#define ufbxi_nodiscard
	#endif
#elif defined(__GNUC__) || defined(__clang__)
	#define ufbxi_noinline __attribute__((noinline))
	#define ufbxi_forceinline inline __attribute__((always_inline))
	#define ufbxi_nodiscard __attribute__((warn_unused_result))
#else
	#define ufbxi_noinline
	#define ufbxi_forceinline
	#define ufbxi_nodiscard
#endif

#if defined(_MSC_VER)
	#pragma warning(push)
	#pragma warning(disable: 4200) // nonstandard extension used: zero-sized array in struct/union
	#pragma warning(disable: 4201) // nonstandard extension used: nameless struct/union
	#pragma warning(disable: 4127) // conditional expression is constant
#endif

#ifndef ufbx_assert
#include <assert.h>
#define ufbx_assert(cond) assert(cond)
#endif

#if !defined(ufbx_static_assert)
	#define ufbx_static_assert(desc, cond) typedef char ufbxi_static_assert_##desc[(cond)?1:-1]
#endif

#define ufbxi_arraycount(arr) (sizeof(arr) / sizeof(*(arr)))

// TODO: Intrinsics if this has bad codegen
#define ufbxi_mulhi32(a, b) ((uint32_t)(((uint64_t)(uint32_t)(a) * (uint64_t)(uint32_t)(b)) >> 32u))

#define ufbxi_ignore(cond) (void)(cond)

// TODO: Unaligned loads for some platforms
#define ufbxi_read_u8(ptr) (*(const uint8_t*)(ptr))
#define ufbxi_read_u16(ptr) (*(const uint16_t*)(ptr))
#define ufbxi_read_u32(ptr) (*(const uint32_t*)(ptr))
#define ufbxi_read_u64(ptr) (*(const uint64_t*)(ptr))
#define ufbxi_read_f32(ptr) (*(const float*)(ptr))
#define ufbxi_read_f64(ptr) (*(const double*)(ptr))
#define ufbxi_read_i8(ptr) (int8_t)(ufbxi_read_u8(ptr))
#define ufbxi_read_i16(ptr) (int16_t)(ufbxi_read_u16(ptr))
#define ufbxi_read_i32(ptr) (int32_t)(ufbxi_read_u32(ptr))
#define ufbxi_read_i64(ptr) (int64_t)(ufbxi_read_u64(ptr))

#define ufbxi_write_u8(ptr, val) (*(uint8_t*)(ptr) = (uint8_t)(val))
#define ufbxi_write_u16(ptr, val) (*(uint16_t*)(ptr) = (uint16_t)(val))
#define ufbxi_write_u32(ptr, val) (*(uint32_t*)(ptr) = (uint32_t)(val))
#define ufbxi_write_u64(ptr, val) (*(uint64_t*)(ptr) = (uint64_t)(val))
#define ufbxi_write_f32(ptr, val) (*(float*)(ptr) = (float)(val))
#define ufbxi_write_f64(ptr, val) (*(double*)(ptr) = (double)(val))
#define ufbxi_write_i8(ptr, val) ufbxi_write_u8(ptr, val)
#define ufbxi_write_i16(ptr, val) ufbxi_write_u16(ptr, val)
#define ufbxi_write_i32(ptr, val) ufbxi_write_u32(ptr, val)
#define ufbxi_write_i64(ptr, val) ufbxi_write_u64(ptr, val)

#define ufbxi_for(m_type, m_name, m_begin, m_num) for (m_type *m_name = m_begin, *m_name##_end = m_name + (m_num); m_name != m_name##_end; m_name++)

#ifdef __cplusplus
extern "C" {
#endif

// -- Platform checks

ufbx_static_assert(sizeof_bool, sizeof(bool) == 1);
ufbx_static_assert(sizeof_i8, sizeof(int8_t) == 1);
ufbx_static_assert(sizeof_i16, sizeof(int16_t) == 2);
ufbx_static_assert(sizeof_i32, sizeof(int32_t) == 4);
ufbx_static_assert(sizeof_i64, sizeof(int64_t) == 8);
ufbx_static_assert(sizeof_u8, sizeof(uint8_t) == 1);
ufbx_static_assert(sizeof_u16, sizeof(uint16_t) == 2);
ufbx_static_assert(sizeof_u32, sizeof(uint32_t) == 4);
ufbx_static_assert(sizeof_u64, sizeof(uint64_t) == 8);
ufbx_static_assert(sizeof_f32, sizeof(float) == 4);
ufbx_static_assert(sizeof_f64, sizeof(double) == 8);

// -- General utility

static ufbxi_forceinline uint32_t ufbxi_min32(uint32_t a, uint32_t b) { return a < b ? a : b; }
static ufbxi_forceinline uint32_t ufbxi_max32(uint32_t a, uint32_t b) { return a < b ? b : a; }
static ufbxi_forceinline size_t ufbxi_min_sz(size_t a, size_t b) { return a < b ? a : b; }
static ufbxi_forceinline size_t ufbxi_max_sz(size_t a, size_t b) { return a < b ? b : a; }

// -- DEFLATE implementation
// Pretty much based on Sean Barrett's `stb_image` deflate

#if !defined(ufbx_inflate)

// Lookup data: [0:13] extra mask [13:17] extra bits [17:32] base value
// Generated by `misc/deflate_lut.py`
static const uint32_t ufbxi_deflate_length_lut[] = {
	0x00060000, 0x00080000, 0x000a0000, 0x000c0000, 0x000e0000, 0x00100000, 0x00120000, 0x00140000, 
	0x00162001, 0x001a2001, 0x001e2001, 0x00222001, 0x00264003, 0x002e4003, 0x00364003, 0x003e4003, 
	0x00466007, 0x00566007, 0x00666007, 0x00766007, 0x0086800f, 0x00a6800f, 0x00c6800f, 0x00e6800f, 
	0x0106a01f, 0x0146a01f, 0x0186a01f, 0x01c6a01f, 0x02040000, 0x00000000, 0x00000000, 
};
static const uint32_t ufbxi_deflate_dist_lut[] = {
	0x00020000, 0x00040000, 0x00060000, 0x00080000, 0x000a2001, 0x000e2001, 0x00124003, 0x001a4003, 
	0x00226007, 0x00326007, 0x0042800f, 0x0062800f, 0x0082a01f, 0x00c2a01f, 0x0102c03f, 0x0182c03f, 
	0x0202e07f, 0x0302e07f, 0x040300ff, 0x060300ff, 0x080321ff, 0x0c0321ff, 0x100343ff, 0x180343ff, 
	0x200367ff, 0x300367ff, 0x40038fff, 0x60038fff, 0x8003bfff, 0xc003bfff, 
};

static const uint8_t ufbxi_deflate_code_length_permutation[] = {
	16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15,
};

#define UFBXI_HUFF_MAX_BITS 16
#define UFBXI_HUFF_MAX_VALUE 288
#define UFBXI_HUFF_FAST_BITS 9
#define UFBXI_HUFF_FAST_SIZE (1 << UFBXI_HUFF_FAST_BITS)
#define UFBXI_HUFF_FAST_MASK (UFBXI_HUFF_FAST_SIZE - 1)

typedef struct {
	uint64_t fast_begin_bits, fast_size_bits;
	const uint64_t *fast_data;
	const char *data;
	size_t size;
	uint64_t prefix[2], suffix[2];
} ufbxi_bit_stream;

typedef struct {
	uint32_t num_symbols;

	uint16_t sorted_to_sym[UFBXI_HUFF_MAX_VALUE]; // < Sorted symbol index to symbol
	uint16_t past_max_code[UFBXI_HUFF_MAX_BITS];  // < One past maximum code value per bit length
	int16_t code_to_sorted[UFBXI_HUFF_MAX_BITS];  // < Code to sorted symbol index per bit length
	uint16_t fast_sym[UFBXI_HUFF_FAST_SIZE];      // < Fast symbol lookup [0:12] symbol [12:16] bits
} ufbxi_huff_tree;

typedef struct {
	ufbxi_bit_stream stream;
	ufbxi_huff_tree huff_lit_length;
	ufbxi_huff_tree huff_dist;

	char *out_begin;
	char *out_ptr;
	char *out_end;
} ufbxi_deflate_context;

static ufbxi_forceinline uint32_t ufbxi_bit_reverse(uint32_t mask, uint32_t num_bits)
{
	ufbx_assert(num_bits <= 16);
	uint32_t x = mask;
    x = (((x & 0xaaaa) >> 1) | ((x & 0x5555) << 1));
    x = (((x & 0xcccc) >> 2) | ((x & 0x3333) << 2));
    x = (((x & 0xf0f0) >> 4) | ((x & 0x0f0f) << 4));
	x = (((x & 0xff00) >> 8) | ((x & 0x00ff) << 8));
	return x >> (16 - num_bits);
}

static ufbxi_noinline void
ufbxi_bit_init(ufbxi_bit_stream *s, const void *data, size_t size)
{
	uintptr_t fast_begin_addr = ((uintptr_t)data + ((8 - (uintptr_t)data) & 7u));
	uintptr_t fast_end_addr = ((uintptr_t)data + size) & ~(uintptr_t)7u;
	const char *bytes = (const char*)data;

	s->data = bytes;
	s->size = size;

	if ((ptrdiff_t)(fast_end_addr - fast_begin_addr) >= 16) {
		uint64_t fast_begin_offset = fast_begin_addr - (uintptr_t)data;
		s->fast_begin_bits = fast_begin_offset * 8;
		s->fast_size_bits = (fast_end_addr - fast_begin_addr) * 8 - 64;
		s->fast_data = (const uint64_t*)((const char*)data + fast_begin_offset);
	} else {
		s->fast_begin_bits = 0;
		s->fast_size_bits = 0;
		s->fast_data = NULL;
	}

	s->prefix[0] = s->prefix[1] = 0;
	s->suffix[0] = s->suffix[1] = 0;
	for (size_t i = 0; i < 8; i++) {
		if (i < size) {
			s->prefix[0] |= (uint64_t)(uint8_t)bytes[i] << (i * 8);
			s->suffix[1] |= (uint64_t)(uint8_t)bytes[size - i - 1] << (56 - i * 8);
		}
		if (i + 8 < size) {
			s->prefix[1] |= (uint64_t)(uint8_t)bytes[i + 8] << (i * 8);
			s->suffix[0] |= (uint64_t)(uint8_t)bytes[size - i - 9] << (56 - i * 8);
		}
	}
}

static ufbxi_noinline uint64_t
ufbxi_bit_read_slow(ufbxi_bit_stream *s, uint64_t offset_bits)
{
	if (offset_bits < 64) {
		return s->prefix[0] >> offset_bits | (s->prefix[1] << 1) << (63 - offset_bits);
	} else {
		uint64_t suffix_shift = (uint64_t)offset_bits - ((uint64_t)s->size * 8 - 128);
		if (suffix_shift < 64) {
			return s->suffix[0] >> suffix_shift | (s->suffix[1] << 1) << (63 - suffix_shift);
		} else if (suffix_shift < 128) {
			return s->suffix[1] >> (suffix_shift - 64);
		} else {
			return 0;
		}
	}
}

static ufbxi_forceinline uint64_t
ufbxi_bit_read(ufbxi_bit_stream *s, uint64_t offset_bits)
{
	uint64_t fast_pos_bits = offset_bits - s->fast_begin_bits;
	unsigned shift = fast_pos_bits & 63;
	if (fast_pos_bits < s->fast_size_bits) {
		uint64_t word = fast_pos_bits >> 6;
		uint64_t a = s->fast_data[word];
		uint64_t b = s->fast_data[word + 1];
		return a >> shift | (b << 1) << (63 - shift);
	} else {
		return ufbxi_bit_read_slow(s, offset_bits);
	}
}

// 0: Success
// -1: Overfull
// -2: Underfull
static ufbxi_noinline ptrdiff_t
ufbxi_huff_build(ufbxi_huff_tree *tree, uint8_t *sym_bits, uint32_t sym_count)
{
	ufbx_assert(sym_count <= UFBXI_HUFF_MAX_VALUE);
	tree->num_symbols = sym_count;

	uint32_t bits_counts[UFBXI_HUFF_MAX_BITS];
	memset(bits_counts, 0, sizeof(bits_counts));
	for (uint32_t i = 0; i < sym_count; i++) {
		uint32_t bits = sym_bits[i];
		ufbx_assert(bits <= UFBXI_HUFF_MAX_BITS);
		bits_counts[bits]++;
	}
	uint32_t nonzero_sym_count = sym_count - bits_counts[0];

	uint32_t total_syms[UFBXI_HUFF_MAX_BITS];
	uint32_t first_code[UFBXI_HUFF_MAX_BITS];

	tree->code_to_sorted[0] = INT16_MAX;
	tree->past_max_code[0] = 0;
	total_syms[0] = 0;

	{
		int num_codes_left = 1;
		uint32_t code = 0;
		uint32_t prev_count = 0;
		for (uint32_t bits = 1; bits < UFBXI_HUFF_MAX_BITS; bits++) {
			uint32_t count = bits_counts[bits];
			code = (code + prev_count) << 1;
			first_code[bits] = code;
			tree->past_max_code[bits] = (uint16_t)(code + count);

			uint32_t prev_syms = total_syms[bits - 1];
			total_syms[bits] = prev_syms + count;

			// Each bit level doubles the amount of codes and potentially removes some
			num_codes_left = (num_codes_left << 1) - count;
			if (num_codes_left < 0) {
				return -1;
			}

			if (count > 0) {
				tree->code_to_sorted[bits] = (int16_t)((int)prev_syms - (int)code);
			} else {
				tree->code_to_sorted[bits] = INT16_MAX;
			}
			prev_count = count;
		}

		// All codes should be used if there's more than one symbol
		if (nonzero_sym_count > 1 && num_codes_left != 0) {
			return -2;
		}
	}

	memset(tree->fast_sym, 0, sizeof(tree->fast_sym));

	uint32_t bits_index[UFBXI_HUFF_MAX_BITS];
	memset(bits_index, 0, sizeof(bits_index));
	memset(tree->sorted_to_sym, 0xff, sizeof(tree->sorted_to_sym));
	for (uint32_t i = 0; i < sym_count; i++) {
		uint32_t bits = sym_bits[i];
		if (bits == 0) continue;

		uint32_t index = bits_index[bits]++;
		uint32_t sorted = total_syms[bits - 1] + index;
		tree->sorted_to_sym[sorted] = (uint16_t)i;

		uint32_t code = first_code[bits] + index;
		uint32_t rev_code = ufbxi_bit_reverse(code, bits);

		if (bits <= UFBXI_HUFF_FAST_BITS) {
			uint16_t fast_sym = (uint16_t)(i | bits << 12);
			uint32_t hi_max = 1 << (UFBXI_HUFF_FAST_BITS - bits);
			for (uint32_t hi = 0; hi < hi_max; hi++) {
				ufbx_assert(tree->fast_sym[rev_code | hi << bits] == 0);
				tree->fast_sym[rev_code | hi << bits] = fast_sym;
			}
		}
	}

	return 0;
}

static ufbxi_forceinline uint32_t
ufbxi_huff_decode_bits(const ufbxi_huff_tree *tree, uint64_t *p_bits, uint64_t *p_pos)
{
	uint32_t fast_sym_bits = tree->fast_sym[*p_bits & UFBXI_HUFF_FAST_MASK];
	if (fast_sym_bits != 0) {
		uint32_t bits = fast_sym_bits >> 12;
		*p_pos += bits;
		*p_bits >>= bits;
		return fast_sym_bits & 0x3ff;
	}

	uint32_t code = ufbxi_bit_reverse((uint32_t)*p_bits, UFBXI_HUFF_FAST_BITS + 1);
	*p_bits >>= UFBXI_HUFF_FAST_BITS + 1;
	*p_pos += UFBXI_HUFF_FAST_BITS + 1;
	for (uint32_t bits = UFBXI_HUFF_FAST_BITS + 1; bits < UFBXI_HUFF_MAX_BITS; bits++) {
		if (code < tree->past_max_code[bits]) {
			uint32_t sorted = code + tree->code_to_sorted[bits];
			if (sorted >= tree->num_symbols) return ~0u;
			return tree->sorted_to_sym[sorted];
		}
		code = code << 1 | (*p_bits & 1);
		*p_bits >>= 1;
		*p_pos += 1;
	}

	return ~0u;
}

static void
ufbxi_init_static_huff(ufbxi_deflate_context *dc)
{
	ptrdiff_t err = 0;

	uint8_t lit_length_bits[288];
	memset(lit_length_bits +   0, 8, 144 -   0);
	memset(lit_length_bits + 144, 9, 256 - 144);
	memset(lit_length_bits + 256, 7, 280 - 256);
	memset(lit_length_bits + 280, 8, 288 - 280);
	err |= ufbxi_huff_build(&dc->huff_lit_length, lit_length_bits, sizeof(lit_length_bits));

	uint8_t dist_bits[32];
	memset(dist_bits + 0, 5, 32 - 0);
	err |= ufbxi_huff_build(&dc->huff_dist, dist_bits, sizeof(dist_bits));

	ufbx_assert(err == 0);
}

// 0: Success
// -1: Huffman Overfull
// -2: Huffman Underfull
// -3: Code 16 repeat overflow
// -4: Code 17 repeat overflow
// -5: Code 18 repeat overflow
// -6: Bad length code
static ufbxi_noinline ptrdiff_t
ufbxi_init_dynamic_huff_tree(ufbxi_deflate_context *dc, const ufbxi_huff_tree *huff_code_length,
	ufbxi_huff_tree *tree, uint32_t num_symbols, uint64_t *p_pos)
{
	uint8_t code_lengths[UFBXI_HUFF_MAX_VALUE];
	ufbx_assert(num_symbols <= UFBXI_HUFF_MAX_VALUE);
	uint64_t pos = *p_pos;

	uint32_t symbol_index = 0;
	uint8_t prev = 0;
	while (symbol_index < num_symbols) {
		uint64_t bits = ufbxi_bit_read(&dc->stream, pos);

		uint32_t inst = ufbxi_huff_decode_bits(huff_code_length, &bits, &pos);
		if (inst <= 15) {
			prev = (uint8_t)inst;
			code_lengths[symbol_index++] = (uint8_t)inst;
		} else if (inst == 16) {
			uint32_t num = 3 + ((uint32_t)bits & 0x3);
			pos += 2;
			if (symbol_index + num > num_symbols) return -3;
			memset(code_lengths + symbol_index, prev, num);
			symbol_index += num;
		} else if (inst == 17) {
			uint32_t num = 3 + ((uint32_t)bits & 0x7);
			pos += 3;
			if (symbol_index + num > num_symbols) return -4;
			memset(code_lengths + symbol_index, 0, num);
			symbol_index += num;
			prev = 0;
		} else if (inst == 18) {
			uint32_t num = 11 + ((uint32_t)bits & 0x7f);
			pos += 7;
			if (symbol_index + num > num_symbols) return -5;
			memset(code_lengths + symbol_index, 0, num);
			symbol_index += num;
			prev = 0;
		} else {
			return -6;
		}
	}

	ptrdiff_t err = ufbxi_huff_build(tree, code_lengths, num_symbols);
	if (err != 0) return err;

	*p_pos = pos;
	return 0;
}

static ptrdiff_t
ufbxi_init_dynamic_huff(ufbxi_deflate_context *dc, uint64_t *p_pos)
{
	uint64_t pos = *p_pos;
	uint64_t bits = ufbxi_bit_read(&dc->stream, pos);
	pos += 14;

	uint32_t num_lit_lengths = 257 + (bits & 0x1f);
	uint32_t num_dists = 1 + (bits >> 5 & 0x1f);
	uint32_t num_code_lengths = 4 + (bits >> 10 & 0xf);

	uint8_t code_lengths[19];
	memset(code_lengths, 0, sizeof(code_lengths));

	bits = ufbxi_bit_read(&dc->stream, pos);
	for (uint32_t i = 0; i < num_code_lengths; i++) {
		code_lengths[ufbxi_deflate_code_length_permutation[i]] = (uint32_t)bits & 0x7;
		bits >>= 3;
	}
	pos += num_code_lengths * 3;

	ufbxi_huff_tree huff_code_length;
	ptrdiff_t err;
	err = ufbxi_huff_build(&huff_code_length, code_lengths, ufbxi_arraycount(code_lengths));
	if (err) return -14 + 1 + err;
	err = ufbxi_init_dynamic_huff_tree(dc, &huff_code_length, &dc->huff_lit_length, num_lit_lengths, &pos);
	if (err) return -16 + 1 + err;
	err = ufbxi_init_dynamic_huff_tree(dc, &huff_code_length, &dc->huff_dist, num_dists, &pos);
	if (err) return -22 + 1 + err;

	*p_pos = pos;
	return 0;
}

static uint32_t
ufbxi_adler32(const void *data, size_t size)
{
	size_t a = 1, b = 0;
	const size_t num_before_wrap = sizeof(size_t) == 8 ? 380368439u : 5552u;

	const char *p = (const char*)data;

	size_t size_left = size;
	while (size_left > 0) {
		size_t num = size_left <= num_before_wrap ? size_left : num_before_wrap;
		size_left -= num;
		const char *end = p + num;

		while (end - p >= 8) {
			a += (size_t)(uint8_t)p[0]; b += a;
			a += (size_t)(uint8_t)p[1]; b += a;
			a += (size_t)(uint8_t)p[2]; b += a;
			a += (size_t)(uint8_t)p[3]; b += a;
			a += (size_t)(uint8_t)p[4]; b += a;
			a += (size_t)(uint8_t)p[5]; b += a;
			a += (size_t)(uint8_t)p[6]; b += a;
			a += (size_t)(uint8_t)p[7]; b += a;
			p += 8;
		}

		while (p != end) {
			a += (size_t)(uint8_t)p[0]; b += a;
			p++;
		}

		a %= 65521u;
		b %= 65521u;
	}

	return (uint32_t)((b << 16) | (a & 0xffff));
}

static int
ufbxi_inflate_block(ufbxi_deflate_context *dc, uint64_t *p_pos)
{
	uint64_t pos = *p_pos;
	char *out_ptr = dc->out_ptr;
	char *const out_begin = dc->out_begin;
	char *const out_end = dc->out_end;

	uint64_t bits;
	uint64_t pos_end = pos;
	for (;;) {
		if (pos_end - pos < 15) {
			bits = ufbxi_bit_read(&dc->stream, pos);
			pos_end = pos + 64;
		}

		// Decode literal/length value from input stream
		uint32_t lit_length = ufbxi_huff_decode_bits(&dc->huff_lit_length, &bits, &pos);

		// If value < 256: copy value (literal byte) to output stream
		if (lit_length < 256) {
			if (out_ptr == out_end) {
				return -10;
			}
			*out_ptr++ = (char)lit_length;
		} else if (lit_length - 257 <= 285 - 257) {
			// If value = 257..285: Decode extra length and distance
			uint32_t length, distance;

			if (pos_end - pos < 33) {
				bits = ufbxi_bit_read(&dc->stream, pos);
				pos_end = pos + 64;
			}

			// Length
			{
				uint32_t lut = ufbxi_deflate_length_lut[lit_length - 257];
				uint32_t base = lut >> 17;
				uint32_t offset = ((uint32_t)bits & lut & 0x1fff); // 33-5 = 28 bits
				uint32_t offset_bits = (lut >> 13) & 0xf;
				bits >>= offset_bits;
				pos += offset_bits;
				length = base + offset;
			}

			// Distance
			{
				uint32_t dist = ufbxi_huff_decode_bits(&dc->huff_dist, &bits, &pos); // 28-15 = 13 bits
				if (dist >= 30) {
					return -11;
				}
				uint32_t lut = ufbxi_deflate_dist_lut[dist];
				uint32_t base = lut >> 17;
				uint32_t offset = ((uint32_t)bits & lut & 0x1fff); // 13-13 = 0 bits
				uint32_t offset_bits = (lut >> 13) & 0xf;
				bits >>= offset_bits;
				pos += offset_bits;
				distance = base + offset;
			}

			if ((ptrdiff_t)distance > out_ptr - out_begin || (ptrdiff_t)length > out_end - out_ptr) {
				return -12;
			}

			ufbx_assert(length > 0);
			const char *src = out_ptr - distance;
			char *dst = out_ptr;
			out_ptr += length;
			{
				// TODO: Do something better than per-byte copy
				char *end = dst + length;

				while (end - dst >= 4) {
					dst[0] = src[0];
					dst[1] = src[1];
					dst[2] = src[2];
					dst[3] = src[3];
					dst += 4;
					src += 4;
				}

				while (dst != end) {
					*dst++ = *src++;
				}
			}
		} else if (lit_length == 256) {
			break;
		} else {
			return -13;
		}
	}

	dc->out_ptr = out_ptr;
	*p_pos = pos;
	return 0;
}

// TODO: Error codes should have a quick test if the destination buffer overflowed
// Returns actual number of decompressed bytes or negative error:
// -1: Bad compression method (ZLIB header)
// -2: Requires dictionary (ZLIB header)
// -3: Bad FCHECK (ZLIB header)
// -4: Bad NLEN (Uncompressed LEN != ~NLEN)
// -5: Uncompressed source overflow
// -6: Uncompressed destination overflow
// -7: Bad block type
// -8: Truncated checksum
// -9: Checksum mismatch
// -10: Literal destination overflow
// -11: Bad distance code or distance of (30..31)
// -12: Match out of bounds
// -13: Bad lit/length code
// -14: Codelen Huffman Overfull
// -15: Codelen Huffman Underfull
// -16 - -21: Litlen Huffman: Overfull / Underfull / Repeat 16/17/18 overflow / Bad length code
// -22 - -27: Distance Huffman: Overfull / Underfull / Repeat 16/17/18 overflow / Bad length code
static ptrdiff_t
ufbxi_inflate(void *dst, size_t dst_size, const void *src, size_t src_size)
{
	ptrdiff_t err;
	ufbxi_deflate_context dc;
	ufbxi_bit_init(&dc.stream, src, src_size);
	dc.out_begin = (char*)dst;
	dc.out_ptr = (char*)dst;
	dc.out_end = (char*)dst + dst_size;

	uint64_t pos = 0;
	uint64_t bits = ufbxi_bit_read(&dc.stream, pos);

	// Zlib header
	{
		size_t cmf = (size_t)(bits & 0xff);
		size_t flg = (size_t)(bits >> 8) & 0xff;
		bits >>= 16;
		pos += 16;

		if ((cmf & 0xf) != 0x8) return -1;
		if ((flg & 0x20) != 0) return -2;
		if ((cmf << 8 | flg) % 31u != 0) return -3;
	}

	for (;;) { 
		bits = ufbxi_bit_read(&dc.stream, pos);

		// Block header: [0:1] BFINAL [1:3] BTYPE
		size_t header = (size_t)bits & 0x7;
		bits >>= 3;
		pos += 3;

		size_t type = header >> 1;
		if (type == 0) {
			// 0b00 - no compression
			// Round up to the next byte
			size_t byte_pos = (size_t)((pos + 7) >> 3);
			bits >>= ((uint64_t)byte_pos << 3) - pos;

			// Literal header: [0:2] LEN [2:4] NLEN = ~LEN
			const uint8_t *src_pos = (const uint8_t*)src + byte_pos;
			size_t len = (size_t)(bits & 0xffff);
			size_t nlen = (size_t)((bits >> 16) & 0xffff);
			if ((len ^ nlen) != 0xffff) return -4;
			if (byte_pos + len + 4 > src_size) return -5;
			if (dc.out_end - dc.out_ptr < (ptrdiff_t)len) return -6;

			// Copy literal data (skipping header) and advance
			memcpy(dc.out_ptr, src_pos + 4, len);
			dc.out_ptr += len;
			pos = (byte_pos + 4 + len) << 3;
		} else if (type <= 2) {
			if (type == 1) {
				// TODO: Cache the trees?
				ufbxi_init_static_huff(&dc);
			} else { 
				err = ufbxi_init_dynamic_huff(&dc, &pos);
				if (err) return err;
			}

			err = ufbxi_inflate_block(&dc, &pos);
			if (err) return err;
		} else {
			// 0b11 - reserved (error)
			return -7;
		}

		// BFINAL: End of stream
		if (header & 1) break;
	}

	// Check Adler-32
	{
		// Round up to the next byte
		size_t byte_pos = (size_t)((pos + 7) >> 3);
		if (src_size < byte_pos + 4) {
			return -8;
		}
		const uint8_t *p = (const uint8_t*)src + byte_pos;
		uint32_t ref = p[0] << 24 | p[1] << 16 | p[2] << 8 | p[3];
		uint32_t checksum = ufbxi_adler32(dc.out_begin, dc.out_ptr - dc.out_begin);
		if (ref != checksum) {
			return -9;
		}
	}

	return dc.out_ptr - dc.out_begin;
}

#define ufbx_inflate ufbxi_inflate

#endif // !defined(ufbx_inflate)

// -- General purpose chunked buffer

typedef struct ufbxi_buf_chunk ufbxi_buf_chunk;

struct ufbxi_buf_chunk {
	ufbxi_buf_chunk *root;
	ufbxi_buf_chunk *prev;
	ufbxi_buf_chunk *next;
	void *align_0;

	uint32_t pushed_pos;
	uint32_t size;
	uint32_t next_size;
	uint32_t align_1;

	char data[];
};

ufbx_static_assert(buf_chunk_align, offsetof(ufbxi_buf_chunk, data) % 8 == 0);

typedef struct {
	ufbxi_buf_chunk *chunk;
	uint32_t pos, size;
	size_t num_items;
} ufbxi_buf;

static void *ufbxi_push_size_uninit_new_block(ufbxi_buf *b, size_t size)
{
	ufbxi_buf_chunk *chunk = b->chunk;
	if (chunk) {
		// Store the final position for the retired chunk
		chunk->pushed_pos = b->pos;

		// Try to re-use old chunks first
		ufbxi_buf_chunk *next;
		while ((next = chunk->next) != NULL) {
			chunk = next;
			if (size <= chunk->size) {
				b->chunk = chunk;
				b->pos = (uint32_t)size;
				b->size = chunk->size;
				return chunk->data;
			} else {
				// Didn't fit, skip the whole chunk
				chunk->pushed_pos = 0;
			}
		}
	}

	// Allocate a new chunk, grow `next_size` geometrically but don't double
	// the current or previous user sizes if they are larger.
	uint32_t next_size = chunk ? chunk->next_size * 2 : 4096;
	uint32_t chunk_size = next_size - sizeof(ufbxi_buf_chunk);
	if (chunk_size < size) chunk_size = (uint32_t)size;
	ufbxi_buf_chunk *new_chunk = (ufbxi_buf_chunk*)malloc(sizeof(ufbxi_buf_chunk) + chunk_size);
	if (!new_chunk) return NULL;

	new_chunk->prev = chunk;
	new_chunk->next = NULL;
	new_chunk->size = chunk_size;
	new_chunk->next_size = next_size;

	// Link the chunk to the list and set it as the active one
	if (chunk) {
		chunk->next = new_chunk;
		new_chunk->root = chunk->root;
	} else {
		new_chunk->root = new_chunk;
	}

	b->chunk = new_chunk;
	b->pos = (uint32_t)size;
	b->size = chunk_size;

	return new_chunk->data;
}

static ufbxi_forceinline uint32_t ufbxi_align_to_mask(uint32_t value, uint32_t align_mask)
{
	return value + ((uint32_t)-(int32_t)value & align_mask);
}

static ufbxi_forceinline uint32_t ufbxi_size_align_mask(size_t size)
{
	// Align to the all bits below the lowest set one in `size`
	// up to a maximum of 0x7 (align to 8 bytes).
	return ((size ^ (size - 1)) >> 1) & 0x7;
}

static ufbxi_forceinline void *ufbxi_push_size_uninit(ufbxi_buf *b, size_t size, size_t n)
{
	// Guard against overflows and huge allocations
	if (n >= UFBXI_MAX_ALLOCATION_SIZE / size) return NULL;

	b->num_items += n;

	uint32_t align_mask = ufbxi_size_align_mask(size);
	uint32_t pos = ufbxi_align_to_mask(b->pos, align_mask);
	uint32_t push_size = (uint32_t)(size * n);
	uint32_t end = pos + push_size;
	if (end <= b->size) {
		b->pos = end;
		return b->chunk->data + pos;
	} else {
		return ufbxi_push_size_uninit_new_block(b, push_size);
	}
}

static ufbxi_forceinline void *ufbxi_push_size_zero(ufbxi_buf *b, size_t size, size_t n)
{
	void *ptr = ufbxi_push_size_uninit(b, size, n);
	if (ptr) memset(ptr, 0, size * n);
	return ptr;
}

ufbxi_nodiscard static ufbxi_forceinline void *ufbxi_push_size_copy(ufbxi_buf *b, size_t size, size_t n, const void *data)
{
	void *ptr = ufbxi_push_size_uninit(b, size, n);
	if (ptr) memcpy(ptr, data, size * n);
	return ptr;
}

static void ufbxi_pop_size(ufbxi_buf *b, size_t size, size_t n, void *dst)
{
	b->num_items -= n;

	char *ptr = (char*)dst;
	// Check if `size` and `n` cannot overflow. If `size` and `n` use at most
	// 2 and 6 bits per `size_t` byte the product can't overflow.
	if (size < ((size_t)1 << sizeof(size_t)*2) && n < ((size_t)1 << sizeof(size_t)*6)) {
		size_t bytes_left = size * n;

		if (ptr) {
			ptr += bytes_left;
			uint32_t pos = b->pos;
			for (;;) {
				ufbxi_buf_chunk *chunk = b->chunk;
				if (bytes_left <= pos) {
					// Rest of the data is in this single chunk
					pos -= (uint32_t)bytes_left;
					b->pos = pos;
					ptr -= bytes_left;
					memcpy(ptr, chunk->data + pos, bytes_left);
					return;
				} else {
					// Pop the whole chunk
					ptr -= pos;
					bytes_left -= pos;
					memcpy(ptr, chunk->data, pos);
					chunk = chunk->prev;
					b->chunk = chunk;
					b->size = chunk->size;
					pos = chunk->pushed_pos;
				}
			}
		} else {
			uint32_t pos = b->pos;
			for (;;) {
				ufbxi_buf_chunk *chunk = b->chunk;
				if (bytes_left <= pos) {
					// Rest of the data is in this single chunk
					pos -= (uint32_t)bytes_left;
					b->pos = pos;
					return;
				} else {
					// Pop the whole chunk
					bytes_left -= pos;
					chunk = chunk->prev;
					b->chunk = chunk;
					b->size = chunk->size;
					pos = chunk->pushed_pos;
				}
			}
		}

	} else {
		// Slow path, equivalent to the branch above
		if (ptr) {
			for (size_t i = 0; i < n; i++) ptr += size;
		}
		while (n > 0) {
			ufbx_assert(b->chunk);
			while (b->pos == 0) {
				ufbx_assert(b->chunk->prev);
				b->chunk = b->chunk->prev;
				b->pos = b->chunk->pushed_pos;
				b->size = b->chunk->size;
			}
			ufbx_assert(b->pos >= size);
			b->pos -= (uint32_t)size;
			if (ptr) {
				ptr -= size;
				memcpy(ptr, b->chunk->data + b->pos, size);
			}
		}
	}
}

static void *ufbxi_push_pop_size(ufbxi_buf *dst, ufbxi_buf *src, size_t size, size_t n)
{
	void *data = ufbxi_push_size_uninit(dst, size, n);
	if (!data) return NULL;
	ufbxi_pop_size(src, size, n, data);
	return data;
}

static void ufbxi_free_buf(ufbxi_buf *buf)
{
	ufbxi_buf_chunk *chunk = buf->chunk;
	while (chunk) {
		ufbxi_buf_chunk *next = chunk->prev;
		free(chunk);
		chunk = next;
	}
	memset(buf, 0, sizeof(ufbxi_buf));
}

static void ufbxi_clear_buf(ufbxi_buf *buf)
{
	ufbxi_buf_chunk *chunk = buf->chunk;
	if (chunk) {
		buf->chunk = chunk->root;
		buf->pos = 0;
		buf->size = chunk->size;
		buf->num_items = 0;
	}
}

#define ufbxi_push_uninit(b, type, n) (type*)ufbxi_push_size_uninit((b), sizeof(type), (n))
#define ufbxi_push_zero(b, type, n) (type*)ufbxi_push_size_zero((b), sizeof(type), (n))
#define ufbxi_push_copy(b, type, n, data) (type*)ufbxi_push_size_copy((b), sizeof(type), (n), (data))
#define ufbxi_pop(b, type, n, dst) ufbxi_pop_size((b), sizeof(type), (n), (dst))
#define ufbxi_push_pop(dst, src, type, n) (type*)ufbxi_push_pop_size((dst), (src), sizeof(type), (n))

// -- (Uint)Pointer map

typedef struct {
	uintptr_t key;
	uintptr_t val;
} ufbxi_ptr_map_entry;

typedef struct {
	ufbxi_ptr_map_entry *entries;
	uint32_t map_size;
} ufbxi_ptr_map;

static uint32_t ufbxi_ceil_pow2(uint32_t v)
{
	// https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
	v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++;
	return v > 0 ? v : 1;
}

static uint32_t ufbxi_uintptr_hash(uintptr_t up)
{
	// TODO: 64-bit hash?
	uint32_t x = (uint32_t)up;
    x ^= x >> 16;
    x *= UINT32_C(0x7feb352d);
    x ^= x >> 15;
    x *= UINT32_C(0x846ca68b);
    x ^= x >> 16;
    return x;
}

ufbxi_nodiscard static int ufbxi_ptr_map_init(ufbxi_ptr_map *map, uint32_t size)
{
	map->map_size = ufbxi_ceil_pow2(size * 2);
	map->entries = (ufbxi_ptr_map_entry*)calloc(map->map_size, sizeof(ufbxi_ptr_map_entry));
	return map->entries != NULL;
}

static uintptr_t ufbxi_ptr_map_insert_up(ufbxi_ptr_map *map, uintptr_t key, uintptr_t val)
{
	ufbx_assert(map->map_size > 0);
	uint32_t hash = ufbxi_uintptr_hash(key);
	ufbxi_ptr_map_entry *entries = map->entries;
	uint32_t mask = map->map_size - 1;
	for (uint32_t ix = hash; ; ix++) {
		ufbxi_ptr_map_entry *entry = &entries[ix & mask];
		if (entry->key == key) {
			return entry->val;
		} else if (entry->key == 0) {
			entry->key = key;
			entry->val = val;
			return val;
		}
	}
}

static uintptr_t ufbxi_ptr_map_find_up(ufbxi_ptr_map *map, uintptr_t key)
{
	ufbx_assert(map->map_size > 0);
	uint32_t hash = ufbxi_uintptr_hash(key);
	ufbxi_ptr_map_entry *entries = map->entries;
	uint32_t mask = map->map_size - 1;
	for (uint32_t ix = hash; ; ix++) {
		ufbxi_ptr_map_entry *entry = &entries[ix & mask];
		if (entry->key == key) {
			return entry->val;
		} else if (entry->key == 0) {
			return 0;
		}
	}
}

static void ufbxi_ptr_map_free(ufbxi_ptr_map *map)
{
	free(map->entries);
	map->entries = NULL;
	map->map_size = 0;
}

#define ufbxi_ptr_map_insert(map, type, key, val) (type)ufbxi_ptr_map_insert_up((map), (uintptr_t)(key), (uintptr_t)(val))
#define ufbxi_ptr_map_find(map, type, key) (type)ufbxi_ptr_map_find_up((map), (uintptr_t)(key))

// -- File data representation

#define UFBXI_STRINGS \
	UFBXI_STR(Definitions) \
	UFBXI_STR(Objects) \
	UFBXI_STR(ObjectType) \
	UFBXI_STR(PropertyTemplate) \
	UFBXI_STR(Properties70) \
	UFBXI_STR(Properties60) \
	UFBXI_STR(Model) \
	UFBXI_STR(Geometry) \
	UFBXI_STR(Vertices) \
	UFBXI_STR(PolygonVertexIndex) \
	UFBXI_STR(Edges) \
	UFBXI_STR(MappingInformationType) \
	UFBXI_STR(Name) \
	UFBXI_STR(ByVertex) \
	UFBXI_STR(ByVertice) \
	UFBXI_STR(ByPolygonVertex) \
	UFBXI_STR(ByEdge) \
	UFBXI_STR(ByPolygon) \
	UFBXI_STR(AllSame) \
	UFBXI_STR(FBXHeaderExtension) \
	UFBXI_STR(FBXVersion) \
	UFBXI_STR(LayerElementUV) \
	UFBXI_STR(LayerElementNormal) \
	UFBXI_STR(UV) \
	UFBXI_STR(UVIndex) \
	UFBXI_STR(Normals) \
	UFBXI_STR(NormalsIndex) \

#define UFBXI_PROP_STR(name) UFBXI_PROP_STR_IMP(name, #name)

#define UFBXI_PROP_STRINGS \
	UFBXI_PROP_STR_IMP(Lcl_Translation, "Lcl Translation") \
	UFBXI_PROP_STR_IMP(Lcl_Rotation, "Lcl Rotation") \
	UFBXI_PROP_STR_IMP(Lcl_Scaling, "Lcl Scaling") \

#define UFBXI_PROP_STR_IMP(m_name, m_str) static const char ufbxi_propname_##m_name[] = m_str;

	UFBXI_PROP_STRINGS

#undef UFBXI_PROP_STR_IMP

typedef enum {
	UFBXI_PROP_NONE,
	UFBXI_PROP_NUMBER,
	UFBXI_PROP_STRING,
	UFBXI_PROP_ARRAY,
} ufbxi_prop_type;

typedef union {
	struct { double f; int64_t i; }; // if `UFBXI_PROP_NUMBER`
	ufbx_string s;                   // if `UFBXI_PROP_STRING`
} ufbxi_prop_value;

typedef struct {
	union {
		void *data_pointer; // if `use_data_pointer`
		uint64_t offset;    // otherwise
	};
	size_t data_size;
	size_t num_values;
	bool real_array;
	bool use_data_pointer;
} ufbxi_prop_array;

typedef struct ufbxi_node ufbxi_node;

typedef enum {
	UFBXI_NODE_PARSED_CHILDREN = 0x1,
} ufbxi_node_flags;

struct ufbxi_node {
	const char *name;
	uint32_t num_children;
	uint8_t name_len;
	uint8_t flags;
	uint16_t prop_type_mask;

	union {
		ufbxi_node *children;     // if `flags & UFBXI_PARSED_CHILDREN`
		uint64_t children_offset; // otherwise
	};
	union {
		ufbxi_prop_array *prop_array; // if `prop_type_mask == UFBXI_PROP_ARRAY`
		ufbxi_prop_value *prop_val;   // otherwise
	};
};

typedef struct {
	uint32_t hash;
	uint32_t length;
	const char *data;
} ufbxi_string_pool_entry;

typedef struct {
	ufbxi_string_pool_entry *entries;
	size_t map_size;
	size_t num_entries;
	size_t max_entries;
} ufbxi_string_pool;

typedef struct {

#define UFBXI_STR(m_name) const char *m_name;
#define UFBXI_PROP_STR_IMP(m_name, m_str) const char *m_name;

	UFBXI_STRINGS
	UFBXI_PROP_STRINGS

#undef UFBXI_STR
#undef UFBXI_PROP_STR_IMP

} ufbxi_strings;

typedef struct {

	uint32_t version;
	bool from_ascii;
	bool big_endian;

	ufbx_load_opts opts;

	// String pointers
	ufbxi_strings s;

	// File buffer
	const char *buffer;
	uint64_t buffer_begin;
	uint64_t buffer_end;

	// File IO
	char *read_buffer;
	size_t read_buffer_size;
	ufbx_read_fn *read_fn;
	void *read_user;
	uint64_t prev_read_end;

	// Conversion source buffer
	void *convert_buf;
	size_t convert_buf_size;

	ufbxi_string_pool string_pool;

	ufbxi_ptr_map prop_type_map;

	ufbxi_node root;

	ufbx_scene scene;

	// Temporary buffers
	ufbxi_buf tmp;
	ufbxi_buf tmp_node;
	ufbxi_buf tmp_template;
	ufbxi_buf tmp_property;
	ufbxi_buf tmp_ascii_array;
	ufbxi_buf tmp_group;
	ufbxi_buf tmp_object;

	// Result buffers
	ufbxi_buf result;
	ufbxi_buf string_buf;

	ufbx_error error;

} ufbxi_context;

static ufbxi_noinline int ufbxi_fail_imp(ufbxi_context *uc, const char *cond, const char *func, uint32_t line)
{
	if (uc->error.stack_size < UFBX_ERROR_STACK_MAX_DEPTH) {
		ufbx_error_frame *frame = &uc->error.stack[uc->error.stack_size++];
		frame->description = cond;
		frame->function = func;
		frame->source_line = line;
	}
	return 0;
}

#define ufbxi_check(cond) if (!(cond)) return ufbxi_fail_imp(uc, "ufbxi_check(" #cond ")", __FUNCTION__, __LINE__)
#define ufbxi_check_uc(m_uc, cond) if (!(cond)) return ufbxi_fail_imp(m_uc, "ufbxi_check_uc(" #m_uc ", " #cond ")", __FUNCTION__, __LINE__)
#define ufbxi_fail(desc) return ufbxi_fail_imp(uc, desc, __FUNCTION__, __LINE__)
#define ufbxi_fail_uc(m_uc, desc) return ufbxi_fail_imp(m_uc, desc, __FUNCTION__, __LINE__)
#define ufbxi_check_return(cond, ret) do { if (!(cond)) { ufbxi_fail_imp(uc, "ufbxi_check_return(" #cond ", " #ret ")", __FUNCTION__, __LINE__); return ret; } } while (0)

static ufbxi_node *ufbxi_find_child(ufbxi_node *node, const char *name)
{
	ufbxi_for(ufbxi_node, c, node->children, node->num_children) {
		if (c->name == name) return c;
	}
	return NULL;
}

ufbxi_nodiscard ufbxi_forceinline static int ufbxi_get_val_at(ufbxi_node *node, size_t ix, char fmt, void *v)
{
	ufbxi_prop_type type = (ufbxi_prop_type)((node->prop_type_mask >> (ix*2)) & 0x3);
	switch (fmt) {
	case '_': return 1;
	case 'I': if (type == UFBXI_PROP_NUMBER) { *(int32_t*)v = (int32_t)node->prop_val[ix].i; return 1; } else return 0;
	case 'L': if (type == UFBXI_PROP_NUMBER) { *(int64_t*)v = (int64_t)node->prop_val[ix].i; return 1; } else return 0;
	case 'F': if (type == UFBXI_PROP_NUMBER) { *(float*)v = (float)node->prop_val[ix].i; return 1; } else return 0;
	case 'D': if (type == UFBXI_PROP_NUMBER) { *(double*)v = (double)node->prop_val[ix].i; return 1; } else return 0;
	case 'R': if (type == UFBXI_PROP_NUMBER) { *(ufbx_real*)v = (ufbx_real)node->prop_val[ix].i; return 1; } else return 0;
	case 'B': if (type == UFBXI_PROP_NUMBER) { *(bool*)v = node->prop_val[ix].i != 0; return 1; } else return 0;
	case 'S': if (type == UFBXI_PROP_STRING) { *(ufbx_string*)v = node->prop_val[ix].s; return 1; } else return 0;
	case 'C': if (type == UFBXI_PROP_STRING) { *(const char**)v = node->prop_val[ix].s.data; return 1; } else return 0;
	default:
		ufbx_assert(0 && "Bad format char");
		return 0;
	}
}

ufbxi_nodiscard static ufbxi_forceinline int ufbxi_get_val1(ufbxi_node *node, const char *fmt, void *v0)
{
	if (!ufbxi_get_val_at(node, 0, fmt[0], v0)) return 0;
	return 1;
}

ufbxi_nodiscard static ufbxi_forceinline int ufbxi_get_val2(ufbxi_node *node, const char *fmt, void *v0, void *v1)
{
	if (!ufbxi_get_val_at(node, 0, fmt[0], v0)) return 0;
	if (!ufbxi_get_val_at(node, 1, fmt[1], v1)) return 0;
	return 1;
}

ufbxi_nodiscard static ufbxi_forceinline int ufbxi_get_val3(ufbxi_node *node, const char *fmt, void *v0, void *v1, void *v2)
{
	if (!ufbxi_get_val_at(node, 0, fmt[0], v0)) return 0;
	if (!ufbxi_get_val_at(node, 1, fmt[1], v1)) return 0;
	if (!ufbxi_get_val_at(node, 2, fmt[2], v2)) return 0;
	return 1;
}

ufbxi_nodiscard static ufbxi_forceinline int ufbxi_find_val1(ufbxi_node *node, const char *name, const char *fmt, void *v0)
{
	ufbxi_node *child = ufbxi_find_child(node, name);
	if (!child) return 0;
	if (!ufbxi_get_val_at(child, 0, fmt[0], v0)) return 0;
	return 1;
}

ufbxi_nodiscard static ufbxi_forceinline int ufbxi_find_val2(ufbxi_node *node, const char *name, const char *fmt, void *v0, void *v1)
{
	ufbxi_node *child = ufbxi_find_child(node, name);
	if (!child) return 0;
	if (!ufbxi_get_val_at(child, 0, fmt[0], v0)) return 0;
	if (!ufbxi_get_val_at(child, 1, fmt[1], v1)) return 0;
	return 1;
}

static size_t ufbxi_get_array_size(ufbxi_node *node)
{
	if (node->prop_type_mask == UFBXI_PROP_ARRAY) {
		return node->prop_array->num_values;
	} else {
		// TODO: Count trailing zeros and divide by 2
		size_t num = 0;
		while (num < UFBXI_MAX_NON_ARRAY_VALUES) {
			if ((ufbxi_prop_type)((node->prop_type_mask >> (num*2)) & 0x3f) == UFBXI_PROP_NONE) break;
			num++;
		}
		return num;
	}
}

// -- String pool

static uint32_t ufbxi_string_hash(const char *str, size_t length)
{
	uint32_t hash = 0;
	uint32_t seed = UINT32_C(0x9e3779b9);
	if (length >= 4) {
		do {
			uint32_t word = ufbxi_read_u32(str);
			hash = ((hash << 5u | hash >> 27u) ^ word) * seed;
			str += 4;
			length -= 4;
		} while (length >= 4);

		uint32_t word = ufbxi_read_u32(str + length - 4);
		hash = ((hash << 5u | hash >> 27u) ^ word) * seed;
		return hash;
	} else {
		uint32_t word = 0;
		if (length >= 1) word |= (uint32_t)(uint8_t)str[0] << 0;
		if (length >= 2) word |= (uint32_t)(uint8_t)str[1] << 8;
		if (length >= 3) word |= (uint32_t)(uint8_t)str[2] << 16;
		hash = ((hash << 5u | hash >> 27u) ^ word) * seed;
		return hash;
	}
}

ufbxi_nodiscard static const char *ufbxi_push_string_imp(ufbxi_context *uc, const char *str, size_t length, bool copy)
{
	if (length == 0) return "";
	if (length >= UFBXI_MAX_STRING_LENGTH) return NULL;
	ufbxi_string_pool pool = uc->string_pool;

	// Re-hash the old string pool if necessary
	if (pool.num_entries == pool.max_entries) {
		// TODO: Set this number based on experimental data
		pool.map_size = ufbxi_max_sz(pool.map_size * 2, 512);
		pool.entries = (ufbxi_string_pool_entry*)calloc(pool.map_size, sizeof(ufbxi_string_pool_entry));
		if (!pool.entries) return NULL;

		pool.max_entries = pool.map_size / 2;

		ufbxi_string_pool old_pool = uc->string_pool;
		for (size_t i = 0; i < old_pool.map_size; i++) {
			ufbxi_string_pool_entry *src = &old_pool.entries[i];
			if (!src->length) continue;
			for (uint32_t ix = src->hash; ; ix++) {
				ufbxi_string_pool_entry *dst = &pool.entries[ix & (pool.map_size - 1)];
				if (dst->length == 0) {
					*dst = *src;
					break;
				}
			}
		}
		free(old_pool.entries);

		uc->string_pool = pool;
	}

	if (pool.num_entries >= UFBXI_MAX_STRINGS) return NULL;

	uint32_t hash = ufbxi_string_hash(str, length);
	for (uint32_t ix = hash; ; ix++) {
		ufbxi_string_pool_entry *entry = &pool.entries[ix & (pool.map_size - 1)];
		if (entry->hash == hash && entry->length == length && !memcmp(str, entry->data, length)) {
			return entry->data;
		} else if (entry->length == 0) {
			uc->string_pool.num_entries = pool.num_entries + 1;

			const char *data;
			if (copy) {
				char *dst = ufbxi_push_uninit(&uc->string_buf, char, length + 1);
				if (!dst) return NULL;
				memcpy(dst, str, length);
				dst[length] = '\0';
				data = dst;
			} else {
				data = str;
			}

			entry->data = data;
			entry->hash = hash;
			entry->length = (uint32_t)length;
			return data;
		}
	}
}

ufbxi_nodiscard static ufbxi_forceinline const char *ufbxi_push_string(ufbxi_context *uc, const char *str, size_t length)
{
	return ufbxi_push_string_imp(uc, str, length, true);
}

ufbxi_nodiscard static ufbxi_forceinline int ufbxi_push_string_place(ufbxi_context *uc, const char **p_str, size_t length)
{
	const char *str = *p_str;
	ufbxi_check(str || length == 0);
	str = ufbxi_push_string(uc, str, length);
	ufbxi_check(str);
	*p_str = str;
	return 1;
}

ufbxi_nodiscard static ufbxi_forceinline int ufbxi_push_string_place_str(ufbxi_context *uc, ufbx_string *p_str)
{
	ufbxi_check(p_str);
	return ufbxi_push_string_place(uc, &p_str->data, p_str->length);
}

ufbxi_nodiscard static int ufbxi_load_strings(ufbxi_context *uc)
{
#define UFBXI_STR(m_name) if ((uc->s.m_name = ufbxi_push_string_imp(uc, #m_name, sizeof(#m_name) - 1, false)) == NULL) return 0;
#define UFBXI_PROP_STR_IMP(m_name, m_str) if ((uc->s.m_name = ufbxi_push_string_imp(uc, ufbxi_propname_##m_name, sizeof(ufbxi_propname_##m_name) - 1, false)) == NULL) return 0; 

	UFBXI_STRINGS
	UFBXI_PROP_STRINGS

#undef UFBXI_STR
#undef UFBXI_PROP_STR_IMP

	return 1;
}

typedef struct {
	ufbx_prop_type type;
	const char *name;
} ufbxi_prop_type_name;

const ufbxi_prop_type_name ufbxi_prop_type_names[] = {
	{ UFBX_PROP_BOOLEAN, "Boolean" },
	{ UFBX_PROP_BOOLEAN, "bool" },
	{ UFBX_PROP_INTEGER, "Integer" },
	{ UFBX_PROP_INTEGER, "int" },
	{ UFBX_PROP_INTEGER, "enum" },
	{ UFBX_PROP_NUMBER, "Number" },
	{ UFBX_PROP_NUMBER, "double" },
	{ UFBX_PROP_VECTOR, "Vector" },
	{ UFBX_PROP_VECTOR, "Vector3D" },
	{ UFBX_PROP_COLOR, "Color" },
	{ UFBX_PROP_COLOR, "ColorRGB" },
	{ UFBX_PROP_STRING, "String" },
	{ UFBX_PROP_STRING, "KString" },
	{ UFBX_PROP_DATE_TIME, "DateTime" },
	{ UFBX_PROP_TRANSLATION, "Lcl Translation" },
	{ UFBX_PROP_ROTATION, "Lcl Rotation" },
	{ UFBX_PROP_SCALING, "Lcl Scaling" },
};

ufbxi_nodiscard static int ufbxi_load_maps(ufbxi_context *uc)
{
	ufbxi_check(ufbxi_ptr_map_init(&uc->prop_type_map, ufbxi_arraycount(ufbxi_prop_type_names)));
	for (size_t i = 0; i < ufbxi_arraycount(ufbxi_prop_type_names); i++) {
		ufbxi_prop_type_name name = ufbxi_prop_type_names[i];
		const char *str = ufbxi_push_string(uc, name.name, strlen(name.name));
		ufbxi_check(str);
		ufbxi_ptr_map_insert(&uc->prop_type_map, ufbxi_prop_type, str, name.type);
	}

	return 1;
}

// -- Binary parsing

ufbxi_nodiscard static int ufbxi_get_buffer_refill(ufbxi_context *uc, uint64_t offset, size_t size, bool allow_eof)
{
	if (uc->read_buffer_size < size) {
		// We need to check that the read function exists only once, so
		// we can do it at the first (or any) reallocate.
		ufbxi_check(uc->read_fn);

		size_t new_size = ufbxi_max_sz(uc->read_buffer_size * 2, UFBXI_READ_BUFFER_SIZE);
		new_size = ufbxi_max_sz(new_size, size);
		ufbxi_check(new_size <= UFBXI_MAX_READ_BUFFER_SIZE);
		void *new_buf = realloc(uc->read_buffer, new_size);
		ufbxi_check(new_buf);
		uc->read_buffer = (char*)new_buf;
		uc->read_buffer_size = new_size;
	}

	size_t num_read;
	if (offset >= uc->buffer_begin && offset < uc->buffer_end) {

		// Shift old data back from the right side of the buffer
		size_t left = (size_t)(uc->buffer_end - offset);
		size_t shift = (size_t)(offset - uc->buffer_begin);
		memmove(uc->read_buffer, uc->read_buffer + shift, left);

		// Read new data in
		uint64_t read_offset = offset + left;
		size_t read_size = uc->read_buffer_size - left;
		bool contiguous = uc->prev_read_end == read_offset;
		num_read = uc->read_fn(uc->read_user, read_offset, uc->read_buffer + left, read_size, contiguous);
		ufbxi_check(num_read != SIZE_MAX);
		num_read += left;
	} else {
		bool contiguous = uc->prev_read_end == offset;
		num_read = uc->read_fn(uc->read_user, offset, uc->read_buffer, uc->read_buffer_size, contiguous);
		ufbxi_check(num_read != SIZE_MAX);
	}

	ufbxi_check(allow_eof || num_read >= size);

	uc->buffer = uc->read_buffer;
	uc->buffer_begin = offset;
	uc->buffer_end = offset + num_read;
	uc->prev_read_end = offset + num_read;

	return 1;
}

static ufbxi_forceinline const char *ufbxi_get_buffer(ufbxi_context *uc, uint64_t offset, size_t size)
{
	if (size >= UFBXI_MAX_BUFFER_SIZE) return NULL;

	uint64_t begin = uc->buffer_begin, end = uc->buffer_end;
	int64_t left = offset - begin;
	int64_t right = end - offset;
	if (left >= 0 && right >= (int64_t)size) {
		return uc->buffer + (size_t)left;
	} else {
		if (!ufbxi_get_buffer_refill(uc, offset, size, false)) return NULL;
		return uc->buffer;
	}
}

static ufbxi_forceinline const char *ufbxi_try_get_buffer(ufbxi_context *uc, uint64_t offset, size_t size)
{
	if (size >= UFBXI_MAX_BUFFER_SIZE) return NULL;

	uint64_t begin = uc->buffer_begin, end = uc->buffer_end;
	int64_t left = offset - begin;
	int64_t right = end - offset;
	if (left >= 0 && right >= (int64_t)size) {
		return uc->buffer + (size_t)left;
	} else if (!uc->read_fn) {
		// Fail without error if there's no read function as any refill is
		// equivalent to an EOF condition.
		uc->buffer = NULL;
		uc->buffer_begin = offset;
		uc->buffer_end = offset;
		return NULL;
	} else {
		if (!ufbxi_get_buffer_refill(uc, offset, size, true)) return NULL;
		return uc->buffer;
	}
}

ufbxi_nodiscard static int ufbxi_read_to(ufbxi_context *uc, uint64_t offset, size_t size, void *dst)
{
	ufbxi_check(size < UFBXI_MAX_BUFFER_SIZE);

	uint64_t begin = uc->buffer_begin, end = uc->buffer_end;
	int64_t left = offset - begin;
	int64_t right = end - offset;
	if (left >= 0 && right >= (int64_t)size) {
		// Copy from the current buffer if the whole range is contained
		memcpy(dst, uc->buffer + (size_t)left, size);
	} else {
		// Don't try to copy parts from the current buffer, just read
		// everything straight from the source
		ufbxi_check(uc->read_fn);
		bool contiguous = uc->prev_read_end == offset;
		size_t num_read = uc->read_fn(uc->read_user, offset, dst, size, contiguous);
		ufbxi_check(num_read == size);

		uc->prev_read_end = offset + num_read;
	}

	return 1;
}

static bool ufbxi_is_null_record(ufbxi_context *uc, uint64_t offset)
{
	if (uc->version >= 7500) {
		const char *data = ufbxi_get_buffer(uc, offset, 8);
		return ufbxi_read_u64(data) == 0;
	} else {
		const char *data = ufbxi_get_buffer(uc, offset, 4);
		return ufbxi_read_u32(data) == 0;
	}
}

ufbxi_nodiscard static int ufbxi_binary_parse_node(ufbxi_context *uc, uint64_t *p_offset, ufbxi_node **p_node, ufbxi_buf *buf)
{
	uint64_t offset = *p_offset;

	ufbxi_node *node = ufbxi_push_zero(&uc->tmp_node, ufbxi_node, 1);
	ufbxi_check(node);
	if (p_node) *p_node = node;

	uint64_t end_offset, num_values, values_len;

	// Parse the node header, FBX versions over 7500 use 64-bit values for
	// most fields.
	// https://code.blender.org/2013/08/fbx-binary-file-format-specification/#node-record-format
	size_t header_size = (uc->version >= 7500) ? 25 : 13;
	const char *header = ufbxi_get_buffer(uc, offset, header_size);
	ufbxi_check(header);
	offset += header_size;
	if (uc->version >= 7500) {
		end_offset = ufbxi_read_u64(header + 0);
		num_values = ufbxi_read_u64(header + 8);
		values_len = ufbxi_read_u64(header + 16);
		node->name_len = ufbxi_read_u8(header + 24);
	} else {
		end_offset = ufbxi_read_u32(header + 0);
		num_values = ufbxi_read_u32(header + 4);
		values_len = ufbxi_read_u32(header + 8);
		node->name_len = ufbxi_read_u8(header + 12);
	}

	// The name follows immediately after the header
	node->name = ufbxi_get_buffer(uc, offset, node->name_len);
	ufbxi_check(ufbxi_push_string_place(uc, &node->name, node->name_len));
	offset += node->name_len;

	// Check that the offsets make sense so we don't loop forever
	ufbxi_check(end_offset >= offset);
	ufbxi_check(values_len <= end_offset - offset);
	uint64_t values_end_offset = offset + values_len;

	// Parse values: If there's more than `UFBXI_MAX_NON_ARRAY_VALUES` or
	// if the first element has an array type the values are treated as
	// an array. If a later member is an array the array is ignored.
	if (num_values > 0) {

		const char *data = ufbxi_get_buffer(uc, offset, 1);
		ufbxi_check(data);
		char c = data[0];
		bool array_type = (c=='c' || c=='b' || c=='i' || c=='l' || c =='f' || c=='d');
		if (num_values > UFBXI_MAX_NON_ARRAY_VALUES || array_type) {
			// Defer parsing of array properties to usage time
			node->prop_type_mask = UFBXI_PROP_ARRAY;
			node->prop_array = ufbxi_push_uninit(buf, ufbxi_prop_array, 1);
			ufbxi_check(node->prop_array);
			node->prop_array->offset = offset;
			uint64_t array_size;
			if (array_type) {
				// If the array is real parse the header to get the element count
				const char *arr_data = ufbxi_get_buffer(uc, offset + 1, 12);
				ufbxi_check(arr_data);
				array_size = ufbxi_read_u32(arr_data + 0);
				node->prop_array->real_array = true;
			} else {
				// If the array of multiple individual values use the value count
				array_size = num_values;
				node->prop_array->real_array = false;
				node->prop_array->offset = offset;
				node->prop_array->data_size = (size_t)values_len;
				ufbxi_check(values_len < UFBXI_MAX_ARRAY_SIZE_BYTES);
			}
			ufbxi_check(array_size <= UFBXI_MAX_ARRAY_SIZE);
			node->prop_array->num_values = (size_t)array_size;

		} else {
			// Non-array properties
			ufbxi_prop_value *vals = ufbxi_push_uninit(buf, ufbxi_prop_value, (size_t)num_values);
			ufbxi_check(vals);
			node->prop_val = vals;

			uint32_t prop_type_mask = 0;
			size_t i = 0;
			for (;;) {
				offset += 1;
				switch (c) {

				#define ufbxi_int_prop(m_size, m_expr) { \
					const char *val = ufbxi_get_buffer(uc, offset, m_size); \
					ufbxi_check(val); offset += m_size; \
					prop_type_mask |= UFBXI_PROP_NUMBER << (i*2); \
					vals[i].f = (double)(vals[i].i = m_expr); }

				#define ufbxi_float_prop(m_size, m_expr) { \
					const char *val = ufbxi_get_buffer(uc, offset, m_size); \
					ufbxi_check(val); offset += m_size; \
					prop_type_mask |= UFBXI_PROP_NUMBER << (i*2); \
					vals[i].i = (int64_t)(vals[i].f = m_expr); }

				// TODO: Looks like old FBX files use 'C' with 'T'/'F' as well?
				case 'C': case 'B': ufbxi_int_prop(1, *val != 0 ? 1 : 0); break;
				case 'Y': ufbxi_int_prop(2, ufbxi_read_i16(val)); break;
				case 'I': ufbxi_int_prop(4, ufbxi_read_i32(val)); break;
				case 'L': ufbxi_int_prop(8, ufbxi_read_i64(val)); break;
				case 'F': ufbxi_float_prop(4, ufbxi_read_f32(val)); break;
				case 'D': ufbxi_float_prop(8, ufbxi_read_f64(val)); break;

				case 'S': case 'R':
				{
					const char *length_data = ufbxi_get_buffer(uc, offset, 4);
					ufbxi_check(length_data);
					size_t len = ufbxi_read_u32(length_data);
					offset += 4;
					vals[i].s.data = ufbxi_get_buffer(uc, offset, len);
					vals[i].s.length = len;
					ufbxi_check(ufbxi_push_string_place_str(uc, &vals[i].s));
					offset += len;
					prop_type_mask |= UFBXI_PROP_STRING << (i*2);
				}
				break;

				default:
					ufbxi_fail("Bad property type");

				}

				if (++i == num_values) break;
				data = ufbxi_get_buffer(uc, offset, 1);
				ufbxi_check(data);
				c = data[0];
			}

			node->prop_type_mask = (uint16_t)prop_type_mask;
		}
	}

	if (values_end_offset == end_offset) {
		// No child array
		node->flags |= UFBXI_NODE_PARSED_CHILDREN;
	} else {
		node->children_offset = values_end_offset;
	}

	*p_offset = end_offset;
	return 1;
}

ufbxi_nodiscard static int ufbxi_binary_parse_node_children(ufbxi_context *uc, ufbxi_node *node, int depth, ufbxi_buf *buf)
{
	ufbx_assert(depth > 0);

	if (node->flags & UFBXI_NODE_PARSED_CHILDREN) return 1;
	node->flags |= UFBXI_NODE_PARSED_CHILDREN;

	uint64_t offset = node->children_offset;

	// Parse children
	uint32_t num_children = 0;
	for (;;) {

		// Stop if we hit a NULL record
		if (ufbxi_is_null_record(uc, offset)) {
			break;
		}

		ufbxi_node *child;
		ufbxi_check(num_children < UFBXI_MAX_CHILDREN);
		ufbxi_check(ufbxi_binary_parse_node(uc, &offset, &child, buf));

		if (depth > 1) {
			ufbxi_check(ufbxi_binary_parse_node_children(uc, child, depth - 1, buf));
		}

		num_children++;
	}

	// Pop children from `tmp_node` to a contiguous array
	if (num_children) {
		node->num_children = num_children;
		node->children = ufbxi_push_pop(buf, &uc->tmp_node, ufbxi_node, num_children);
		ufbxi_check(node->children);
	}

	return 1;
}

#define UFBXI_BINARY_MAGIC_SIZE 23
#define UFBXI_BINARY_HEADER_SIZE 27
static const char ufbxi_binary_magic[] = "Kaydara FBX Binary  \x00\x1a\x00";

ufbxi_nodiscard static int ufbxi_binary_parse(ufbxi_context *uc)
{
	uint64_t offset = UFBXI_BINARY_HEADER_SIZE;

	// Parse top-level nodes
	uint32_t num_nodes = 0;
	for (;;) {
		// Stop when we hit a NULL record
		if (ufbxi_is_null_record(uc, offset)) break;

		ufbxi_check(num_nodes < UFBXI_MAX_CHILDREN);
		ufbxi_check(ufbxi_binary_parse_node(uc, &offset, NULL, &uc->tmp));
		num_nodes++;
	}

	// Pop top-level nodes from `tmp_node` to a contiguous array
	ufbxi_node *top_nodes = ufbxi_push_pop(&uc->tmp, &uc->tmp_node, ufbxi_node, num_nodes);
	ufbxi_check(top_nodes);

	ufbxi_free_buf(&uc->tmp_node);

	uc->root.children = top_nodes;
	uc->root.num_children = num_nodes;

	return 1;
}

static char ufbxi_normalize_array_type(char type) {
	switch (type) {
	case 'r': return sizeof(ufbx_real) == sizeof(float) ? 'f' : 'd';
	case 'c': return 'b';
	default: return type;
	}
}

size_t ufbxi_array_type_size(char type)
{
	switch (type) {
	case 'r': return sizeof(ufbx_real);
	case 'b': return sizeof(bool);
	case 'i': return sizeof(int32_t);
	case 'l': return sizeof(int64_t);
	case 'f': return sizeof(float);
	case 'd': return sizeof(double);
	default: return 1;
	}
}

ufbxi_nodiscard static ufbxi_noinline int ufbxi_convert_array(char src_type, char dst_type, const void *src, void *dst, size_t size)
{
	switch (dst_type)
	{

	#define ufbxi_convert_loop(m_dst, m_size, m_expr) { \
		const char *val = (const char*)src, *val_end = val + size*m_size; \
		m_dst *d = (m_dst*)dst; \
		while (val != val_end) { *d++ = (m_dst)(m_expr); val += m_size; } }

	#define ufbxi_convert_switch(m_dst) \
		switch (src_type) { \
		case 'b': ufbxi_convert_loop(m_dst, 1, *val != 0); break; \
		case 'i': ufbxi_convert_loop(m_dst, 4, ufbxi_read_i32(val)); break; \
		case 'l': ufbxi_convert_loop(m_dst, 8, ufbxi_read_i64(val)); break; \
		case 'f': ufbxi_convert_loop(m_dst, 4, ufbxi_read_f32(val)); break; \
		case 'd': ufbxi_convert_loop(m_dst, 8, ufbxi_read_f64(val)); break; \
		default: return 0; \
		} \
		break; \

	case 'b':
		switch (src_type) {
		case 'b': ufbxi_convert_loop(char, 1, *val != 0); break;
		case 'i': ufbxi_convert_loop(char, 4, ufbxi_read_i32(val) != 0); break;
		case 'l': ufbxi_convert_loop(char, 8, ufbxi_read_i64(val) != 0); break;
		case 'f': ufbxi_convert_loop(char, 4, ufbxi_read_f32(val) != 0); break;
		case 'd': ufbxi_convert_loop(char, 8, ufbxi_read_f64(val) != 0); break;
		default: return 0;
		}
		break;

	case 'i': ufbxi_convert_switch(int32_t); break;
	case 'l': ufbxi_convert_switch(int64_t); break;
	case 'f': ufbxi_convert_switch(float); break;
	case 'd': ufbxi_convert_switch(double); break;

	default: return 0;

	}

	return 1;
}

ufbxi_nodiscard static ufbxi_noinline int ufbxi_parse_multivalue_array(ufbxi_context *uc, char dst_type, const void *src, size_t src_size, void *dst, size_t size)
{
	if (size == 0) return 1;
	const char *val = (const char*)src, *val_end = val + src_size;

	switch (dst_type)
	{

	#define ufbxi_convert_parse(m_dst, m_size, m_expr) \
		if (val_end - val < m_size) return 0; \
		*d++ = (m_dst)(m_expr); val += m_size; \

	#define ufbxi_convert_parse_switch(m_dst) { \
		m_dst *d = (m_dst*)dst; \
		for (size_t i = 0; i < size; i++) { \
			if (val == val_end) return 0; \
			switch (*val++) { \
				case 'C': \
				case 'B': ufbxi_convert_parse(m_dst, 1, *val != 0); break; \
				case 'Y': ufbxi_convert_parse(m_dst, 2, ufbxi_read_i16(val)); break; \
				case 'I': ufbxi_convert_parse(m_dst, 4, ufbxi_read_i32(val)); break; \
				case 'L': ufbxi_convert_parse(m_dst, 8, ufbxi_read_i64(val)); break; \
				case 'F': ufbxi_convert_parse(m_dst, 4, ufbxi_read_f32(val)); break; \
				case 'D': ufbxi_convert_parse(m_dst, 8, ufbxi_read_f64(val)); break; \
				default: return 0; \
			} \
		} \
	} \

	case 'b':
	{
		char *d = (char*)dst;
		for (size_t i = 0; i < size; i++) {
			if (val == val_end) return 0;
			switch (*val++) {
				case 'C':
				case 'B': ufbxi_convert_parse(char, 1, *val != 0); break;
				case 'Y': ufbxi_convert_parse(char, 2, ufbxi_read_i16(val) != 0); break;
				case 'I': ufbxi_convert_parse(char, 4, ufbxi_read_i32(val) != 0); break;
				case 'L': ufbxi_convert_parse(char, 8, ufbxi_read_i64(val) != 0); break;
				case 'F': ufbxi_convert_parse(char, 4, ufbxi_read_f32(val) != 0); break;
				case 'D': ufbxi_convert_parse(char, 8, ufbxi_read_f64(val) != 0); break;
				default: return 0;
			}
		}
	}
	break;

	case 'i': ufbxi_convert_parse_switch(int32_t); break;
	case 'l': ufbxi_convert_parse_switch(int64_t); break;
	case 'f': ufbxi_convert_parse_switch(float); break;
	case 'd': ufbxi_convert_parse_switch(double); break;

	default: return 0;

	}

	return 1;
}

ufbxi_nodiscard static int ufbxi_parse_array(ufbxi_context *uc, ufbxi_node *node, char fmt, void *dst)
{
	ufbxi_check(dst);

	char dst_type = ufbxi_normalize_array_type(fmt);
	size_t dst_elem_size = ufbxi_array_type_size(dst_type);

	if (node->prop_type_mask == UFBXI_PROP_ARRAY) {
		ufbxi_prop_array *arr = node->prop_array;

		if (arr->real_array) {
			uint64_t offset = arr->offset;
			const char *header = ufbxi_get_buffer(uc, offset, 12);
			ufbxi_check(header);
			char src_type = (char)ufbxi_read_u8(header + 0);
			uint32_t size = ufbxi_read_u32(header + 1); 
			uint32_t encoding = ufbxi_read_u32(header + 5); 
			uint32_t encoded_size = ufbxi_read_u32(header + 9); 
			offset += 13;

			ufbxi_check(size == arr->num_values);

			// Don't normalize UFBX-specific "real" to f/d
			if (src_type != 'r') {
				src_type = ufbxi_normalize_array_type(src_type);
			}

			size_t src_elem_size = ufbxi_array_type_size(src_type);
			size_t src_data_size = src_elem_size * size;

			// If the source and destination types differ we need to read the array
			// into a temporary buffer first and then convert it to the final buffer.
			// If we are on a big endian machine we must run the convert loop even
			// on equal types to swap the bytes.
			void *src_data = dst;
			if (src_type != dst_type || uc->big_endian) {
				if (uc->convert_buf_size < src_data_size) {
					uc->convert_buf_size = ufbxi_max_sz(uc->convert_buf_size * 2, src_data_size);
					ufbxi_check(uc->convert_buf_size < UFBXI_MAX_ALLOCATION_SIZE);
					free(uc->convert_buf);
					uc->convert_buf = malloc(uc->convert_buf_size);
					ufbxi_check(uc->convert_buf);
				}
				src_data = uc->convert_buf;
			}

			if (encoding == 0) {
				// Encoding 0: Plain binary data
				ufbxi_check(ufbxi_read_to(uc, offset, encoded_size, src_data));
			} else if (encoding == 1) {
				// Encoding 1: DEFLATE
				const char *encoded_data = ufbxi_get_buffer(uc, offset, encoded_size);
				ufbxi_check(encoded_data);
				ptrdiff_t res = ufbx_inflate(src_data, src_data_size, encoded_data, encoded_size);
				ufbxi_check(res == src_data_size);
			} else {
				ufbxi_fail("Bad array encoding");
			}

			if (src_type != dst_type) {
				ufbxi_check(ufbxi_convert_array(src_type, dst_type, src_data, dst, size));
			} else if (dst_type == 'b') {
				// If we didn't perform conversion but use the "bool" type we need
				// to normalize the array contents afterwards.
				ufbxi_for(char, c, (char*)dst, size) {
					*c = *c != 0;
				}
			}

		} else {

			// Parse a large number of individual values as an array
			size_t size = arr->num_values;
			const void *src;
			size_t src_size = arr->data_size;
			if (arr->use_data_pointer) {
				src = arr->data_pointer;
			} else {
				src = ufbxi_get_buffer(uc, arr->offset, src_size);
				ufbxi_check(src);
			}
			ufbxi_check(ufbxi_parse_multivalue_array(uc, dst_type, src, src_size, dst, size));

		}

	} else {

		// Parse node non-array inline properties as an array
		uint16_t type_mask = node->prop_type_mask;
		ufbxi_prop_value *val = node->prop_val;
		char *dst_ptr = (char*)dst;
		for (;;) {
			ufbxi_prop_type type = (ufbxi_prop_type)(type_mask & 0x3);
			type_mask >>= 2;
			if (!type) break;
			ufbxi_check(type == UFBXI_PROP_NUMBER);

			// No need for specialized loops as the number of these
			// properties is generally very small
			switch (dst_type) {
			case 'b': *(char*)dst_ptr = val->i != 0; dst_ptr += 1; break;
			case 'i': *(int32_t*)dst_ptr = (int32_t)val->i; dst_ptr += sizeof(int32_t); break;
			case 'l': *(int64_t*)dst_ptr = (int64_t)val->i; dst_ptr += sizeof(int64_t); break;
			case 'f': *(float*)dst_ptr = (float)val->f; dst_ptr += sizeof(int32_t); break;
			case 'd': *(double*)dst_ptr = (double)val->f; dst_ptr += sizeof(int64_t); break;
			}
			val++;
		}

	}

	return 1;
}

// -- ASCII parsing

#define UFBXI_ASCII_END '\0'
#define UFBXI_ASCII_NAME 'N'
#define UFBXI_ASCII_BARE_WORD 'B'
#define UFBXI_ASCII_INT 'I'
#define UFBXI_ASCII_FLOAT 'F'
#define UFBXI_ASCII_STRING 'S'

typedef struct {
	char *str_data;
	size_t str_len;
	char type;
	union {
		double f64;
		int64_t i64;
		uint32_t name_len;
	} value;
} ufbxi_ascii_token;

typedef struct {
	ufbxi_context *uc;

	uint64_t offset;
	uint64_t offset_end;
	const char *src;

	char token_str[2][UFBXI_ASCII_MAX_TOKEN_LENGTH];

	ufbxi_ascii_token prev_token;
	ufbxi_ascii_token token;
} ufbxi_ascii;

#define ufbxi_ascii_error(ua, desc) ufbxi_fail_uc((ua)->uc, desc)

static ufbxi_noinline char ufbxi_ascii_refill(ufbxi_ascii *ua)
{
	ufbxi_context *uc = ua->uc;
	ua->src = ufbxi_try_get_buffer(uc, ua->offset, 1);
	if (!ua->src) return '\0';
	ua->offset_end = ua->uc->buffer_end;
	if (ua->offset == ua->offset_end) {
		return '\0';
	} else {
		return *ua->src;
	}
}

static ufbxi_forceinline char ufbxi_ascii_peek(ufbxi_ascii *ua)
{
	if (ua->offset == ua->offset_end) return ufbxi_ascii_refill(ua);
	return *ua->src;
}

static ufbxi_forceinline char ufbxi_ascii_next(ufbxi_ascii *ua)
{
	if (ua->offset == ua->offset_end) return ufbxi_ascii_refill(ua);
	ua->offset++;
	ua->src++;
	if (ua->offset == ua->offset_end) return ufbxi_ascii_refill(ua);
	return *ua->src;
}

static char ufbxi_ascii_skip_whitespace(ufbxi_ascii *ua)
{
	// Ignore whitespace
	char c = ufbxi_ascii_peek(ua);
	for (;;) {
		while (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
			c = ufbxi_ascii_next(ua);
		}
		if (c == ';') {
			c = ufbxi_ascii_next(ua);
			while (c != '\n' && c != '\0') {
				c = ufbxi_ascii_next(ua);
			}
		} else {
			break;
		}
	}
	return c;
}

ufbxi_nodiscard static int ufbxi_ascii_next_token(ufbxi_ascii *ua, ufbxi_ascii_token *token)
{
	char c = ufbxi_ascii_skip_whitespace(ua);
	token->str_len = 0;

	if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '_') {
		token->type = UFBXI_ASCII_BARE_WORD;
		uint32_t len = 0;
		while ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')
			|| (c >= '0' && c <= '9') || c == '_') {
			token->str_data[len++] = c;
			if (len >= UFBXI_ASCII_MAX_TOKEN_LENGTH) {
				ufbxi_ascii_error(ua, "Token too long");
			}
			c = ufbxi_ascii_next(ua);
		}

		token->str_len = len;

		// Skip whitespace to find if there's a following ':'
		c = ufbxi_ascii_skip_whitespace(ua);
		if (c == ':') {
			token->value.name_len = len;
			token->type = UFBXI_ASCII_NAME;
			ufbxi_ascii_next(ua);
		}
	} else if ((c >= '0' && c <= '9') || c == '-' || c == '+' || c == '.') {
		token->type = UFBXI_ASCII_INT;

		uint32_t len = 0;
		while ((c >= '0' && c <= '9') || c == '-' || c == '+' || c == '.' || c == 'e' || c == 'E') {
			if (c == '.' || c == 'e' || c == 'E') {
				token->type = UFBXI_ASCII_FLOAT;
			}
			if (len == UFBXI_ASCII_MAX_TOKEN_LENGTH - 1) {
				ufbxi_ascii_error(ua, "Number is too long");
			}
			token->str_data[len++] = c;
			c = ufbxi_ascii_next(ua);
		}
		token->str_data[len] = '\0';

		char *end;
		if (token->type == UFBXI_ASCII_INT) {
			token->value.i64 = strtoll(token->str_data, &end, 10);
			if (end != token->str_data + len) {
				ufbxi_ascii_error(ua, "Bad integer constant");
			}
		} else if (token->type == UFBXI_ASCII_FLOAT) {
			token->value.f64 = strtod(token->str_data, &end);
			if (end != token->str_data + len) {
				ufbxi_ascii_error(ua, "Bad float constant");
			}
		}
	} else if (c == '"') {
		token->type = UFBXI_ASCII_STRING;
		c = ufbxi_ascii_next(ua);
		uint32_t len = 0;
		while (c != '"') {
			token->str_data[len++] = c;
			c = ufbxi_ascii_next(ua);
			if (c == '\0') {
				ufbxi_ascii_error(ua, "Unclosed string");
			}
		}
		token->str_len = len;
		// Skip closing quote
		ufbxi_ascii_next(ua);
	} else {
		token->type = c;
		ufbxi_ascii_next(ua);
	}

	return 1;
}

ufbxi_nodiscard static int ufbxi_ascii_accept(ufbxi_ascii *ua, char type)
{
	if (ua->token.type == type) {
		char *swap_data = ua->prev_token.str_data;
		ua->prev_token = ua->token;
		ua->token.str_data = swap_data;
		if (!ufbxi_ascii_next_token(ua, &ua->token)) return 0;
		return 1;
	} else {
		return 0;
	}
}

ufbxi_nodiscard static int ufbxi_ascii_parse_node(ufbxi_ascii *ua, uint32_t depth)
{
	ufbxi_context *uc = ua->uc;

	if (depth >= UFBXI_ASCII_MAX_STACK_SIZE) {
		ufbxi_ascii_error(ua, "Too many nested nodes");
	}

	if (!ufbxi_ascii_accept(ua, UFBXI_ASCII_NAME)) {
		ufbxi_ascii_error(ua, "Expected node name");
	}

	uint32_t name_len = ua->prev_token.value.name_len;
	if (name_len > 0xff) {
		ufbxi_ascii_error(ua, "Node name is too long");
	}

	const char *name = ufbxi_push_string(uc, ua->prev_token.str_data, ua->prev_token.str_len);
	ufbxi_check(name);

	ufbxi_node *node = ufbxi_push_zero(&uc->tmp_node, ufbxi_node, 1);
	node->name = name;
	node->name_len = (uint8_t)name_len;

	// ASCII doesn't support deferred parsing of nodes
	node->flags = UFBXI_NODE_PARSED_CHILDREN;

	int in_array = 0;
	size_t num_values = 0;
	uint32_t prop_type_mask = 0;

	// NOTE: Infinite loop to allow skipping the comma parsing via `continue`.
	for (;;) {
		ufbxi_ascii_token *tok = &ua->prev_token;
		if (ufbxi_ascii_accept(ua, UFBXI_ASCII_STRING)) {

			if (num_values < UFBXI_MAX_NON_ARRAY_VALUES) {
				prop_type_mask |= UFBXI_PROP_STRING << (num_values*2);
				ufbxi_prop_value *val = ufbxi_push_uninit(&uc->tmp_property, ufbxi_prop_value, 1);
				val->s.data = tok->str_data;
				val->s.length = tok->str_len;
				ufbxi_check(ufbxi_push_string_place_str(uc, &val->s));
			}

		} else if (ufbxi_ascii_accept(ua, UFBXI_ASCII_INT)) {
			int64_t val = tok->value.i64;

			if (num_values < UFBXI_MAX_NON_ARRAY_VALUES) {
				prop_type_mask |= UFBXI_PROP_NUMBER << (num_values*2);
				ufbxi_prop_value *v = ufbxi_push_uninit(&uc->tmp_property, ufbxi_prop_value, 1);
				v->f = (double)(v->i = val);
			}

			if (val >= INT16_MIN && val <= INT16_MAX) {
				char *dst = ufbxi_push_uninit(&uc->tmp_ascii_array, char, 1 + 2);
				ufbxi_check(dst);
				dst[0] = 'Y';
				ufbxi_write_i16(dst + 1, val);
			} else if (val >= INT32_MIN && val <= INT32_MAX) {
				char *dst = ufbxi_push_uninit(&uc->tmp_ascii_array, char, 1 + 4);
				ufbxi_check(dst);
				dst[0] = 'I';
				ufbxi_write_i32(dst + 1, val);
			} else {
				char *dst = ufbxi_push_uninit(&uc->tmp_ascii_array, char, 1 + 8);
				ufbxi_check(dst);
				dst[0] = 'L';
				ufbxi_write_i64(dst + 1, val);
			}

		} else if (ufbxi_ascii_accept(ua, UFBXI_ASCII_FLOAT)) {
			double val = tok->value.f64;

			if (num_values < UFBXI_MAX_NON_ARRAY_VALUES) {
				prop_type_mask |= UFBXI_PROP_NUMBER << (num_values*2);
				ufbxi_prop_value *v = ufbxi_push_uninit(&uc->tmp_property, ufbxi_prop_value, 1);
				v->i = (int64_t)(v->f = val);
			}

			if (val == (double)(float)val) {
				char *dst = ufbxi_push_uninit(&uc->tmp_ascii_array, char, 1 + 4);
				ufbxi_check(dst);
				dst[0] = 'F';
				ufbxi_write_f32(dst + 1, val);
			} else {
				char *dst = ufbxi_push_uninit(&uc->tmp_ascii_array, char, 1 + 8);
				ufbxi_check(dst);
				dst[0] = 'D';
				ufbxi_write_i64(dst + 1, val);
			}

		} else if (ufbxi_ascii_accept(ua, UFBXI_ASCII_BARE_WORD)) {

			int64_t val = 0;
			if (tok->str_len == 1 && (tok->str_data[0] == 'Y' || tok->str_data[0] == 'T')) {
				val = 1;
			} else if (tok->str_len == 1 && (tok->str_data[0] == 'N' || tok->str_data[0] == 'F')) {
				val = 0;
			} else {
				// Ignore other bare words that tend to appear, treat them as 0
				// TODO: What does "Shading: W" mean?
			}

			if (num_values < UFBXI_MAX_NON_ARRAY_VALUES) {
				prop_type_mask |= UFBXI_PROP_NUMBER << (num_values*2);
				ufbxi_prop_value *v = ufbxi_push_uninit(&uc->tmp_property, ufbxi_prop_value, 1);
				v->f = (double)(v->i = val);
			}

			{
				char *dst = ufbxi_push_uninit(&uc->tmp_ascii_array, char, 1 + 1);
				ufbxi_check(dst);
				dst[0] = 'C';
				dst[1] = (char)val;
			}

		} else if (ufbxi_ascii_accept(ua, '*')) {
			if (in_array) {
				ufbxi_ascii_error(ua, "Nested array values");
			}
			if (!ufbxi_ascii_accept(ua, UFBXI_ASCII_INT)) {
				ufbxi_ascii_error(ua, "Expected array size");
			}
			if (ufbxi_ascii_accept(ua, '{')) {
				if (!ufbxi_ascii_accept(ua, UFBXI_ASCII_NAME)) {
					ufbxi_ascii_error(ua, "Expected array content name");
				}

				// NOTE: This `continue` skips incrementing `num_values` and parsing
				// a comma, continuing to parse the values in the array.
				in_array = 1;
				continue;
			}
		} else {
			break;
		}

		// Add value and keep parsing if there's a comma. This part may be
		// skipped if we enter an array block.
		num_values++;
		if (!ufbxi_ascii_accept(ua, ',')) break;
	}

	if (in_array) {
		if (!ufbxi_ascii_accept(ua, '}')) {
			ufbxi_ascii_error(ua, "Unclosed value array");
		}
	}

	size_t array_bytes = uc->tmp_ascii_array.num_items;
	if (num_values > UFBXI_MAX_NON_ARRAY_VALUES) {
		// Convert to array: Pop property values and retain binary encoded array
		ufbxi_check(uc->tmp_property.num_items == UFBXI_MAX_NON_ARRAY_VALUES);
		ufbxi_pop(&uc->tmp_property, ufbxi_prop_value, UFBXI_MAX_NON_ARRAY_VALUES, NULL);

		char *binary = ufbxi_push_pop(&uc->tmp, &uc->tmp_ascii_array, char, array_bytes);
		ufbxi_check(binary);

		ufbxi_prop_array *arr = ufbxi_push_uninit(&uc->tmp, ufbxi_prop_array, 1);
		ufbxi_check(arr);

		arr->num_values = num_values;
		arr->data_pointer = binary;
		arr->data_size = array_bytes;
		arr->real_array = false;
		arr->use_data_pointer = true;

		node->prop_array = arr;
		node->prop_type_mask = UFBXI_PROP_ARRAY;
	} else {
		node->prop_type_mask = (uint16_t)prop_type_mask;

		// Not enough values to be an array: Free binary and retain property values
		ufbxi_pop(&uc->tmp_ascii_array, char, array_bytes, NULL);

		node->prop_val = ufbxi_push_pop(&uc->tmp, &uc->tmp_property, ufbxi_prop_value, num_values);
		ufbxi_check(node->prop_val);
	}

	if (ufbxi_ascii_accept(ua, '{')) {
		size_t num_children = 0;
		while (!ufbxi_ascii_accept(ua, '}')) {
			ufbxi_check(num_children < UFBXI_MAX_CHILDREN);
			ufbxi_check(ufbxi_ascii_parse_node(ua, depth + 1));
			num_children++;
		}

		node->children = ufbxi_push_pop(&uc->tmp, &uc->tmp_node, ufbxi_node, num_children);
		ufbxi_check(node->children);
		node->num_children = (uint32_t)num_children;
	} else {
		node->children = NULL;
		node->num_children = 0;
	}

	return 1;
}

ufbxi_nodiscard static int ufbxi_ascii_parse(ufbxi_context *uc)
{
	ufbxi_ascii ua = { 0 };
	ua.uc = uc;

	ua.token.str_data = ua.token_str[0];
	ua.prev_token.str_data = ua.token_str[1];

	// Parse top-level nodes
	uint32_t num_nodes = 0;
	ufbxi_check(ufbxi_ascii_next_token(&ua, &ua.token));
	while (!ufbxi_ascii_accept(&ua, UFBXI_ASCII_END)) {
		ufbxi_check(num_nodes < UFBXI_MAX_CHILDREN);
		ufbxi_check(ufbxi_ascii_parse_node(&ua, 0));
		num_nodes++;
	}

	// Pop top-level nodes from `tmp_node` to a contiguous array
	ufbxi_node *top_nodes = ufbxi_push_pop(&uc->tmp, &uc->tmp_node, ufbxi_node, num_nodes);
	ufbxi_check(top_nodes);

	uc->root.children = top_nodes;
	uc->root.num_children = num_nodes;

	ufbxi_free_buf(&uc->tmp_node);
	ufbxi_free_buf(&uc->tmp_property);
	ufbxi_free_buf(&uc->tmp_ascii_array);

	return 1;
}

// -- Find implementation

static ufbxi_forceinline uint32_t ufbxi_get_name_key(const char *name, size_t len)
{
	uint32_t key = 0;
	if (len >= 4) {
		key = (uint8_t)name[0]<<24 | (uint8_t)name[1]<<16 | (uint8_t)name[2]<<8 | (uint8_t)name[3];
	} else {
		for (size_t i = 0; i < 4; i++) {
			key <<= 8;
			if (i < len) key |= (uint8_t)name[i];
		}
	}
	return key;
}

static ufbxi_forceinline ufbx_prop *ufbxi_get_prop_from_list_imp(const ufbx_prop_list *list, const char *name, size_t len, uint32_t key)
{
	ufbx_prop *props = list->data;
	size_t begin = 0;
	size_t end = list->size;
	while (end - begin >= 16) {
		size_t mid = (begin + end) >> 1;
		const ufbx_prop *p = &props[mid];
		if (p->imp_key < key) {
			begin = mid + 1;
		} else { 
			end = mid;
		}
	}

	for (; begin < end; begin++) {
		const ufbx_prop *p = &props[begin];
		if (p->imp_key > key) break;
		if (p->imp_key == key && p->name.length == len && !memcmp(p->name.data, name, len)) {
			return (ufbx_prop*)p;
		}
	}

	return NULL;
}

static ufbxi_forceinline ufbx_prop *ufbxi_get_prop_from_list_interned(const ufbx_prop_list *list, const char *name, uint32_t key)
{
	ufbx_prop *props = list->data;
	size_t begin = 0;
	size_t end = list->size;
	while (end - begin >= 16) {
		size_t mid = (begin + end) >> 1;
		const ufbx_prop *p = &props[mid];
		if (p->imp_key < key) {
			begin = mid + 1;
		} else { 
			end = mid;
		}
	}

	for (; begin < end; begin++) {
		const ufbx_prop *p = &props[begin];
		if (p->imp_key > key) break;
		if (p->name.data == name) {
			return (ufbx_prop*)p;
		}
	}

	return NULL;
}

ufbxi_nodiscard static ufbxi_noinline ufbx_prop *ufbxi_get_prop_imp(const ufbx_node *node, const char *name, uint32_t key)
{
	ufbx_prop *p = ufbxi_get_prop_from_list_interned(&node->props, name, key);
	if (!p && node->prop_template) {
		p = ufbxi_get_prop_from_list_interned(&node->prop_template->props, name, key);
	}
	return p;
}

#define ufbxi_get_prop(node, name) ufbxi_get_prop_imp((node), (const char*)(ufbxi_propname_##name), \
	(uint8_t)(ufbxi_propname_##name)[0]<<24 | (uint8_t)(ufbxi_propname_##name)[1]<<16 | \
	(uint8_t)(ufbxi_propname_##name)[2]<<8 | (uint8_t)(ufbxi_propname_##name)[3])

// -- General parsing

ufbxi_nodiscard static int ufbxi_parse_node_children(ufbxi_context *uc, ufbxi_node *node, int depth, ufbxi_buf *buf)
{
	if ((node->flags & UFBXI_NODE_PARSED_CHILDREN)) return 1;
	ufbx_assert(!uc->from_ascii);
	return ufbxi_binary_parse_node_children(uc, node, depth, buf);
}

ufbxi_nodiscard static int ufbxi_read_property(ufbxi_context *uc, ufbxi_node *node, ufbx_prop *prop, int version)
{
	ufbxi_check(ufbxi_get_val2(node, "SS", &prop->name, &prop->type_str));
	uint32_t ix = 2;
	if (version == 70) {
		ufbxi_check(ufbxi_get_val_at(node, ix++, 'S', &prop->subtype_str));
	} else {
		prop->subtype_str = ufbx_empty_string;
	}
	ufbxi_check(ufbxi_get_val_at(node, ix++, 'S', &prop->flags));

	uint32_t key = 0;
	for (size_t i = 0; i < 4; i++) {
		key <<= 8;
		if (i < prop->name.length) {
			key |= (uint8_t)prop->name.data[i];
		}
	}
	prop->imp_key = key;

	prop->type = ufbxi_ptr_map_find(&uc->prop_type_map, ufbx_prop_type, prop->type_str.data);
	if (prop->type == UFBX_PROP_UNKNOWN) {
		prop->type = ufbxi_ptr_map_find(&uc->prop_type_map, ufbx_prop_type, prop->subtype_str.data);
	}
	
	return 1;
}

ufbxi_nodiscard static int ufbxi_cmp_prop(const void *va, const void *vb)
{
	const ufbx_prop *a = (const ufbx_prop*)va, *b = (const ufbx_prop*)vb;
	if (a->imp_key < b->imp_key) return -1;
	if (a->imp_key > b->imp_key) return +1;
	return strcmp(a->name.data, b->name.data);
}

ufbxi_nodiscard static int ufbxi_read_properties(ufbxi_context *uc, ufbxi_node *parent, ufbx_prop_list *props)
{
	int version = 70;
	ufbxi_node *node = ufbxi_find_child(parent, uc->s.Properties70);
	if (!node) {
		node = ufbxi_find_child(parent, uc->s.Properties60);
		if (!node) {
			// No properties found, not an error
			return 1;
		}
		version = 60;
	}

	ufbxi_for(ufbxi_node, prop_node, node->children, node->num_children) {
		ufbx_prop *prop = ufbxi_push_zero(&uc->tmp_property, ufbx_prop, 1);
		ufbxi_check(prop);
		ufbxi_check(uc->tmp_property.num_items < UFBXI_MAX_PROPERTIES);
		ufbxi_check(ufbxi_read_property(uc, prop_node, prop, version));
	}

	// Copy the propertries to the destination buffer
	size_t num = uc->tmp_property.num_items;
	props->data = ufbxi_push_pop(&uc->result, &uc->tmp_property, ufbx_prop, num);
	props->size = num;
	ufbxi_check(props->data);

	// Sort the properties by `name_hash`
	qsort(props->data, props->size, sizeof(ufbx_prop), ufbxi_cmp_prop);

	return 1;
}

ufbxi_nodiscard static int ufbxi_read_definitions(ufbxi_context *uc, ufbxi_node *definitions)
{
	ufbxi_check(ufbxi_parse_node_children(uc, definitions, 1, &uc->tmp_group));

	ufbxi_for(ufbxi_node, object, definitions->children, definitions->num_children) {
		if (object->name != uc->s.ObjectType) continue;

		ufbxi_check(ufbxi_parse_node_children(uc, object, UFBXI_MAX_DEPTH, &uc->tmp_object));

		ufbx_template *tmpl = ufbxi_push_zero(&uc->tmp_template, ufbx_template, 1);
		ufbxi_check(tmpl);
		ufbxi_check(ufbxi_get_val1(object, "S", &tmpl->type_str));

		// Pre-7000 FBX versions don't have property templates, they just have
		// the object counts by themselves.
		ufbxi_node *props = ufbxi_find_child(object, uc->s.PropertyTemplate);
		if (props) {
			ufbxi_check(ufbxi_get_val1(props, "S", &tmpl->name));
			ufbxi_check(ufbxi_read_properties(uc, props, &tmpl->props));
		}

		ufbxi_clear_buf(&uc->tmp_object);
	}

	// Copy the templates to the destination buffer
	size_t num = uc->tmp_template.num_items;
	uc->scene.templates.data = ufbxi_push_pop(&uc->result, &uc->tmp_template, ufbx_template, num);
	uc->scene.templates.size = num;
	ufbxi_check(uc->scene.templates.data);

	ufbxi_clear_buf(&uc->tmp_group);

	return 1;
}

ufbxi_nodiscard static int ufbxi_split_type_and_name(ufbxi_context *uc, ufbx_string type_and_name, ufbx_string *type, ufbx_string *name)
{
	// Name and type are packed in a single property as Type::Name (in ASCII)
	// or Type\x01\x02Name (in binary)
	const char *sep = uc->from_ascii ? "::" : "\x00\x01";
	size_t type_end;
	for (type_end = 2; type_end < type_and_name.length; type_end++) {
		const char *ch = type_and_name.data + type_end - 2;
		if (ch[0] == sep[0] && ch[1] == sep[1]) break;
	}

	// ???: ASCII and binary store type and name in different order
	if (type_end < type_and_name.length) {
		if (uc->from_ascii) {
			name->data = type_and_name.data + type_end;
			name->length = type_and_name.length - type_end;
			type->data = type_and_name.data;
			type->length = type_end - 2;
		} else {
			name->data = type_and_name.data;
			name->length = type_end - 2;
			type->data = type_and_name.data + type_end;
			type->length = type_and_name.length - type_end;
		}
	} else {
		*type = type_and_name;
		name->data = NULL;
		name->length = 0;
	}

	ufbxi_check(ufbxi_push_string_place_str(uc, type));
	ufbxi_check(ufbxi_push_string_place_str(uc, name));

	return 1;
}

static ufbxi_forceinline int ufbxi_get_array_size_divisor(ufbxi_context *uc, ufbxi_node *node, size_t *p_size, size_t divisor)
{
	ufbxi_check(node);
	size_t size = ufbxi_get_array_size(node);
	ufbxi_check(size % divisor == 0);
	*p_size = size / divisor;
	return 1;
}

ufbxi_nodiscard static int ufbxi_read_vertex_element(ufbxi_context *uc, ufbx_mesh *mesh, ufbxi_node *node,
	ufbx_vertex_element *element, const char *data_name, const char *index_name, char data_type, size_t num_components)
{
	ufbxi_node *node_data = ufbxi_find_child(node, data_name);
	ufbxi_node *node_index = index_name ? ufbxi_find_child(node, index_name) : NULL;
	ufbxi_check(node_data);

	const char *mapping;
	ufbxi_check(ufbxi_find_val1(node, uc->s.MappingInformationType, "C", (void*)&mapping));

	size_t num_elems;
	ufbxi_check(ufbxi_get_array_size_divisor(uc, node_data, &num_elems, num_components));
	size_t elem_size = ufbxi_array_type_size(data_type) * num_components;

	void *data = ufbxi_push_uninit(&uc->result, char, num_elems * elem_size);
	ufbxi_check(ufbxi_parse_array(uc, node_data, data_type, data));

	size_t mesh_num_indices = mesh->num_indices;
	int32_t *indices;

	int32_t invalid_index = uc->opts.allow_nonexistent_indices ? -1 : (int32_t)num_elems - 1;

	if (node_index) {
		size_t num_indices = ufbxi_get_array_size(node_index);

		if (mapping == uc->s.ByPolygonVertex) {

			// Indexed by polygon vertex: We can use the indices directly,
			// possibly filling the rest with `invalid_index`
			size_t arr_size = ufbxi_max_sz(num_indices, mesh_num_indices);
			indices = ufbxi_push_uninit(&uc->result, int32_t, arr_size);
			ufbxi_check(ufbxi_parse_array(uc, node_index, 'i', indices));
			for (size_t i = num_indices; i < mesh_num_indices; i++) {
				indices[i] = invalid_index;
			}

			// Check that the indices are in range
			for (size_t i = 0; i < num_indices; i++) {
				if (indices[i] < 0 || indices[i] >= (int32_t)num_elems) {
					indices[i] = invalid_index;
				}
			}

		} else if (mapping == uc->s.ByVertex) {

			// Indexed by vertex: We need to temporarily decode the vertex
			// mapping and follow through the position mapping to get the
			// final indices.
			indices = ufbxi_push_uninit(&uc->result, int32_t, mesh_num_indices);
			ufbxi_check(indices);

			int32_t *temp_indices = ufbxi_push_uninit(&uc->tmp, int32_t, num_indices);
			ufbxi_check(ufbxi_parse_array(uc, node_index, 'i', indices));

			int32_t *vert_ix = mesh->vertex_position.indices;
			for (size_t i = 0; i < mesh_num_indices; i++) {
				int32_t ix = temp_indices[i];
				indices[i] = ix >= 0 && ix < mesh->num_vertices ? vert_ix[ix] : invalid_index;
			}

			ufbxi_pop(&uc->tmp, int32_t, num_indices, NULL);
		} else if (mapping == uc->s.AllSame) {
			// Indexed by all same: ??? This could be possibly used for making
			// holes with invalid indices, but that seems really fringe.
			// Just use the shared zero index buffer for this.
		} else {
			ufbxi_fail("Invalid mapping");
		}

	} else {
	}

	return 1;
}

ufbxi_nodiscard static int ufbxi_read_mesh(ufbxi_context *uc, ufbxi_node *node, const ufbx_node *desc)
{
	ufbx_mesh *mesh = ufbxi_push_zero(&uc->result, ufbx_mesh, 1);
	mesh->node = *desc;
	mesh->node.type = UFBX_NODE_MESH;

	ufbxi_node *node_vertices = ufbxi_find_child(node, uc->s.Vertices);
	ufbxi_node *node_indices = ufbxi_find_child(node, uc->s.PolygonVertexIndex);
	ufbxi_node *node_edges = ufbxi_find_child(node, uc->s.Edges);

	// Every mesh must have at least vertices and indices
	ufbxi_check(ufbxi_get_array_size_divisor(uc, node_vertices, &mesh->num_vertices, 3));
	ufbxi_check(node_indices);
	mesh->num_indices = ufbxi_get_array_size(node_indices);

	// Read vertex data
	{
		ufbx_vec3 *vertices = ufbxi_push_uninit(&uc->result, ufbx_vec3, mesh->num_vertices);
		ufbxi_check(ufbxi_parse_array(uc, node_vertices, 'r', vertices));


		mesh->vertex_position.data = vertices;
	}

	// Read index data
	{
		int32_t *indices = ufbxi_push_uninit(&uc->result, int32_t, mesh->num_indices);
		ufbxi_check(ufbxi_parse_array(uc, node_indices, 'i', indices));

		// Read edge data while we have the un-negated indices
		if (node_edges) {
			size_t num_edges = ufbxi_get_array_size(node_edges);
			int32_t *temp_indices = ufbxi_push_uninit(&uc->tmp, int32_t, num_edges);
			ufbxi_check(temp_indices);
			ufbxi_check(ufbxi_parse_array(uc, node_edges, 'i', temp_indices));

			ufbx_edge *edges = ufbxi_push_uninit(&uc->result, ufbx_edge, num_edges);
			ufbxi_check(edges);

			for (size_t i = 0; i < num_edges; i++) {
				int32_t index_ix = temp_indices[i];
				ufbxi_check(index_ix >= 0 && index_ix < mesh->num_indices);
				int32_t ix = indices[index_ix];
				int32_t next;
				if (ix < 0) {
					// Rewind to find the first vertex of this polygon
					edges[i].indices[0] = ~ix;
					while (index_ix > 0 && indices[index_ix - 1] >= 0) {
						index_ix--;
					}
					next = indices[index_ix];
				} else {
					ufbxi_check((size_t)index_ix < mesh->num_indices - 1);
					next = indices[index_ix + 1];
				}
				edges[i].indices[0] = ix;
				edges[i].indices[1] = next >= 0 ? next : ~next;
			}

			ufbxi_pop(&uc->tmp, int32_t, num_edges, NULL);

			mesh->num_edges = num_edges;
			mesh->edges = edges;
		}

		// Count the number of faces
		int32_t *indices_end = indices + mesh->num_indices;
		uint32_t num_faces = 0;
		for (int32_t *p_ix = indices; p_ix != indices_end; p_ix++) {
			int32_t ix = *p_ix;
			if (ix < 0) num_faces++;
		}

		ufbx_face *faces = ufbxi_push_uninit(&uc->result, ufbx_face, num_faces);
		ufbxi_check(faces);

		mesh->faces = faces;
		mesh->num_faces = num_faces;

		ufbx_face *dst_face = faces;
		int32_t *p_face_begin = indices;
		for (int32_t *p_ix = indices; p_ix != indices_end; p_ix++) {
			int32_t ix = *p_ix;
			// Un-negate final indices of polygons
			if (ix < 0) {
				ix = ~ix;
				*p_ix =  ix;
				dst_face->index_begin = (int32_t)(p_face_begin - indices);
				dst_face->num_indices = (int32_t)((p_ix - p_face_begin) + 1);
				dst_face++;
				p_face_begin = p_ix + 1;
			}
			ufbxi_check(ix < mesh->num_vertices);
		}
		ufbx_assert(dst_face == faces + num_faces);

		mesh->vertex_position.indices = indices;
	}

	ufbxi_for (ufbxi_node, n, node->children, node->num_children) {
		if (n->name[0] != 'L') continue; // All names start with 'LayerElement*'

		if (n->name == uc->s.LayerElementNormal) {
			if (mesh->vertex_normal.data) continue;
			ufbxi_check(ufbxi_read_vertex_element(uc, mesh, n, &mesh->vertex_normal.element,
				uc->s.Normals, uc->s.NormalsIndex, 'r', 3));
		} else if (n->name == uc->s.LayerElementUV) {
		}
	}

	return 1;
}

ufbxi_nodiscard static int ufbxi_read_model(ufbxi_context *uc, ufbxi_node *node, const ufbx_node *desc)
{
	(void)node; // TODO

	ufbx_model *model = ufbxi_push_zero(&uc->result, ufbx_model, 1);
	model->node = *desc;
	model->node.type = UFBX_NODE_MODEL;

	// Pre-7000 FBX stores models and meshes _in the same node_ so we need to
	// create a virtual node for meshes.
	if (uc->version < 7000) {
		ufbxi_node *node_vertices = ufbxi_find_child(node, uc->s.Vertices);
		ufbxi_node *node_indices = ufbxi_find_child(node, uc->s.PolygonVertexIndex);
		if (node_vertices && node_indices) {
			ufbx_node mesh_desc = { 0 };
			mesh_desc.type = UFBX_NODE_MESH;
			ufbxi_check(ufbxi_read_mesh(uc, node, &mesh_desc));
		}
	}

	return 1;
}

ufbxi_nodiscard static int ufbxi_read_objects(ufbxi_context *uc, ufbxi_node *objects)
{
	ufbxi_check(ufbxi_parse_node_children(uc, objects, 1, &uc->tmp_group));

	ufbx_node node = { 0 };
	ufbxi_for(ufbxi_node, object, objects->children, objects->num_children) {
		ufbx_string type_and_name;

		ufbxi_check(ufbxi_parse_node_children(uc, object, UFBXI_MAX_DEPTH, &uc->tmp_object));

		// Failing to parse the object properties is not an error since
		// there's some weird objects mixed in every now and then.
		// FBX version 7000 and up uses 64-bit unique IDs per object,
		// older FBX versions just use name/type pairs, which we can
		// use as IDs since all strings are interned into a string pool.
		if (uc->version >= 7000) {
			if (!ufbxi_get_val3(object, "LSS", &node.id, &type_and_name, &node.sub_type_str)) continue;
		} else {
			if (!ufbxi_get_val2(object, "SS", &type_and_name, &node.sub_type_str)) continue;
			node.id = (uintptr_t)type_and_name.data;
		}

		ufbxi_check(ufbxi_split_type_and_name(uc, type_and_name, &node.type_str, &node.name));
		ufbxi_check(ufbxi_read_properties(uc, object, &node.props));

		const char *name = object->name;
		if (name == uc->s.Model) {
			ufbxi_check(ufbxi_read_model(uc, object, &node));
		} else if (name == uc->s.Geometry) {
			ufbxi_check(ufbxi_read_mesh(uc, object, &node));
		}

		ufbxi_clear_buf(&uc->tmp_object);
	}

	ufbxi_clear_buf(&uc->tmp_group);

	return 1;
}

ufbxi_nodiscard static int ufbxi_parse(ufbxi_context *uc)
{
	const char *header = ufbxi_get_buffer(uc, 0, UFBXI_BINARY_MAGIC_SIZE + 4);
	ufbxi_check(header);

	if (!memcmp(header, ufbxi_binary_magic, UFBXI_BINARY_MAGIC_SIZE)) {
		uc->version = ufbxi_read_u32(header + UFBXI_BINARY_MAGIC_SIZE);
		ufbxi_check(ufbxi_binary_parse(uc));
	} else {
		ufbxi_check(ufbxi_ascii_parse(uc));

		// Default to version 7400 if not found in header
		uc->version = 7400;

		// Try to get the version from the header
		ufbxi_node *header_extension = ufbxi_find_child(&uc->root, uc->s.FBXHeaderExtension);
		if (header_extension) {
			// Doesn't matter if it's not found
			ufbxi_ignore(ufbxi_find_val1(header_extension, uc->s.FBXVersion, "I", &uc->version));
		}
	}

	return 1;
}

ufbxi_nodiscard static int ufbxi_read_root(ufbxi_context *uc)
{
	// We can handle without a Definitions section
	ufbxi_node *definitions = ufbxi_find_child(&uc->root, uc->s.Definitions);
	if (definitions) {
		ufbxi_check(ufbxi_read_definitions(uc, definitions));
	}

	// Objects section must be found
	ufbxi_node *objects = ufbxi_find_child(&uc->root, uc->s.Objects);
	ufbxi_check(objects);
	ufbxi_check(ufbxi_read_objects(uc, objects));

	return 1;
}

ufbxi_nodiscard static int ufbxi_load_imp(ufbxi_context *uc)
{
	ufbxi_check(ufbxi_load_strings(uc));
	ufbxi_check(ufbxi_load_maps(uc));
	ufbxi_check(ufbxi_parse(uc));
	ufbxi_check(ufbxi_read_root(uc));

	return 1;
}

ufbx_scene *ufbxi_load(ufbxi_context *uc, ufbx_error *p_error)
{
	// Test endianness
	{
		uint8_t buf[2];
		uint16_t val = 0xbbaa;
		memcpy(buf, &val, 2);
		uc->big_endian = buf[0] == 0xbb;
	}

	if (ufbxi_load_imp(uc)) {
		// TODO
	}

	if (p_error) {
		*p_error = uc->error;
	}

	return NULL;
}

// -- File IO

size_t ufbxi_file_read(void *user, uint64_t offset, void *data, size_t size, bool contiguous)
{
	FILE *file = (FILE*)user;

	if (!contiguous) {
		#if _WIN32
			_fseeki64(file, (long long)offset, SEEK_SET);
		#else
			fseek(file, (long)offset, SEEK_SET);
		#endif
	}

	size_t num_read = fread(data, 1, size, file);
	if (num_read == 0 && ferror(file)) return SIZE_MAX;
	return num_read;
}

// -- API

const ufbx_string ufbx_empty_string = { "", 0 };

ufbx_scene *ufbx_load_memory(const void *data, size_t size, const ufbx_load_opts *opts, ufbx_error *error)
{
	(void)opts; // TODO

	ufbxi_context uc = { 0 };
	uc.buffer = (const char *)data;
	uc.buffer_begin = 0;
	uc.buffer_end = size;
	return ufbxi_load(&uc, error);
}

ufbx_scene *ufbx_load_file(const char *filename, const ufbx_load_opts *opts, ufbx_error *error)
{
	(void)opts; // TODO

	FILE *file;
	#ifdef _WIN32
		if (fopen_s(&file, filename, "rb")) return NULL;
	#else
		file = fopen(filename, "rb");
	#endif
	if (!file) return NULL;

	ufbxi_context uc = { 0 };
	uc.read_fn = &ufbxi_file_read;
	uc.read_user = file;
	ufbx_scene *scene = ufbxi_load(&uc, error);

	fclose(file);

	return scene;
}

void ufbx_free_scene(ufbx_scene *scene)
{
	(void)scene; // TODO
}

ufbx_prop *ufbx_get_prop_from_list(const ufbx_prop_list *list, const char *name)
{
	size_t len = strlen(name);
	uint32_t key = ufbxi_get_name_key(name, len);
	return ufbxi_get_prop_from_list_imp(list, name, len, key);
}

ufbx_prop *ufbx_get_prop_from_list_len(const ufbx_prop_list *list, const char *name, size_t len)
{
	uint32_t key = ufbxi_get_name_key(name, len);
	return ufbxi_get_prop_from_list_imp(list, name, len, key);
}

ufbx_prop *ufbx_get_prop(const ufbx_node *node, const char *name)
{
	size_t len = strlen(name);
	uint32_t key = ufbxi_get_name_key(name, len);
	ufbx_prop *p = ufbxi_get_prop_from_list_imp(&node->props, name, len, key);
	if (!p && node->prop_template) {
		p = ufbxi_get_prop_from_list_imp(&node->prop_template->props, name, len, key);
	}
	return p;
}

ufbx_prop *ufbx_get_prop_len(const ufbx_node *node, const char *name, size_t len)
{
	uint32_t key = ufbxi_get_name_key(name, len);
	ufbx_prop *p = ufbxi_get_prop_from_list_imp(&node->props, name, len, key);
	if (!p && node->prop_template) {
		p = ufbxi_get_prop_from_list_imp(&node->prop_template->props, name, len, key);
	}
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(_MSC_VER)
	#pragma warning(pop)
#endif

#endif
