
#if UFBXT_IMPL
static ufbx_string make_str(const char *s) {
	ufbx_string str = { s, strlen(s) };
	return str;
};
#endif

// Generated by `misc/enum_type_perfect_hash.py`
UFBXT_TEST(table_prop_type_map_values)
#if UFBXT_IMPL
{
	ufbxt_assert(ufbxi_get_prop_type(make_str("Boolean")) == UFBX_PROP_BOOLEAN);
	ufbxt_assert(ufbxi_get_prop_type(make_str("bool")) == UFBX_PROP_BOOLEAN);
	ufbxt_assert(ufbxi_get_prop_type(make_str("Integer")) == UFBX_PROP_INTEGER);
	ufbxt_assert(ufbxi_get_prop_type(make_str("int")) == UFBX_PROP_INTEGER);
	ufbxt_assert(ufbxi_get_prop_type(make_str("enum")) == UFBX_PROP_INTEGER);
	ufbxt_assert(ufbxi_get_prop_type(make_str("Number")) == UFBX_PROP_NUMBER);
	ufbxt_assert(ufbxi_get_prop_type(make_str("double")) == UFBX_PROP_NUMBER);
	ufbxt_assert(ufbxi_get_prop_type(make_str("Vector")) == UFBX_PROP_VECTOR);
	ufbxt_assert(ufbxi_get_prop_type(make_str("Vector3D")) == UFBX_PROP_VECTOR);
	ufbxt_assert(ufbxi_get_prop_type(make_str("Color")) == UFBX_PROP_COLOR);
	ufbxt_assert(ufbxi_get_prop_type(make_str("ColorRGB")) == UFBX_PROP_COLOR);
	ufbxt_assert(ufbxi_get_prop_type(make_str("String")) == UFBX_PROP_STRING);
	ufbxt_assert(ufbxi_get_prop_type(make_str("KString")) == UFBX_PROP_STRING);
	ufbxt_assert(ufbxi_get_prop_type(make_str("DateTime")) == UFBX_PROP_DATE_TIME);
	ufbxt_assert(ufbxi_get_prop_type(make_str("Lcl Translation")) == UFBX_PROP_TRANSLATION);
	ufbxt_assert(ufbxi_get_prop_type(make_str("Lcl Rotation")) == UFBX_PROP_ROTATION);
	ufbxt_assert(ufbxi_get_prop_type(make_str("Lcl Scaling")) == UFBX_PROP_SCALING);
}
#endif

UFBXT_TEST(table_node_type_map_values)
#if UFBXT_IMPL
{
	ufbxt_assert(ufbxi_get_node_type(make_str("Model")) == UFBX_NODE_MODEL);
	ufbxt_assert(ufbxi_get_node_type(make_str("Geometry")) == UFBX_NODE_MESH);
	ufbxt_assert(ufbxi_get_node_type(make_str("Material")) == UFBX_NODE_MATERIAL);
	ufbxt_assert(ufbxi_get_node_type(make_str("Texture")) == UFBX_NODE_TEXTURE);
	ufbxt_assert(ufbxi_get_node_type(make_str("AnimationCurveNode")) == UFBX_NODE_ANIMATION);
	ufbxt_assert(ufbxi_get_node_type(make_str("AnimationCurve")) == UFBX_NODE_ANIMATION_CURVE);
	ufbxt_assert(ufbxi_get_node_type(make_str("AnimationLayer")) == UFBX_NODE_ANIMATION_LAYER);
	ufbxt_assert(ufbxi_get_node_type(make_str("NodeAttribute")) == UFBX_NODE_ATTRIBUTE);
}
#endif
// End of generated code

UFBXT_TEST(table_prop_type_map_self)
#if UFBXT_IMPL
{
	size_t num = ufbxi_arraycount(ufbxi_prop_type_map);
	for (size_t i = 0; i < num; i++) {
		const ufbxi_prop_type_map_entry *entry = &ufbxi_prop_type_map[i];
		if (entry->hash == 0) continue;

		uint32_t hash = ufbxi_hash_string(entry->name);
		ufbxt_assert(entry->hash == hash);
		ufbxt_assert(ufbxi_prop_type_permute_hash(hash) == i);
	}
}
#endif

UFBXT_TEST(table_prop_type_map_not_found)
#if UFBXT_IMPL
{
	ufbxt_assert(ufbxi_get_prop_type(make_str("Test")) == UFBX_PROP_UNKNOWN);
	ufbxt_assert(ufbxi_get_prop_type(make_str("Another")) == UFBX_PROP_UNKNOWN);
}
#endif

UFBXT_TEST(table_node_type_map_self)
#if UFBXT_IMPL
{
	size_t num = ufbxi_arraycount(ufbxi_node_type_map);
	for (size_t i = 0; i < num; i++) {
		const ufbxi_node_type_map_entry *entry = &ufbxi_node_type_map[i];
		if (entry->hash == 0) continue;

		uint32_t hash = ufbxi_hash_string(entry->name);
		ufbxt_assert(entry->hash == hash);
		ufbxt_assert(ufbxi_node_type_permute_hash(hash) == i);
	}
}
#endif

UFBXT_TEST(table_node_type_map_not_found)
#if UFBXT_IMPL
{
	ufbxt_assert(ufbxi_get_node_type(make_str("Test")) == UFBX_NODE_UNKNOWN);
	ufbxt_assert(ufbxi_get_node_type(make_str("Another")) == UFBX_NODE_UNKNOWN);
}
#endif

UFBXT_TEST(temp_stacks)
#if UFBXT_IMPL
{
	ufbxi_context *uc = ufbxt_memory_context("");

	uint32_t num = 100000;
	for (uint32_t i = 0; i < num; i++) {
		uint32_t *a = ufbxi_temp_push_uninit(uc, 0, uint32_t);
		uint32_t *b = ufbxi_temp_push_uninit(uc, 1, uint32_t);
		*a = i;
		*b = i*i;
	}

	uint32_t *as = ufbxi_temp_retain_n(uc, 0, uint32_t, num);
	uint32_t *bs = ufbxi_temp_retain_n(uc, 1, uint32_t, num);
	for (uint32_t i = 0; i < num; i++) {
		ufbxt_assert(as[i] == i);
		ufbxt_assert(bs[i] == i*i);
	}
}
#endif
