#ifndef UFBX_UFBX_H_IMPLEMENTED
#define UFBX_UFBX_H_IMPLEMENTED

#include "ufbx.h"
#include <stdarg.h>
#include <stdint.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// -- Platform

#if defined(_MSC_VER)
	#define ufbxi_noinline __declspec(noinline)
	#define ufbxi_forceinline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define ufbxi_noinline __attribute__((noinline))
	#define ufbxi_forceinline inline __attribute__((always_inline))
#else
	#define ufbxi_noinline
	#define ufbxi_forceinline
#endif

#define ufbxi_arraycount(arr) (sizeof(arr) / sizeof(*(arr)))

// -- Debugging

#if !defined(ufbx_assert)
	#define ufbx_assert(cond) (void)0
#endif

#ifdef __cplusplus
extern "C" {
#endif

// -- Utility

static ufbxi_forceinline int
ufbxi_streq(ufbx_string str, const char *ref)
{
	size_t length = strlen(ref);
	return str.length == length && !memcmp(str.data, ref, length);
}

static ufbxi_forceinline int
ufbxi_streq_str(ufbx_string str, ufbx_string ref)
{
	return str.length == ref.length && !memcmp(str.data, ref.data, ref.length);
}

// TODO: Unaligned loads for some platforms
#define ufbxi_read_u8(ptr) (*(const uint8_t*)(ptr))
#define ufbxi_read_u16(ptr) (*(const uint16_t*)(ptr))
#define ufbxi_read_u32(ptr) (*(const uint32_t*)(ptr))
#define ufbxi_read_u64(ptr) (*(const uint64_t*)(ptr))
#define ufbxi_read_f32(ptr) (*(const float*)(ptr))
#define ufbxi_read_f64(ptr) (*(const double*)(ptr))
#define ufbxi_read_i8(ptr) (int8_t)(ufbxi_read_u8(ptr))
#define ufbxi_read_i16(ptr) (int16_t)(ufbxi_read_u16(ptr))
#define ufbxi_read_i32(ptr) (int32_t)(ufbxi_read_u32(ptr))
#define ufbxi_read_i64(ptr) (int64_t)(ufbxi_read_u64(ptr))

#define ufbxi_write_u8(ptr, val) (*(uint8_t*)(ptr) = (uint8_t)(val))
#define ufbxi_write_u16(ptr, val) (*(uint16_t*)(ptr) = (uint16_t)(val))
#define ufbxi_write_u32(ptr, val) (*(uint32_t*)(ptr) = (uint32_t)(val))
#define ufbxi_write_u64(ptr, val) (*(uint64_t*)(ptr) = (uint64_t)(val))
#define ufbxi_write_f32(ptr, val) (*(float*)(ptr) = (float)(val))
#define ufbxi_write_f64(ptr, val) (*(double*)(ptr) = (double)(val))
#define ufbxi_write_i8(ptr, val) ufbxi_write_u8(ptr, val)
#define ufbxi_write_i16(ptr, val) ufbxi_write_u16(ptr, val)
#define ufbxi_write_i32(ptr, val) ufbxi_write_u32(ptr, val)
#define ufbxi_write_i64(ptr, val) ufbxi_write_u64(ptr, val)

// -- DEFLATE implementation
// Pretty much based on Sean Barrett's `stb_image` deflate

#if !defined(ufbx_inflate)

// Lookup data: [0:13] extra mask [13:17] extra bits [17:32] base value
// Generated by `misc/deflate_lut.py`
static const uint32_t ufbxi_deflate_length_lut[] = {
	0x00060000, 0x00080000, 0x000a0000, 0x000c0000, 0x000e0000, 0x00100000, 0x00120000, 0x00140000, 
	0x00162001, 0x001a2001, 0x001e2001, 0x00222001, 0x00264003, 0x002e4003, 0x00364003, 0x003e4003, 
	0x00466007, 0x00566007, 0x00666007, 0x00766007, 0x0086800f, 0x00a6800f, 0x00c6800f, 0x00e6800f, 
	0x0106a01f, 0x0146a01f, 0x0186a01f, 0x01c6a01f, 0x02040000, 0x00000000, 0x00000000, 
};
static const uint32_t ufbxi_deflate_dist_lut[] = {
	0x00020000, 0x00040000, 0x00060000, 0x00080000, 0x000a2001, 0x000e2001, 0x00124003, 0x001a4003, 
	0x00226007, 0x00326007, 0x0042800f, 0x0062800f, 0x0082a01f, 0x00c2a01f, 0x0102c03f, 0x0182c03f, 
	0x0202e07f, 0x0302e07f, 0x040300ff, 0x060300ff, 0x080321ff, 0x0c0321ff, 0x100343ff, 0x180343ff, 
	0x200367ff, 0x300367ff, 0x40038fff, 0x60038fff, 0x8003bfff, 0xc003bfff, 
};

static const uint8_t ufbxi_deflate_code_length_permutation[] = {
	16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15,
};

#define UFBXI_HUFF_MAX_BITS 16
#define UFBXI_HUFF_MAX_VALUE 288
#define UFBXI_HUFF_FAST_BITS 9
#define UFBXI_HUFF_FAST_SIZE (1 << UFBXI_HUFF_FAST_BITS)
#define UFBXI_HUFF_FAST_MASK (UFBXI_HUFF_FAST_SIZE - 1)

typedef struct {
	uint64_t fast_begin_bits, fast_size_bits;
	const uint64_t *fast_data;
	const char *data;
	size_t size;
	uint64_t prefix[2], suffix[2];
} ufbxi_bit_stream;

typedef struct {
	uint32_t num_symbols;

	uint16_t sorted_to_sym[UFBXI_HUFF_MAX_VALUE]; // < Sorted symbol index to symbol
	uint16_t past_max_code[UFBXI_HUFF_MAX_BITS];  // < One past maximum code value per bit length
	int16_t code_to_sorted[UFBXI_HUFF_MAX_BITS];  // < Code to sorted symbol index per bit length
	uint16_t fast_sym[UFBXI_HUFF_FAST_SIZE];      // < Fast symbol lookup [0:12] symbol [12:16] bits
} ufbxi_huff_tree;

typedef struct {
	ufbxi_bit_stream stream;
	ufbxi_huff_tree huff_lit_length;
	ufbxi_huff_tree huff_dist;

	char *out_begin;
	char *out_ptr;
	char *out_end;
} ufbxi_deflate_context;

static ufbxi_forceinline uint32_t ufbxi_bit_reverse(uint32_t mask, uint32_t num_bits)
{
	ufbx_assert(num_bits <= 16);
	uint32_t x = mask;
    x = (((x & 0xaaaa) >> 1) | ((x & 0x5555) << 1));
    x = (((x & 0xcccc) >> 2) | ((x & 0x3333) << 2));
    x = (((x & 0xf0f0) >> 4) | ((x & 0x0f0f) << 4));
	x = (((x & 0xff00) >> 8) | ((x & 0x00ff) << 8));
	return x >> (16 - num_bits);
}

static ufbxi_noinline void
ufbxi_bit_init(ufbxi_bit_stream *s, const void *data, size_t size)
{
	uintptr_t fast_begin_addr = ((uintptr_t)data + ((8 - (uintptr_t)data) & 7u));
	uintptr_t fast_end_addr = ((uintptr_t)data + size) & ~(uintptr_t)7u;
	const char *bytes = (const char*)data;

	s->data = bytes;
	s->size = size;

	if ((ptrdiff_t)(fast_end_addr - fast_begin_addr) >= 16) {
		uint64_t fast_begin_offset = fast_begin_addr - (uintptr_t)data;
		s->fast_begin_bits = fast_begin_offset * 8;
		s->fast_size_bits = (fast_end_addr - fast_begin_addr) * 8 - 64;
		s->fast_data = (const uint64_t*)((const char*)data + fast_begin_offset);
	} else {
		s->fast_begin_bits = 0;
		s->fast_size_bits = 0;
		s->fast_data = NULL;
	}

	s->prefix[0] = s->prefix[1] = 0;
	s->suffix[0] = s->suffix[1] = 0;
	for (size_t i = 0; i < 8; i++) {
		if (i < size) {
			s->prefix[0] |= (uint64_t)(uint8_t)bytes[i] << (i * 8);
			s->suffix[1] |= (uint64_t)(uint8_t)bytes[size - i - 1] << (56 - i * 8);
		}
		if (i + 8 < size) {
			s->prefix[1] |= (uint64_t)(uint8_t)bytes[i + 8] << (i * 8);
			s->suffix[0] |= (uint64_t)(uint8_t)bytes[size - i - 9] << (56 - i * 8);
		}
	}
}

static ufbxi_noinline uint64_t
ufbxi_bit_read_slow(ufbxi_bit_stream *s, uint64_t offset_bits)
{
	if (offset_bits < 64) {
		return s->prefix[0] >> offset_bits | (s->prefix[1] << 1) << (63 - offset_bits);
	} else {
		uint64_t suffix_shift = (uint64_t)offset_bits - ((uint64_t)s->size * 8 - 128);
		if (suffix_shift < 64) {
			return s->suffix[0] >> suffix_shift | (s->suffix[1] << 1) << (63 - suffix_shift);
		} else if (suffix_shift < 128) {
			return s->suffix[1] >> (suffix_shift - 64);
		} else {
			return 0;
		}
	}
}

static ufbxi_forceinline uint64_t
ufbxi_bit_read(ufbxi_bit_stream *s, uint64_t offset_bits)
{
	uint64_t fast_pos_bits = offset_bits - s->fast_begin_bits;
	unsigned shift = fast_pos_bits & 63;
	if (fast_pos_bits < s->fast_size_bits) {
		uint64_t word = fast_pos_bits >> 6;
		uint64_t a = s->fast_data[word];
		uint64_t b = s->fast_data[word + 1];
		return a >> shift | (b << 1) << (63 - shift);
	} else {
		return ufbxi_bit_read_slow(s, offset_bits);
	}
}

// 0: Success
// -1: Overfull
// -2: Underfull
static ufbxi_noinline ptrdiff_t
ufbxi_huff_build(ufbxi_huff_tree *tree, uint8_t *sym_bits, uint32_t sym_count)
{
	ufbx_assert(sym_count <= UFBXI_HUFF_MAX_VALUE);
	tree->num_symbols = sym_count;

	uint32_t bits_counts[UFBXI_HUFF_MAX_BITS];
	memset(bits_counts, 0, sizeof(bits_counts));
	for (uint32_t i = 0; i < sym_count; i++) {
		uint32_t bits = sym_bits[i];
		ufbx_assert(bits <= UFBXI_HUFF_MAX_BITS);
		bits_counts[bits]++;
	}
	uint32_t nonzero_sym_count = sym_count - bits_counts[0];

	uint32_t total_syms[UFBXI_HUFF_MAX_BITS];
	uint32_t first_code[UFBXI_HUFF_MAX_BITS];

	tree->code_to_sorted[0] = INT16_MAX;
	tree->past_max_code[0] = 0;
	total_syms[0] = 0;

	int num_codes_left = 1;
	uint32_t code = 0;
	uint32_t prev_count = 0;
	for (uint32_t bits = 1; bits < UFBXI_HUFF_MAX_BITS; bits++) {
		uint32_t count = bits_counts[bits];
		code = (code + prev_count) << 1;
		first_code[bits] = code;
		tree->past_max_code[bits] = (uint16_t)(code + count);

		uint32_t prev_syms = total_syms[bits - 1];
		total_syms[bits] = prev_syms + count;

		// Each bit level doubles the amount of codes and potentially removes some
		num_codes_left = (num_codes_left << 1) - count;
		if (num_codes_left < 0) {
			return -1;
		}

		if (count > 0) {
			tree->code_to_sorted[bits] = (int16_t)((int)prev_syms - (int)code);
		} else {
			tree->code_to_sorted[bits] = INT16_MAX;
		}
		prev_count = count;
	}

	// All codes should be used if there's more than one symbol
	if (nonzero_sym_count > 1 && num_codes_left != 0) {
		return -2;
	}

	memset(tree->fast_sym, 0, sizeof(tree->fast_sym));

	uint32_t bits_index[UFBXI_HUFF_MAX_BITS];
	memset(bits_index, 0, sizeof(bits_index));
	memset(tree->sorted_to_sym, 0xff, sizeof(tree->sorted_to_sym));
	for (uint32_t i = 0; i < sym_count; i++) {
		uint32_t bits = sym_bits[i];
		if (bits == 0) continue;

		uint32_t index = bits_index[bits]++;
		uint32_t sorted = total_syms[bits - 1] + index;
		tree->sorted_to_sym[sorted] = i;

		uint32_t code = first_code[bits] + index;
		uint32_t rev_code = ufbxi_bit_reverse(code, bits);

		if (bits <= UFBXI_HUFF_FAST_BITS) {
			uint16_t fast_sym = i | bits << 12;
			uint32_t hi_max = 1 << (UFBXI_HUFF_FAST_BITS - bits);
			for (uint32_t hi = 0; hi < hi_max; hi++) {
				ufbx_assert(tree->fast_sym[rev_code | hi << bits] == 0);
				tree->fast_sym[rev_code | hi << bits] = fast_sym;
			}
		}
	}

	return 0;
}

static ufbxi_forceinline uint32_t
ufbxi_huff_decode_bits(const ufbxi_huff_tree *tree, uint64_t *p_bits, uint64_t *p_pos)
{
	uint32_t fast_sym_bits = tree->fast_sym[*p_bits & UFBXI_HUFF_FAST_MASK];
	if (fast_sym_bits != 0) {
		uint32_t bits = fast_sym_bits >> 12;
		*p_pos += bits;
		*p_bits >>= bits;
		return fast_sym_bits & 0x3ff;
	}

	uint32_t code = ufbxi_bit_reverse((uint32_t)*p_bits, UFBXI_HUFF_FAST_BITS + 1);
	*p_bits >>= UFBXI_HUFF_FAST_BITS + 1;
	*p_pos += UFBXI_HUFF_FAST_BITS + 1;
	for (uint32_t bits = UFBXI_HUFF_FAST_BITS + 1; bits < UFBXI_HUFF_MAX_BITS; bits++) {
		if (code < tree->past_max_code[bits]) {
			uint32_t sorted = code + tree->code_to_sorted[bits];
			if (sorted >= tree->num_symbols) return ~0u;
			return tree->sorted_to_sym[sorted];
		}
		code = code << 1 | (*p_bits & 1);
		*p_bits >>= 1;
		*p_pos += 1;
	}

	return ~0u;
}

static void
ufbxi_init_static_huff(ufbxi_deflate_context *dc)
{
	ptrdiff_t err = 0;

	uint8_t lit_length_bits[288];
	memset(lit_length_bits +   0, 8, 144 -   0);
	memset(lit_length_bits + 144, 9, 256 - 144);
	memset(lit_length_bits + 256, 7, 280 - 256);
	memset(lit_length_bits + 280, 8, 288 - 280);
	err |= ufbxi_huff_build(&dc->huff_lit_length, lit_length_bits, sizeof(lit_length_bits));

	uint8_t dist_bits[32];
	memset(dist_bits + 0, 5, 32 - 0);
	err |= ufbxi_huff_build(&dc->huff_dist, dist_bits, sizeof(dist_bits));

	ufbx_assert(err == 0);
}

// 0: Success
// -1: Huffman Overfull
// -2: Huffman Underfull
// -3: Code 16 repeat overflow
// -4: Code 17 repeat overflow
// -5: Code 18 repeat overflow
// -6: Bad length code
static ufbxi_noinline ptrdiff_t
ufbxi_init_dynamic_huff_tree(ufbxi_deflate_context *dc, const ufbxi_huff_tree *huff_code_length,
	ufbxi_huff_tree *tree, uint32_t num_symbols, uint64_t *p_pos)
{
	uint8_t code_lengths[UFBXI_HUFF_MAX_VALUE];
	ufbx_assert(num_symbols <= UFBXI_HUFF_MAX_VALUE);
	uint64_t pos = *p_pos;

	uint32_t symbol_index = 0;
	uint8_t prev = 0;
	while (symbol_index < num_symbols) {
		uint64_t bits = ufbxi_bit_read(&dc->stream, pos);

		uint32_t inst = ufbxi_huff_decode_bits(huff_code_length, &bits, &pos);
		if (inst <= 15) {
			prev = (uint8_t)inst;
			code_lengths[symbol_index++] = (uint8_t)inst;
		} else if (inst == 16) {
			uint32_t num = 3 + ((uint32_t)bits & 0x3);
			pos += 2;
			if (symbol_index + num > num_symbols) return -3;
			memset(code_lengths + symbol_index, prev, num);
			symbol_index += num;
		} else if (inst == 17) {
			uint32_t num = 3 + ((uint32_t)bits & 0x7);
			pos += 3;
			if (symbol_index + num > num_symbols) return -4;
			memset(code_lengths + symbol_index, 0, num);
			symbol_index += num;
			prev = 0;
		} else if (inst == 18) {
			uint32_t num = 11 + ((uint32_t)bits & 0x7f);
			pos += 7;
			if (symbol_index + num > num_symbols) return -5;
			memset(code_lengths + symbol_index, 0, num);
			symbol_index += num;
			prev = 0;
		} else {
			return -6;
		}
	}

	ptrdiff_t err = ufbxi_huff_build(tree, code_lengths, num_symbols);
	if (err != 0) return err;

	*p_pos = pos;
	return 0;
}

static ptrdiff_t
ufbxi_init_dynamic_huff(ufbxi_deflate_context *dc, uint64_t *p_pos)
{
	uint64_t pos = *p_pos;
	uint64_t bits = ufbxi_bit_read(&dc->stream, pos);
	pos += 14;

	uint32_t num_lit_lengths = 257 + (bits & 0x1f);
	uint32_t num_dists = 1 + (bits >> 5 & 0x1f);
	uint32_t num_code_lengths = 4 + (bits >> 10 & 0xf);

	uint8_t code_lengths[19];
	memset(code_lengths, 0, sizeof(code_lengths));

	bits = ufbxi_bit_read(&dc->stream, pos);
	for (uint32_t i = 0; i < num_code_lengths; i++) {
		code_lengths[ufbxi_deflate_code_length_permutation[i]] = (uint32_t)bits & 0x7;
		bits >>= 3;
	}
	pos += num_code_lengths * 3;

	ufbxi_huff_tree huff_code_length;
	ptrdiff_t err;
	err = ufbxi_huff_build(&huff_code_length, code_lengths, ufbxi_arraycount(code_lengths));
	if (err) return -14 + 1 + err;
	err = ufbxi_init_dynamic_huff_tree(dc, &huff_code_length, &dc->huff_lit_length, num_lit_lengths, &pos);
	if (err) return -16 + 1 + err;
	err = ufbxi_init_dynamic_huff_tree(dc, &huff_code_length, &dc->huff_dist, num_dists, &pos);
	if (err) return -22 + 1 + err;

	*p_pos = pos;
	return 0;
}

static uint32_t
ufbxi_adler32(const void *data, size_t size)
{
	size_t a = 1, b = 0;
	const size_t num_before_wrap = sizeof(size_t) == 8 ? 380368439u : 5552u;

	const char *p = (const char*)data;

	size_t size_left = size;
	while (size_left > 0) {
		size_t num = size_left <= num_before_wrap ? size_left : num_before_wrap;
		size_left -= num;
		const char *end = p + num;

		while (end - p >= 8) {
			a += (size_t)(uint8_t)p[0]; b += a;
			a += (size_t)(uint8_t)p[1]; b += a;
			a += (size_t)(uint8_t)p[2]; b += a;
			a += (size_t)(uint8_t)p[3]; b += a;
			a += (size_t)(uint8_t)p[4]; b += a;
			a += (size_t)(uint8_t)p[5]; b += a;
			a += (size_t)(uint8_t)p[6]; b += a;
			a += (size_t)(uint8_t)p[7]; b += a;
			p += 8;
		}

		while (p != end) {
			a += (size_t)(uint8_t)p[0]; b += a;
			p++;
		}

		a %= 65521u;
		b %= 65521u;
	}

	return (uint32_t)((b << 16) | (a & 0xffff));
}

static int
ufbxi_inflate_block(ufbxi_deflate_context *dc, uint64_t *p_pos)
{
	uint64_t pos = *p_pos;
	char *out_ptr = dc->out_ptr;
	char *const out_begin = dc->out_begin;
	char *const out_end = dc->out_end;

	uint64_t bits;
	uint64_t pos_end = pos;
	for (;;) {
		if (pos_end - pos < 15) {
			bits = ufbxi_bit_read(&dc->stream, pos);
			pos_end = pos + 64;
		}

		// Decode literal/length value from input stream
		uint32_t lit_length = ufbxi_huff_decode_bits(&dc->huff_lit_length, &bits, &pos);

		// If value < 256: copy value (literal byte) to output stream
		if (lit_length < 256) {
			if (out_ptr == out_end) {
				return -10;
			}
			*out_ptr++ = (char)lit_length;
		} else if (lit_length - 257 <= 285 - 257) {
			// If value = 257..285: Decode extra length and distance
			uint32_t length, distance;

			if (pos_end - pos < 33) {
				bits = ufbxi_bit_read(&dc->stream, pos);
				pos_end = pos + 64;
			}

			// Length
			{
				uint32_t lut = ufbxi_deflate_length_lut[lit_length - 257];
				uint32_t base = lut >> 17;
				uint32_t offset = ((uint32_t)bits & lut & 0x1fff); // 33-5 = 28 bits
				uint32_t offset_bits = (lut >> 13) & 0xf;
				bits >>= offset_bits;
				pos += offset_bits;
				length = base + offset;
			}

			// Distance
			{
				uint32_t dist = ufbxi_huff_decode_bits(&dc->huff_dist, &bits, &pos); // 28-15 = 13 bits
				if (dist >= 30) {
					return -11;
				}
				uint32_t lut = ufbxi_deflate_dist_lut[dist];
				uint32_t base = lut >> 17;
				uint32_t offset = ((uint32_t)bits & lut & 0x1fff); // 13-13 = 0 bits
				uint32_t offset_bits = (lut >> 13) & 0xf;
				bits >>= offset_bits;
				pos += offset_bits;
				distance = base + offset;
			}

			if ((ptrdiff_t)distance > out_ptr - out_begin || (ptrdiff_t)length > out_end - out_ptr) {
				return -12;
			}

			ufbx_assert(length > 0);
			const char *src = out_ptr - distance;
			char *dst = out_ptr;
			out_ptr += length;
			{
				// TODO: Do something better than per-byte copy
				char *end = dst + length;

				while (end - dst >= 4) {
					dst[0] = src[0];
					dst[1] = src[1];
					dst[2] = src[2];
					dst[3] = src[3];
					dst += 4;
					src += 4;
				}

				while (dst != end) {
					*dst++ = *src++;
				}
			}
		} else if (lit_length == 256) {
			break;
		} else {
			return -13;
		}
	}

	dc->out_ptr = out_ptr;
	*p_pos = pos;
	return 0;
}

// TODO: Error codes should have a quick test if the destination buffer overflowed
// Returns actual number of decompressed bytes or negative error:
// -1: Bad compression method (ZLIB header)
// -2: Requires dictionary (ZLIB header)
// -3: Bad FCHECK (ZLIB header)
// -4: Bad NLEN (Uncompressed LEN != ~NLEN)
// -5: Uncompressed source overflow
// -6: Uncompressed destination overflow
// -7: Bad block type
// -8: Truncated checksum
// -9: Checksum mismatch
// -10: Literal destination overflow
// -11: Bad distance code or distance of (30..31)
// -12: Match out of bounds
// -13: Bad lit/length code
// -14: Codelen Huffman Overfull
// -15: Codelen Huffman Underfull
// -16 - -21: Litlen Huffman: Overfull / Underfull / Repeat 16/17/18 overflow / Bad length code
// -22 - -27: Distance Huffman: Overfull / Underfull / Repeat 16/17/18 overflow / Bad length code
static ptrdiff_t
ufbxi_inflate(void *dst, size_t dst_size, const void *src, size_t src_size)
{
	ptrdiff_t err;
	ufbxi_deflate_context dc;
	ufbxi_bit_init(&dc.stream, src, src_size);
	dc.out_begin = (char*)dst;
	dc.out_ptr = (char*)dst;
	dc.out_end = (char*)dst + dst_size;

	uint64_t pos = 0;
	uint64_t bits = ufbxi_bit_read(&dc.stream, pos);

	// Zlib header
	{
		size_t cmf = (size_t)(bits & 0xff);
		size_t flg = (size_t)(bits >> 8) & 0xff;
		bits >>= 16;
		pos += 16;

		if ((cmf & 0xf) != 0x8) return -1;
		if ((flg & 0x20) != 0) return -2;
		if ((cmf << 8 | flg) % 31u != 0) return -3;
	}

	for (;;) { 
		bits = ufbxi_bit_read(&dc.stream, pos);

		// Block header: [0:1] BFINAL [1:3] BTYPE
		size_t header = (size_t)bits & 0x7;
		bits >>= 3;
		pos += 3;

		size_t type = header >> 1;
		if (type == 0) {
			// 0b00 - no compression
			// Round up to the next byte
			size_t byte_pos = (size_t)((pos + 7) >> 3);
			bits >>= ((uint64_t)byte_pos << 3) - pos;

			// Literal header: [0:2] LEN [2:4] NLEN = ~LEN
			const uint8_t *src_pos = (const uint8_t*)src + byte_pos;
			size_t len = (size_t)(bits & 0xffff);
			size_t nlen = (size_t)((bits >> 16) & 0xffff);
			if ((len ^ nlen) != 0xffff) return -4;
			if (byte_pos + len + 4 > src_size) return -5;
			if (dc.out_end - dc.out_ptr < (ptrdiff_t)len) return -6;

			// Copy literal data (skipping header) and advance
			memcpy(dc.out_ptr, src_pos + 4, len);
			dc.out_ptr += len;
			pos = (byte_pos + 4 + len) << 3;
		} else if (type <= 2) {
			if (type == 1) {
				// TODO: Cache the trees?
				ufbxi_init_static_huff(&dc);
			} else { 
				err = ufbxi_init_dynamic_huff(&dc, &pos);
				if (err) return err;
			}

			err = ufbxi_inflate_block(&dc, &pos);
			if (err) return err;
		} else {
			// 0b11 - reserved (error)
			return -7;
		}

		// BFINAL: End of stream
		if (header & 1) break;
	}

	// Check Adler-32
	{
		// Round up to the next byte
		size_t byte_pos = (size_t)((pos + 7) >> 3);
		if (src_size < byte_pos + 4) {
			return -8;
		}
		const uint8_t *p = (const uint8_t*)src + byte_pos;
		uint32_t ref = p[0] << 24 | p[1] << 16 | p[2] << 8 | p[3];
		uint32_t checksum = ufbxi_adler32(dc.out_begin, dc.out_ptr - dc.out_begin);
		if (ref != checksum) {
			return -9;
		}
	}

	return dc.out_ptr - dc.out_begin;
}

#define ufbx_inflate ufbxi_inflate

#endif // !defined(ufbx_inflate)

// -- Binary parsing

typedef struct {
	ufbx_string name;
	size_t value_begin_pos;
	size_t child_begin_pos;
	size_t end_pos;

	size_t next_value_pos;
} ufbxi_node;

typedef struct {
	uint32_t hash;
	uint32_t index;
} ufbxi_map_entry;

typedef struct {
	uint64_t *offsets;
	ufbxi_map_entry *entries;
	size_t capacity;
	size_t mask;
} ufbxi_child_map;

typedef struct {
	ufbxi_node node;

	// Offset for iterating children
	size_t next_child_pos;

	ufbxi_child_map map;
} ufbxi_stack_node;

#define UFBXI_NODE_STACK_SIZE 16
#define UFBXI_STRING_POOL_SIZE 512
#define UFBXI_STRING_SCAN_DISTANCE 16
#define UFBXI_MAX_TEMP_STACKS 4
#define UFBXI_MAX_TEMP_STACK_PAGES 8

static const size_t ufbxi_temp_page_sizes[UFBXI_MAX_TEMP_STACK_PAGES] = {
	1 << 12, 1 << 14, 1 << 16, 1 << 17, 1 << 18, 1 << 18, 1 << 18, 1 << 18
};

typedef struct {
	uint32_t hash;
	uint32_t reftime;
	ufbx_string str;
} ufbxi_pushed_string;

typedef struct {
	char *data;
	size_t offset;
} ufbxi_temp_page;

typedef struct {
	ufbxi_temp_page pages[UFBXI_MAX_TEMP_STACK_PAGES];
	size_t page_index;
} ufbxi_temp_stack;

typedef struct {
	ufbx_scene scene;
	void *memory;
} ufbxi_scene_imp;

typedef struct {
	const char *data;
	size_t size;

	uint32_t version;
	int from_ascii;

	// Currently focused (via find or iteration) node.
	ufbxi_node focused_node;

	// Entered node stack.
	ufbxi_stack_node node_stack[UFBXI_NODE_STACK_SIZE];
	ufbxi_stack_node *node_stack_top;

	// Temporary buffer for decompression
	void *decompress_buffer;
	size_t decompress_buffer_size;

	// Output arena
	char *result_data;
	size_t result_pos;
	size_t result_size;

	// Temp stacks
	ufbxi_temp_stack temp_stacks[UFBXI_MAX_TEMP_STACKS];

	// Error status
	int failed;
	ufbx_error *error;

	// Pushed string pool LRU cache
	ufbxi_pushed_string string_pool[UFBXI_STRING_POOL_SIZE];
	uint32_t string_pool_time;

	// Result
	ufbxi_scene_imp *scene_imp;
	ufbx_scene *scene;

} ufbxi_context;

typedef enum {
	UFBXI_VAL_INT,    // < I,L,Y,C
	UFBXI_VAL_FLOAT,  // < F,D
	UFBXI_VAL_STRING, // < S
	UFBXI_VAL_ARRAY,  // < i,l,f,d,b
} ufbxi_val_class;

typedef enum {
	UFBXI_ENCODING_BASIC = 0,
	UFBXI_ENCODING_DEFLATE = 1,

	// Custom array encoding for older FBX compatability. Concatenates multiple
	// individual values into a single array. Magic number 'UFmv' (little endian)
	// chosen to minimize risk of colliding with other custom encodings.
	UFBXI_ENCODING_MULTIVALUE = 0x766d4655,
} ufbxi_array_encoding;

typedef struct {
	size_t num_elements;
	ufbxi_array_encoding encoding;  
	size_t encoded_size;
	size_t data_offset;
	char src_type;
	char dst_type;
} ufbxi_array;

typedef struct {
	char type_code;
	ufbxi_val_class value_class;
	union {
		int64_t i;
		double f;
		ufbx_string str;
		ufbxi_array arr;
	} value;
} ufbxi_any_value;

static void ufbxi_do_error_common(ufbxi_context *uc, uint32_t line)
{
	uc->failed = 1;
	ufbx_error *err = uc->error;
	if (err) {
		err->source_line = line;
		ufbxi_stack_node *node = uc->node_stack + 1;
		uint32_t ix = 0;
		for (; node <= uc->node_stack_top && ix < UFBX_ERROR_STACK_MAX_DEPTH; node++, ix++) {
			size_t len = node->node.name.length;
			if (len > UFBX_ERROR_STACK_NAME_MAX_LENGTH) {
				len = UFBX_ERROR_STACK_NAME_MAX_LENGTH;
			}
			memcpy(err->stack[ix], node->node.name.data, len);
			err->stack[ix][len] = '\0';
		}
		err->stack_size = ix;
	}
}

static int ufbxi_do_error(ufbxi_context *uc, uint32_t line, const char *desc)
{
	if (uc->failed) return 0;
	ufbxi_do_error_common(uc, line);
	if (uc->error) {
		size_t length = strlen(desc);
		if (length > UFBX_ERROR_DESC_MAX_LENGTH) length = UFBX_ERROR_DESC_MAX_LENGTH;
		memcpy(uc->error->desc, desc, length);
		uc->error->desc[length] = '\0';
	}
	return 0;
}

static int ufbxi_do_errorf(ufbxi_context *uc, uint32_t line, const char *fmt, ...)
{
	if (uc->failed) return 0;
	ufbxi_do_error_common(uc, line);
	if (uc->error) {
		va_list args;
		va_start(args, fmt);
		vsnprintf(uc->error->desc, sizeof(uc->error->desc), fmt, args);
		va_end(args);
	}
	return 0;
}

#define ufbxi_error(uc, desc) ufbxi_do_error((uc), __LINE__, (desc))
#define ufbxi_errorf(uc, fmt, ...) ufbxi_do_errorf((uc), __LINE__, (fmt), __VA_ARGS__)

static void *ufbxi_push_size_uninit(ufbxi_context *uc, size_t size, uint32_t line)
{
	// Align to 8 bytes
	size += (size_t)-(intptr_t)size & 7u;

	size_t pos = uc->result_pos;
	if (uc->result_size - pos >= size) {
		uc->result_pos = pos + size;
		return uc->result_data + pos;
	} else {
		size_t page_size = uc->result_size * 2;
		if (page_size == 0) page_size = 512;
		while (page_size + 8 < size) {
			page_size *= 2;
		}

		void *page = malloc(page_size);
		if (!page) {
			ufbxi_do_errorf(uc, line, "Failed to allocate memory: %zu bytes", page_size);
			return NULL;
		}
		*(void**)page = uc->result_data;
		uc->result_pos = 8 + size;
		uc->result_data = (char*)page;
		uc->result_size = page_size;
		return (char*)page + 8;
	}
}

static void *ufbxi_push_size_zero(ufbxi_context *uc, size_t size, uint32_t line)
{
	void *ptr = ufbxi_push_size_uninit(uc, size, line);
	if (ptr) {
		memset(ptr, 0, size);
	}
	return ptr;
}

static void *ufbxi_temp_push_size_uninit(ufbxi_context *uc, int index, size_t num, size_t size, uint32_t line)
{
	ufbx_assert(index < UFBXI_MAX_TEMP_STACKS);
	ufbxi_temp_stack *stack = &uc->temp_stacks[index];

	// Align to 8 bytes
	size += (size_t)-(intptr_t)size & 7u;
	size *= num;

	while (stack->page_index < UFBXI_MAX_TEMP_STACK_PAGES) {
		ufbxi_temp_page *page = &stack->pages[stack->page_index];
		size_t page_size = ufbxi_temp_page_sizes[stack->page_index];
		size_t space_left = page_size - page->offset;
		if (space_left >= size) {
			if (page->data == NULL) {
				page->data = (char*)malloc(page_size);
				if (!page->data) {
					ufbxi_do_errorf(uc, line, "Failed to allocate memory: %zu bytes", page_size);
					return NULL;
				}
			}
			void *ptr = page->data + page->offset;
			page->offset += size;
			return ptr;
		}
		stack->page_index++;
	}

	ufbxi_do_errorf(uc, line, "Temp stack overflow: %d", index);
	return NULL;
}

static void *ufbxi_temp_push_size_zero(ufbxi_context *uc, int index, size_t num, size_t size, uint32_t line)
{
	void *ptr = ufbxi_temp_push_size_uninit(uc, index, num, size, line);
	if (ptr) {
		memset(ptr, 0, size);
	}
	return ptr;
}

static void ufbxi_temp_pop_size(ufbxi_context *uc, int index, size_t num, size_t size)
{
	ufbx_assert(index < UFBXI_MAX_TEMP_STACKS);
	ufbxi_temp_stack *stack = &uc->temp_stacks[index];
	ufbx_assert(stack->page_index < UFBXI_MAX_TEMP_STACK_PAGES);

	// Align to 8 bytes
	size += (size_t)-(intptr_t)size & 7u;

	size_t size_left = num * size;
	for (;;) {
		ufbxi_temp_page *page = &stack->pages[stack->page_index];
		if (page->offset >= size_left) {
			page->offset -= size_left;
			return;
		} else {
			size_left -= page->offset;
			page->offset = 0;
			ufbx_assert(stack->page_index > 0);
			stack->page_index--;
		}
	}
}

static void *ufbxi_temp_retain_size(ufbxi_context *uc, int index, size_t num, size_t size, uint32_t line)
{
	ufbxi_temp_stack *stack = &uc->temp_stacks[index];
	ufbx_assert(stack->page_index < UFBXI_MAX_TEMP_STACK_PAGES);

	// Align to 8 bytes
	size_t unaligned_size = size;
	size += (size_t)-(intptr_t)size & 7u;

	char *dst = (char*)ufbxi_push_size_uninit(uc, num * unaligned_size, line);
	if (!dst) return NULL;
	dst += num * unaligned_size;

	for (size_t i = 0; i < num; i++) {
		dst -= unaligned_size;
		while (stack->pages[stack->page_index].offset == 0) {
			stack->page_index--;
		}

		ufbxi_temp_page *page = &stack->pages[stack->page_index];
		ufbx_assert(page->offset >= size);
		page->offset -= size;
		memcpy(dst, page->data + page->offset, unaligned_size);
	}

	return dst;
}

static uint32_t ufbxi_hash_string(ufbx_string str)
{
	// FNV-1a
	uint32_t hash = 0x811c9dc5;
	for (const char *c = str.data, *e = c + str.length; c != e; c++) {
		hash = (hash ^ (uint32_t)(unsigned char)*c) * 0x01000193;
	}
	if (hash == 0) hash = 1;
	return hash;
}

static ufbx_string ufbxi_push_string_size(ufbxi_context *uc, ufbx_string str, uint32_t line)
{
	// Special case zero length
	if (str.length == 0) {
		ufbx_string zero_str = { "", 0 };
		return zero_str;
	}

	uint32_t hash = ufbxi_hash_string(str);
	uint32_t base_index = hash >> 16;
	uint32_t insert_index = 0;
	uint32_t insert_time = UINT32_MAX;
	for (uint32_t scan = 0; scan < UFBXI_STRING_SCAN_DISTANCE; scan++) {
		uint32_t index = (base_index + (scan*scan)) & (UFBXI_STRING_POOL_SIZE - 1);
		ufbxi_pushed_string *ps = &uc->string_pool[index];
		if (ps->hash == hash && ufbxi_streq_str(str, ps->str)) {
			ps->reftime = ++uc->string_pool_time;
			return ps->str;
		} else if (ps->hash == 0) {
			insert_index = index;
			break;
		} else if (ps->reftime < insert_time) {
			insert_index = index;
		}
	}

	char *ptr = (char*)ufbxi_push_size_uninit(uc, str.length + 1, line);
	memcpy(ptr, str.data, str.length);
	ptr[str.length] = 0;

	ufbx_string s;
	s.data = ptr;
	s.length = str.length;

	ufbxi_pushed_string *ps = &uc->string_pool[insert_index];
	ps->hash = hash;
	ps->reftime = ++uc->string_pool_time;
	ps->str = s;

	return s;
}

static void ufbxi_free_result(void *page)
{
	while (page) {
		void *next = *(void**)page;
		free(page);
		page = next;
	}
}

#define ufbxi_push_uninit(uc, type) (type*)ufbxi_push_size_uninit((uc), sizeof(type), __LINE__)
#define ufbxi_push_uninit_n(uc, type, n) (type*)ufbxi_push_size_uninit((uc), (n) * sizeof(type), __LINE__)

#define ufbxi_push_zero(uc, type) (type*)ufbxi_push_size_zero((uc), sizeof(type), __LINE__)
#define ufbxi_push_zero_n(uc, type, n) (type*)ufbxi_push_size_zero((uc), (n) * sizeof(type), __LINE__)

#define ufbxi_push_string(uc, str) ufbxi_push_string_size((uc), (str), __LINE__)

#define ufbxi_temp_push_uninit(uc, index, type) (type*)ufbxi_temp_push_size_uninit((uc), (index), 1, sizeof(type), __LINE__)
#define ufbxi_temp_push_uninit_n(uc, index, type, n) (type*)ufbxi_temp_push_size_uninit((uc), (index), (n), sizeof(type), __LINE__)

#define ufbxi_temp_push_zero(uc, index, type) (type*)ufbxi_temp_push_size_zero((uc), (index), 1, sizeof(type), __LINE__)
#define ufbxi_temp_push_zero_n(uc, index, type, n) (type*)ufbxi_temp_push_size_zero((uc), (index), (n), sizeof(type), __LINE__)

#define ufbxi_temp_pop(uc, index, type) ufbxi_temp_pop_size((uc), (index), 1, sizeof(type), __LINE__)
#define ufbxi_temp_pop_n(uc, index, type, n) ufbxi_temp_pop_size((uc), (index), (n), sizeof(type), __LINE__)

#define ufbxi_temp_retain(uc, index, type) (type*)ufbxi_temp_retain_size((uc), (index), 1, sizeof(type), __LINE__)
#define ufbxi_temp_retain_n(uc, index, type, n) (type*)ufbxi_temp_retain_size((uc), (index), (n), sizeof(type), __LINE__)

// Prepare `dst` as an multivalue encoded array. Does not parse the data yet,
// only counts the number of elements, checks types, and skips the array data.
static int ufbxi_convert_multivalue_array(ufbxi_context *uc, ufbxi_array *dst, char dst_type)
{
	size_t begin = uc->focused_node.next_value_pos;
	uint32_t num_elements = 0;
	while (uc->focused_node.next_value_pos < uc->focused_node.child_begin_pos) {
		char src_type = uc->data[uc->focused_node.next_value_pos];
		uint32_t size;
		switch (src_type) {
		case 'I': size = 4; break;
		case 'L': size = 8; break;
		case 'Y': size = 2; break;
		case 'C': size = 1; break;
		case 'F': size = 4; break;
		case 'D': size = 8; break;
		default: return ufbxi_errorf(uc, "Bad multivalue array type '%c'", src_type);
		}
		uc->focused_node.next_value_pos += 1 + size;
		num_elements++;
	}
	if (uc->focused_node.next_value_pos != uc->focused_node.child_begin_pos) {
		return ufbxi_error(uc, "Multivalue array overrun");
	}

	dst->num_elements = num_elements;
	dst->data_offset = begin;
	dst->encoding = UFBXI_ENCODING_MULTIVALUE;
	dst->encoded_size = uc->focused_node.next_value_pos - begin;
	// NOTE: Multivalue arrays can be heterogenous, just use `dst_type` as `src_type`
	dst->src_type = dst_type; 
	dst->dst_type = dst_type;
	return 1;
}
// Parse the next node value in the input stream.
// `dst_type` is a FBX-like type string:
//   Numbers: "I" u/int32_t  "L" u/int64_t  "B" char (bool)  "F" float  "D" double
//   Data: "SR" ufbx_string  "ilfdb" ufbxi_val_array (matching upper-case type)
//   Misc: "." (ignore)  "?" ufbxi_any_value
// Performs implicit conversions:
//   FDILY -> FD, ILYC -> ILB, ILFDYilfd -> fd, ILYCilb -> ilb
static int ufbxi_parse_value(ufbxi_context *uc, char dst_type, void *dst)
{
	// An FBX file must end in a 13 or 25-byte NULL node. Due to this a valid
	// FBX file must always have space for the largest possible property header.
	if (uc->size - uc->focused_node.next_value_pos < 13) {
		return ufbxi_error(uc, "Reading value at the end of file");
	}

	if (uc->focused_node.next_value_pos >= uc->focused_node.child_begin_pos) {
		return ufbxi_error(uc, "Out of values to parse");
	}

	size_t pos = uc->focused_node.next_value_pos;
	char src_type = uc->data[pos];
	const char *src = uc->data + pos + 1;

	// Read the next value locally
	size_t val_size = 1;
	ufbxi_val_class val_class;
	int64_t val_int;
	double val_float;
	size_t val_num_elements;
	uint32_t val_encoding;
	size_t val_encoded_size;
	size_t val_data_offset;
	switch (src_type) {
	case 'I': val_class = UFBXI_VAL_INT; val_int = ufbxi_read_i32(src); val_size += 4; break;
	case 'L': val_class = UFBXI_VAL_INT; val_int = ufbxi_read_i64(src); val_size += 8; break;
	case 'Y': val_class = UFBXI_VAL_INT; val_int = ufbxi_read_i16(src); val_size += 2; break;
	case 'C': val_class = UFBXI_VAL_INT; val_int = (ufbxi_read_u8(src) ? 1 : 0); val_size += 1; break;
	case 'F': val_class = UFBXI_VAL_FLOAT; val_float = ufbxi_read_f32(src); val_size += 4; break;
	case 'D': val_class = UFBXI_VAL_FLOAT; val_float = ufbxi_read_f64(src); val_size += 8; break;
	case 'S': case 'R':
		val_class = UFBXI_VAL_STRING;
		val_num_elements = ufbxi_read_u32(src);
		if (val_num_elements > 0x1000000) {
			return ufbxi_errorf(uc, "String is too large: %u bytes", val_num_elements);
		}
		val_size += 4 + val_num_elements;
		val_data_offset = pos + 5;
		break;
	case 'i': case 'l': case 'f': case 'd': case 'b':
		val_class = UFBXI_VAL_ARRAY;
		val_num_elements = ufbxi_read_u32(src + 0);
		val_encoding = ufbxi_read_u32(src + 4);
		val_encoded_size = ufbxi_read_u32(src + 8);
		if (val_encoded_size > 0x1000000) {
			return ufbxi_errorf(uc, "Array is too large: %u bytes", val_encoded_size);
		}
		val_size += 12 + val_encoded_size;
		val_data_offset = pos + 13;
		break;
	default:
		if (src_type >= 32 && src_type < 127) {
			return ufbxi_errorf(uc, "Invalid type code 0x%02x '%c'", src_type, src_type);
		} else {
			return ufbxi_errorf(uc, "Invalid type code 0x%02x", src_type);
		}
	}

	size_t val_end = pos + val_size;
	if (val_end < pos || val_end > uc->focused_node.child_begin_pos) {
		return ufbxi_errorf(uc, "Value overflows data block: %u bytes", val_size);
	}
	uc->focused_node.next_value_pos = val_end;

	// Early return: Ignore the data
	if (dst_type == '.') return 1;
	ufbxi_any_value *any = NULL;
	if (dst_type == '?') {
		any = (ufbxi_any_value*)dst;
		any->type_code = src_type;
		any->value_class = val_class;
	}

	// Interpret the read value into the user pointer, potentially applying the
	// implicit conversion rules.
	if (val_class == UFBXI_VAL_INT) {
		switch (dst_type) {
		case 'I': *(int32_t*)dst = (int32_t)val_int; break;
		case 'L': *(int64_t*)dst = val_int; break;
		case 'B': *(char*)dst = val_int ? 1 : 0; break;
		case 'F': *(float*)dst = (float)val_int; break;
		case 'D': *(double*)dst = (double)val_int; break;
		case '?': any->value.i = val_int; break;
		case 'i': case 'l': case 'f': case 'd': case 'b':
			// Early return: Parse as multivalue array. Reset position to beginning and rescan.
			uc->focused_node.next_value_pos = pos;
			return ufbxi_convert_multivalue_array(uc, (ufbxi_array*)dst, dst_type);
		default:
			return ufbxi_errorf(uc, "Cannot convert from int '%c' to '%c'", src_type, dst_type);
		}

	} else if (val_class == UFBXI_VAL_FLOAT) {
		switch (dst_type) {
		case 'F': *(float*)dst = (float)val_float; break;
		case 'D': *(double*)dst = val_float; break;
		case '?': any->value.f = val_float; break;
		case 'f': case 'd':
			// Early return: Parse as multivalue array. Reset position to beginning and rescan.
			uc->focused_node.next_value_pos = pos;
			return ufbxi_convert_multivalue_array(uc, (ufbxi_array*)dst, dst_type);
		default:
			return ufbxi_errorf(uc, "Cannot convert from float '%c' to '%c'", src_type, dst_type);
		}

	} else if (val_class == UFBXI_VAL_STRING) {
		ufbx_string *str;
		switch (dst_type) {
		case 'S': str = (ufbx_string*)dst; break;
		case '?': str = &any->value.str; break;
		default:
			return ufbxi_errorf(uc, "Cannot convert from string '%c' to '%c'", src_type, dst_type);
		}

		str->data = uc->data + val_data_offset;
		str->length = val_num_elements;
	} else if (val_class == UFBXI_VAL_ARRAY) {
		ufbxi_array *arr;
		switch (dst_type) {
		case 'i': case 'l': case 'f': case 'd': case 'b':
			arr = (ufbxi_array*)dst;
			arr->dst_type = dst_type;
			break;
		case '?':
			arr = &any->value.arr;
			arr->dst_type = src_type;
			break;
		default:
			return ufbxi_errorf(uc, "Cannot convert from array '%c' to '%c'", src_type, dst_type);
		}

		arr->src_type = src_type;
		arr->num_elements = val_num_elements;
		arr->encoding = (ufbxi_array_encoding)val_encoding;
		arr->encoded_size = val_encoded_size;
		arr->data_offset = val_data_offset;
		if (val_encoding != UFBXI_ENCODING_BASIC && val_encoding != UFBXI_ENCODING_DEFLATE) {
			return ufbxi_errorf(uc, "Unknown array encoding: %u", val_encoding);
		}
	}

	return 1;
}

// VA-list version of `ufbxi_parse_values()`
static int ufbxi_parse_values_va(ufbxi_context *uc, const char *fmt, va_list args)
{
	const char *fmt_ptr = fmt;
	char ch;
	while ((ch = *fmt_ptr) != '\0') {
		void *dst = NULL;
		if (ch != '.') dst = va_arg(args, void*);
		if (!ufbxi_parse_value(uc, ch, dst)) {
			va_end(args);
			return 0;
		}
		fmt_ptr++;
	}
	return 1;
}

// Parse multiple values, works like `scanf()`.
// See `ufbxi_parse_value()` for more information.
static int ufbxi_parse_values(ufbxi_context *uc, const char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	int ret = ufbxi_parse_values_va(uc, fmt, args);
	va_end(args);
	return ret;
}

// Decode the data of an multivalue array into memory. Requires the array to be
// prepared with `ufbxi_convert_multivalue_array()`.
static int ufbxi_decode_multivalue_array(ufbxi_context *uc, ufbxi_array *arr, void *dst)
{
	if (arr->encoding != UFBXI_ENCODING_MULTIVALUE) {
		return ufbxi_error(uc, "Internal: Bad multivalue encoding");
	}

	// HACK: Create a virtual node for the multivalue array and set it as
	// the current one.
	ufbxi_node focused_node = uc->focused_node;
	memset(&uc->focused_node, 0, sizeof(ufbxi_node));

	size_t arr_begin = arr->data_offset;
	size_t arr_end = arr_begin + arr->encoded_size;
	uc->focused_node.value_begin_pos = arr_begin;
	uc->focused_node.next_value_pos = arr_begin;
	uc->focused_node.child_begin_pos = arr_end;
	uc->focused_node.end_pos = arr_end;

	char dst_elem_type;
	uint32_t dst_elem_size;
	switch (arr->dst_type) {
	case 'i': dst_elem_type = 'I'; dst_elem_size = 4; break;
	case 'l': dst_elem_type = 'L'; dst_elem_size = 8; break;
	case 'f': dst_elem_type = 'F'; dst_elem_size = 4; break;
	case 'd': dst_elem_type = 'D'; dst_elem_size = 8; break;
	case 'b': dst_elem_type = 'B'; dst_elem_size = 1; break;
	}

	char *dst_ptr = (char*)dst;
	while (uc->focused_node.next_value_pos < uc->focused_node.child_begin_pos) {
		if (!ufbxi_parse_value(uc, dst_elem_type, dst_ptr)) return 0;
		dst_ptr += dst_elem_size;
	}
	if (uc->focused_node.next_value_pos != uc->focused_node.child_begin_pos) {
		return ufbxi_error(uc, "Multivalue array overrun");
	}
	if (dst_ptr != (char*)dst + arr->num_elements * dst_elem_size) {
		return ufbxi_error(uc, "Internal: Multivalue array read failed");
	}

	uc->focused_node = focused_node;
	return 1;
}

// Decode the contents of an array into memory. Performs potential type conversion
// and decoding of the data. Should not fail for a non-decoding failure reason.
static int ufbxi_decode_array(ufbxi_context *uc, ufbxi_array *arr, void *dst)
{
	uint32_t elem_size;
	switch (arr->src_type) {
	case 'i': case 'f': elem_size = 4; break;
	case 'l': case 'd': elem_size = 8; break;
	case 'b': elem_size = 1; break;
	default: return ufbxi_error(uc, "Internal: Invalid array type");
	}

	size_t arr_size = arr->num_elements * elem_size;

	if (arr->dst_type == arr->src_type) {
		const void *src = uc->data + arr->data_offset;

		// Fast path: Source is memory-compatible with destination, decode directly to
		// the destination memory.
		switch (arr->encoding) {
		case UFBXI_ENCODING_BASIC:
			if (arr->encoded_size != arr_size) {
				return ufbxi_errorf(uc, "Array size mismatch, encoded %u bytes, decoded %u bytes",
					arr->encoded_size, arr_size);
			}
			memcpy(dst, src, arr_size);
			break;
		case UFBXI_ENCODING_DEFLATE: {
			ptrdiff_t res = ufbx_inflate(dst, arr_size, src, arr->encoded_size);
			if (res != arr_size) {
				if (res < 0) {
					return ufbxi_errorf(uc, "Deflate error: %d", (int)res);
				} else {
					return ufbxi_error(uc, "Deflate size mismatch");
				}
			}
		} break;
		case UFBXI_ENCODING_MULTIVALUE:
			// Early return: Defer to multivalue implementation.
			return ufbxi_decode_multivalue_array(uc, arr, dst);
		default: return ufbxi_error(uc, "Internal: Bad array encoding");
		}
	} else {
		const char *src_ptr;
		const void *src = uc->data + arr->data_offset;

		// Slow path: Need to do conversion, allocate temporary buffer if necessary
		switch (arr->encoding) {
		case UFBXI_ENCODING_BASIC:
			if (arr->encoded_size != arr_size) {
				return ufbxi_errorf(uc, "Array size mismatch, encoded %u bytes, decoded %u bytes",
					arr->encoded_size, arr_size);
			}
			src_ptr = (const char*)src;
			break;
		case UFBXI_ENCODING_DEFLATE: {
			size_t buf_size = uc->decompress_buffer_size;
			if (buf_size < arr_size) {
				buf_size = buf_size * 2 > arr_size ? buf_size * 2 : arr_size;
				uc->decompress_buffer_size = buf_size;
				void *buf = realloc(uc->decompress_buffer, buf_size);
				if (!buf) {
					return ufbxi_errorf(uc, "Failed to allocate decompression buffer: %zu bytes", buf_size);
				}
				uc->decompress_buffer = buf;
			}
			ptrdiff_t res = ufbx_inflate(uc->decompress_buffer, arr_size, src, arr->encoded_size);
			if (res != arr_size) {
				if (res < 0) {
					return ufbxi_errorf(uc, "Deflate error: %d", (int)res);
				} else {
					return ufbxi_error(uc, "Deflate size mismatch");
				}
			}
			src_ptr = (const char*)uc->decompress_buffer;
		} break;
		case UFBXI_ENCODING_MULTIVALUE:
			// Multivalue arrays should always have `src_type == dst_type`.
			return ufbxi_error(uc, "Internal: Multivalue array has invalid type");
		default: return ufbxi_error(uc, "Internal: Bad array encoding");
		}

		const char *src_end = src_ptr + arr_size;

		// Try to perform type conversion.
		const char *sp = src_ptr, *ep = src_end;
		int failed = 0;
		if (arr->dst_type == 'i') {
			int32_t *dp = (int32_t*)dst;
			switch (arr->src_type) {
			case 'l': for (; sp!=ep; sp+=8) *dp++ = (int32_t)*(uint64_t*)sp; break;
			case 'b': for (; sp!=ep; sp+=1) *dp++ = *sp != 0 ? 1 : 0; break;
			default: failed = 1; break;
			}
		} else if (arr->dst_type == 'l') {
			int64_t *dp = (int64_t*)dst;
			switch (arr->src_type) {
			case 'i': for (; sp!=ep; sp+=4) *dp++ = *(int32_t*)sp; break;
			case 'b': for (; sp!=ep; sp+=1) *dp++ = *sp != 0 ? 1 : 0; break;
			default: failed = 1; break;
			}
		} else if (arr->dst_type == 'f') {
			float *dp = (float*)dst;
			switch (arr->src_type) {
			case 'i': for (; sp!=ep; sp+=4) *dp++ = (float)*(int32_t*)sp; break;
			case 'l': for (; sp!=ep; sp+=8) *dp++ = (float)*(int64_t*)sp; break;
			case 'd': for (; sp!=ep; sp+=8) *dp++ = (float)*(double*)sp; break;
			default: failed = 1; break;
			}
		} else if (arr->dst_type == 'd') {
			double *dp = (double*)dst;
			switch (arr->src_type) {
			case 'i': for (; sp!=ep; sp+=4) *dp++ = (double)*(int32_t*)sp; break;
			case 'l': for (; sp!=ep; sp+=8) *dp++ = (double)*(int64_t*)sp; break;
			case 'f': for (; sp!=ep; sp+=4) *dp++ = *(float*)sp; break;
			default: failed = 1; break;
			}
		} else if (arr->dst_type == 'b') {
			char *dp = (char*)dst;
			switch (arr->src_type) {
			case 'i': for (; sp!=ep; sp+=4) *dp++ = *(uint32_t*)sp != 0 ? 1 : 0; break;
			case 'l': for (; sp!=ep; sp+=8) *dp++ = *(uint64_t*)sp != 0 ? 1 : 0; break;
			default: failed = 1; break;
			}
		} else {
			return ufbxi_error(uc, "Internal: Unexpected array type");
		}

		if (failed) {
			return ufbxi_errorf(uc, "Bad array conversion: '%c' -> '%c'",
				arr->src_type, arr->dst_type);
		}
	}

	return 1;
}

static ufbxi_forceinline int ufbxi_has_next_value(ufbxi_context *uc)
{
	return uc->focused_node.next_value_pos != uc->focused_node.child_begin_pos;
}

// Enter the currently focused node. Pushes the node to stack and allows inspecting its
// children. Does not fail if the node is empty.
static int ufbxi_enter_node(ufbxi_context *uc)
{
	if (uc->node_stack_top + 1 == uc->node_stack + UFBXI_NODE_STACK_SIZE) {
		return ufbxi_error(uc, "Node stack overflow: Too many nested nodes");
	}

	ufbxi_stack_node *top = ++uc->node_stack_top;
	top->node = uc->focused_node;
	top->next_child_pos = top->node.child_begin_pos;
	top->map.mask = 0;

	return 1;
}

// Exit a node previously entered using `ufbxi_enter_node()`. Future child node
// iteration and find queries will be done to the parent node.
static void ufbxi_exit_node(ufbxi_context *uc)
{
	ufbx_assert(uc->node_stack_top != uc->node_stack);
	ufbxi_stack_node *top = uc->node_stack_top--;
	uc->focused_node = top->node;
}

// Parse the node starting from `pos` to `node`. Does not modify `node` if the
// function fails. Returns zero when parsing a NULL-record without failure.
static int ufbxi_parse_node(ufbxi_context *uc, uint64_t pos, ufbxi_node *node)
{
	uint64_t end_pos, values_len, name_pos;
	uint8_t name_len;

	if (uc->version >= 7500 || uc->from_ascii) {
		if (pos > uc->size - 25) {
			return ufbxi_error(uc, "Internal: Trying to read node out of bounds");
		}
		end_pos = ufbxi_read_u64(uc->data + pos + 0);
		values_len = ufbxi_read_u64(uc->data + pos + 16);
		name_len = ufbxi_read_u8(uc->data + pos + 24);
		name_pos = pos + 25;
	} else {
		if (pos > uc->size - 13) {
			return ufbxi_error(uc, "Internal: Trying to read node out of bounds");
		}
		end_pos = ufbxi_read_u32(uc->data + pos + 0);
		values_len = ufbxi_read_u32(uc->data + pos + 8);
		name_len = ufbxi_read_u8(uc->data + pos + 12);
		name_pos = pos + 13;
	}

	if (end_pos == 0) {
		// NULL-record: Return without failure
		return 0;
	} else if (end_pos < pos + 13) {
		return ufbxi_error(uc, "Node end offset is too low");
	}

	uint64_t value_pos = name_pos + name_len;
	uint64_t child_pos = value_pos + values_len;

	// Check for integer overflow and out-of-bounds at the same time. `name_pos`
	// cannot overflow due to the precondition check.
	if (value_pos < name_pos || value_pos > uc->size) {
		return ufbxi_error(uc, "Node name out of bounds");
	}
	if (child_pos < value_pos || child_pos > uc->size) {
		return ufbxi_error(uc, "Node values out of bounds");
	}
	if (end_pos < child_pos || end_pos > uc->size) {
		return ufbxi_error(uc, "Node children out of bounds");
	}

	if (value_pos > (uint64_t)SIZE_MAX || child_pos > (uint64_t)SIZE_MAX
		|| end_pos > (uint64_t)SIZE_MAX) {
		return ufbxi_error(uc, "The file requires 64-bit build");
	}

	node->name.data = uc->data + name_pos;
	node->name.length = name_len;
	node->value_begin_pos = (size_t)value_pos;
	node->next_value_pos = (size_t)value_pos;
	node->child_begin_pos = (size_t)child_pos;
	node->end_pos = (size_t)end_pos;
	return 1;
}

// Find the starting offset of the next node.
// Returns zero when parsing a NULL-record without failure.
static ufbxi_forceinline int ufbxi_next_node_pos(ufbxi_context *uc, uint64_t pos, uint64_t *p_next_pos)
{
	uint64_t end_pos;
	if (uc->version >= 7500 || uc->from_ascii) {
		if (pos > uc->size - 25) {
			return ufbxi_error(uc, "Internal: Trying to read node out of bounds");
		}
		end_pos = ufbxi_read_u64(uc->data + pos + 0);
	} else {
		if (pos > uc->size - 13) {
			return ufbxi_error(uc, "Internal: Trying to read node out of bounds");
		}
		end_pos = ufbxi_read_u32(uc->data + pos + 0);
	}

	if (end_pos == 0) {
		// NULL-record: Return without failure
		return 0;
	} else if (end_pos < pos + 13) {
		return ufbxi_error(uc, "Node end offset is too low");
	}

	*p_next_pos = end_pos;
	return 1;
}

// Move the focus to the next child of the currently entered node.
static int ufbxi_next_child(ufbxi_context *uc, ufbx_string *name)
{
	ufbxi_stack_node *top = uc->node_stack_top;
	uint64_t pos = top->next_child_pos;
	if (pos == top->node.end_pos) return 0;

	// Parse the node to be focused. If we encounter a NULL-record here
	// it will be reported as not having found the next child without error.
	if (!ufbxi_parse_node(uc, pos, &uc->focused_node)) return 0;

	top->next_child_pos = uc->focused_node.end_pos;
	if (name) *name = uc->focused_node.name;
	return 1;
}

static int ufbxi_build_map(ufbxi_context *uc)
{
	// Collect all the offsets of the topmost entered node
	ufbxi_stack_node *top = uc->node_stack_top;
	ufbxi_child_map *map = &top->map;

	uint64_t pos = top->node.child_begin_pos;
	if (pos == top->node.end_pos) {
		// No children -> no map -> fail to find without error
		return 0;
	}

	size_t num = 0;

	// Follow linked list
	uint64_t next_pos;
	while (ufbxi_next_node_pos(uc, pos, &next_pos)) {
		if (num >= map->capacity) {
			// Re-allocate map buffers if necessary
			size_t cap = map->capacity * 2;
			if (cap == 0) cap = 16;
			size_t offset_size = cap * sizeof(uint64_t);
			size_t entry_size = cap * 4 * sizeof(ufbxi_map_entry);
			size_t size = offset_size + entry_size;
			void *mem = malloc(offset_size + entry_size);
			if (!mem) {
				return ufbxi_errorf(uc, "Failed to allocate memory: %zu bytes", size);
			}
			uint64_t *offsets = (uint64_t*)mem;
			ufbxi_map_entry *entries = (ufbxi_map_entry*)(offsets + cap);
			memcpy(offsets, map->offsets, num * sizeof(uint64_t));
			free(map->offsets);
			map->offsets = offsets;
			map->entries = entries;
			map->capacity = cap;
		}

		map->offsets[num] = pos;
		pos = next_pos;
		num++;
	}

	// Propagate failure from ufbxi_parse_node()
	if (uc->failed) return 0;

	// Find the lowest power of two map size that's large enough
	size_t map_size = 1;
	while (map_size < num * 2) {
		map_size *= 2;
	}
	size_t mask = map_size - 1;
	map->mask = mask;

	// Clear the map
	memset(map->entries, 0, sizeof(ufbxi_map_entry) * map_size);

	// Insert entries to the map
	ufbxi_node node;
	for (size_t index = 0; index < num; index++) {
		uint64_t offset = map->offsets[index];
		int res = ufbxi_parse_node(uc, offset, &node);
		if (!res) return 0;

		uint32_t hash = ufbxi_hash_string(node.name);
		for (size_t entry_ix = hash; ; entry_ix++) {
			ufbxi_map_entry *entry = &map->entries[entry_ix & mask];
			if (entry->hash == 0) {
				entry->hash = hash;
				entry->index = (uint32_t)index;
				break;
			}
		}
	}

	return 1;
}

// Move the focus to the first node matching a name in the currently entered node.
// Does not affect iteration with `ufbxi_next_child()`
static int ufbxi_find_node_str(ufbxi_context *uc, ufbx_string str)
{
	ufbxi_stack_node *top = uc->node_stack_top;
	if (top->map.mask == 0) {
		if (!ufbxi_build_map(uc)) return 0;
	}

	ufbxi_node node;
	size_t mask = top->map.mask;
	uint32_t hash = ufbxi_hash_string(str);
	for (size_t entry_ix = hash; ; entry_ix++) {
		ufbxi_map_entry *entry = &top->map.entries[entry_ix & mask];
		if (entry->hash == hash) {
			uint64_t offset = top->map.offsets[entry->index];
			int res = ufbxi_parse_node(uc, offset, &node);
			ufbx_assert(res == 1); // The node has been parsed already!
			// TODO: Case insensitive?
			if (ufbxi_streq_str(node.name, str)) {
				uc->focused_node = node;
				return 1;
			}
		} else if (entry->hash == 0) {
			return 0;
		}
	}
}

// Convenient shorthands for the above functions.

static ufbxi_forceinline int
ufbxi_find_node(ufbxi_context *uc, const char *name)
{
	ufbx_string str = { name, strlen(name) };
	return ufbxi_find_node_str(uc, str);
}

static ufbxi_forceinline int
ufbxi_find_value_str(ufbxi_context *uc, ufbx_string str, char dst_type, void *dst)
{
	if (!ufbxi_find_node_str(uc, str)) return 0;
	return ufbxi_parse_value(uc, dst_type, dst);
}

static ufbxi_forceinline int
ufbxi_find_value(ufbxi_context *uc, const char *name, char dst_type, void *dst)
{
	ufbx_string str = { name, strlen(name) };
	if (!ufbxi_find_node_str(uc, str)) return 0;
	return ufbxi_parse_value(uc, dst_type, dst);
}

static ufbxi_forceinline int
ufbxi_find_values_str(ufbxi_context *uc, ufbx_string str, const char *fmt, ...)
{
	if (!ufbxi_find_node_str(uc, str)) return 0;
	va_list args;
	va_start(args, fmt);
	int ret = ufbxi_parse_values_va(uc, fmt, args);
	va_end(args);
	return ret;
}

static ufbxi_forceinline int
ufbxi_find_values(ufbxi_context *uc, const char *name, const char *fmt, ...)
{
	ufbx_string str = { name, strlen(name) };
	if (!ufbxi_find_node_str(uc, str)) return 0;
	va_list args;
	va_start(args, fmt);
	int ret = ufbxi_parse_values_va(uc, fmt, args);
	va_end(args);
	return ret;
}

static ufbxi_forceinline int
ufbxi_find_enter_str(ufbxi_context *uc, ufbx_string str)
{
	if (ufbxi_find_node_str(uc, str)) {
		return ufbxi_enter_node(uc);
	} else {
		return 0;
	}
}

static ufbxi_forceinline int
ufbxi_find_enter(ufbxi_context *uc, const char *name)
{
	ufbx_string str = { name, strlen(name) };
	if (ufbxi_find_node_str(uc, str)) {
		return ufbxi_enter_node(uc);
	} else {
		return 0;
	}
}

// ASCII format parsing

#define UFBXI_ASCII_END '\0'
#define UFBXI_ASCII_NAME 'N'
#define UFBXI_ASCII_BARE_WORD 'B'
#define UFBXI_ASCII_INT 'I'
#define UFBXI_ASCII_FLOAT 'F'
#define UFBXI_ASCII_STRING 'S'

#define UFBXI_ASCII_MAX_STACK_SIZE 64

typedef struct {
	ufbx_string str;
	char type;
	union {
		double f64;
		int64_t i64;
		uint32_t name_len;
	} value;
} ufbxi_ascii_token;

typedef struct {
	const char *src;
	const char *src_end;

	char *dst;
	size_t dst_pos;
	size_t dst_size;

	ufbxi_ascii_token prev_token;
	ufbxi_ascii_token token;

	ufbx_string node_stack[UFBXI_ASCII_MAX_STACK_SIZE];
	uint32_t node_stack_size;

	uint32_t version;

	int failed;
	ufbx_error *error;
} ufbxi_ascii;

static int ufbxi_ascii_do_error(ufbxi_ascii *ua, uint32_t line, const char *desc)
{
	if (ua->failed) return 0;
	ua->failed = 1;
	ufbx_error *err = ua->error;
	if (err) {
		err->source_line = line;
		size_t length = strlen(desc);
		if (length > UFBX_ERROR_DESC_MAX_LENGTH) length = UFBX_ERROR_DESC_MAX_LENGTH;
		memcpy(err->desc, desc, length);
		err->desc[length] = '\0';
		uint32_t ix = 0;
		for (; ix < ua->node_stack_size && ix < UFBX_ERROR_STACK_MAX_DEPTH; ix++) {
			size_t len = ua->node_stack[ix].length;
			if (len > UFBX_ERROR_STACK_NAME_MAX_LENGTH) {
				len = UFBX_ERROR_STACK_NAME_MAX_LENGTH;
			}
			memcpy(err->stack[ix], ua->node_stack[ix].data, len);
			err->stack[ix][len] = '\0';
		}
		err->stack_size = ix;
	}
	return 0;
}

#define ufbxi_ascii_error(ua, desc) ufbxi_ascii_do_error((ua), __LINE__, (desc))

static char ufbxi_ascii_peek(ufbxi_ascii *ua)
{
	return ua->src != ua->src_end ? *ua->src : '\0';
}

static char ufbxi_ascii_next(ufbxi_ascii *ua)
{
	if (ua->src != ua->src_end) ua->src++;
	return ua->src != ua->src_end ? *ua->src : '\0';
}

static char ufbxi_ascii_skip_whitespace(ufbxi_ascii *ua)
{
	// Ignore whitespace
	char c = ufbxi_ascii_peek(ua);
	for (;;) {
		while (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
			c = ufbxi_ascii_next(ua);
		}
		if (c == ';') {
			c = ufbxi_ascii_next(ua);
			while (c != '\n' && c != '\0') {
				c = ufbxi_ascii_next(ua);
			}
		} else {
			break;
		}
	}
	return c;
}

static int ufbxi_ascii_next_token(ufbxi_ascii *ua, ufbxi_ascii_token *token)
{
	char c = ufbxi_ascii_skip_whitespace(ua);
	token->str.data = ua->src;

	if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '_') {
		token->type = UFBXI_ASCII_BARE_WORD;
		uint32_t len = 0;
		while ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')
			|| (c >= '0' && c <= '9') || c == '_') {
			len++;
			c = ufbxi_ascii_next(ua);
		}

		// Skip whitespace to find if there's a following ':'
		c = ufbxi_ascii_skip_whitespace(ua);
		if (c == ':') {
			token->value.name_len = len;
			token->type = UFBXI_ASCII_NAME;
			ufbxi_ascii_next(ua);
		}
	} else if ((c >= '0' && c <= '9') || c == '-' || c == '+' || c == '.') {
		token->type = UFBXI_ASCII_INT;

		char buf[128];
		uint32_t len = 0;
		while ((c >= '0' && c <= '9') || c == '-' || c == '+' || c == '.' || c == 'e' || c == 'E') {
			if (c == '.' || c == 'e' || c == 'E') {
				token->type = UFBXI_ASCII_FLOAT;
			}
			if (len == sizeof(buf) - 1) {
				return ufbxi_ascii_error(ua, "Number is too long");
			}
			buf[len++] = c;
			c = ufbxi_ascii_next(ua);
		}
		buf[len] = '\0';

		char *end;
		if (token->type == UFBXI_ASCII_INT) {
			token->value.i64 = strtoll(buf, &end, 10);
			if (end != buf + len) {
				return ufbxi_ascii_error(ua, "Bad integer constant");
			}
		} else if (token->type == UFBXI_ASCII_FLOAT) {
			token->value.f64 = strtod(buf, &end);
			if (end != buf + len) {
				return ufbxi_ascii_error(ua, "Bad float constant");
			}
		}
	} else if (c == '"') {
		token->type = UFBXI_ASCII_STRING;
		c = ufbxi_ascii_next(ua);
		while (c != '"') {
			c = ufbxi_ascii_next(ua);
			if (c == '\0') {
				return ufbxi_ascii_error(ua, "Unclosed string");
			}
		}
		// Skip closing quote
		ufbxi_ascii_next(ua);
	} else {
		token->type = c;
		ufbxi_ascii_next(ua);
	}

	token->str.length = ua->src - token->str.data;
	return 1;
}

static int ufbxi_ascii_accept(ufbxi_ascii *ua, char type)
{
	if (ua->token.type == type) {
		ua->prev_token = ua->token;
		if (!ufbxi_ascii_next_token(ua, &ua->token)) return 0;
		return 1;
	} else {
		return 0;
	}
}

static size_t ufbxi_ascii_push_output(ufbxi_ascii *ua, size_t size)
{
	if (ua->dst_size - ua->dst_pos < size) {
		size_t new_size = 2 * ua->dst_size;
		if (new_size < 1024) new_size = 1024;
		if (new_size < size) new_size = size;
		char *new_dst = (char*)realloc(ua->dst, new_size);
		if (!new_dst) {
			ufbxi_ascii_error(ua, "Out of memory");
			return ~0u;
		}
		ua->dst = new_dst;
		ua->dst_size = new_size;
	}
	size_t pos = ua->dst_pos;
	ua->dst_pos += size;
	return pos;
}

static int ufbxi_ascii_parse_node(ufbxi_ascii *ua)
{
	if (ua->node_stack_size >= UFBXI_ASCII_MAX_STACK_SIZE) {
		return ufbxi_ascii_error(ua, "Too many nested nodes");
	}

	if (!ufbxi_ascii_accept(ua, UFBXI_ASCII_NAME)) {
		return ufbxi_ascii_error(ua, "Expected node name");
	}

	uint32_t name_len = ua->prev_token.value.name_len;
	if (name_len > 0xff) {
		return ufbxi_ascii_error(ua, "Node name is too long");
	}

	ua->node_stack[ua->node_stack_size].data = ua->prev_token.str.data;
	ua->node_stack[ua->node_stack_size].length = name_len;
	ua->node_stack_size++;

	size_t node_pos = ufbxi_ascii_push_output(ua, 25 + name_len);
	if (node_pos == ~0u) return 0;
	ufbxi_write_u8(ua->dst + node_pos + 24, name_len);
	memcpy(ua->dst + node_pos + 25, ua->prev_token.str.data, name_len);

	size_t value_begin_pos = ua->dst_pos;

	int in_array = 0;
	size_t num_values = 0;

	// NOTE: Infinite loop to allow skipping the comma parsing via `continue`.
	for (;;) {
		ufbxi_ascii_token *tok = &ua->prev_token;
		if (ufbxi_ascii_accept(ua, UFBXI_ASCII_STRING)) {
			// The ASCII format supports escaping quotes via "&quot;". There seems
			// to be no way to escape "&quot;" itself. Exporting and importing converts
			// strings with "&quot;" to "\"". Append worst-case data and rewind the
			// write position in case we find "&quot;" escapes.
			size_t string_len = tok->str.length - 2;
			size_t pos = ufbxi_ascii_push_output(ua, 5 + string_len);
			if (pos == ~0u) return 0;
			char *dst = ua->dst + pos + 5;
			size_t bytes_escaped = 0;
			for (size_t i = 0; i < string_len; i++) {
				char c = tok->str.data[1 + i];
				if (c == '&' && i + 6 <= string_len) {
					if (!memcmp(tok->str.data + 1 + i, "&quot;", 6)) {
						bytes_escaped += 5;
						i += 5;
						c = '\"';
					}
				}
				*dst++ = c;
			}

			ua->dst_pos -= bytes_escaped;
			string_len -= bytes_escaped;
			ua->dst[pos + 0] = 'S';
			ufbxi_write_u32(ua->dst + pos + 1, string_len);

		} else if (ufbxi_ascii_accept(ua, UFBXI_ASCII_INT)) {
			int64_t val = tok->value.i64;
			if (val >= INT16_MIN && val <= INT16_MAX) {
				size_t pos = ufbxi_ascii_push_output(ua, 3);
				if (pos == ~0u) return 0;
				ua->dst[pos] = 'Y';
				ufbxi_write_i16(ua->dst + pos + 1, val);
			} else if (val >= INT32_MIN && val <= INT32_MAX) {
				size_t pos = ufbxi_ascii_push_output(ua, 5);
				if (pos == ~0u) return 0;
				ua->dst[pos] = 'I';
				ufbxi_write_i32(ua->dst + pos + 1, val);
			} else {
				size_t pos = ufbxi_ascii_push_output(ua, 9);
				if (pos == ~0u) return 0;
				ua->dst[pos] = 'L';
				ufbxi_write_i64(ua->dst + pos + 1, val);
			}

			// Try to guesstimate the FBX version
			if (!ua->version
				&& ua->node_stack_size == 2
				&& val > 0 && val < INT32_MAX
				&& ufbxi_streq(ua->node_stack[0], "FBXHeaderExtension")
				&& ufbxi_streq(ua->node_stack[1], "FBXVersion")) {
				ua->version = (uint32_t)val;
			}

		} else if (ufbxi_ascii_accept(ua, UFBXI_ASCII_FLOAT)) {
			double val = tok->value.f64;
			if ((double)(float)val == val) {
				size_t pos = ufbxi_ascii_push_output(ua, 5);
				if (pos == ~0u) return 0;
				ua->dst[pos] = 'F';
				ufbxi_write_f32(ua->dst + pos + 1, val);
			} else {
				size_t pos = ufbxi_ascii_push_output(ua, 9);
				if (pos == ~0u) return 0;
				ua->dst[pos] = 'D';
				ufbxi_write_f64(ua->dst + pos + 1, val);
			}

		} else if (ufbxi_ascii_accept(ua, UFBXI_ASCII_BARE_WORD)) {
			if (ufbxi_streq(tok->str, "Y") || ufbxi_streq(tok->str, "T")) {
				size_t pos = ufbxi_ascii_push_output(ua, 2);
				if (pos == ~0u) return 0;
				ua->dst[pos] = 'C';
				ua->dst[pos + 1] = 1;
			} else if (ufbxi_streq(tok->str, "N") || ufbxi_streq(tok->str, "F")) {
				size_t pos = ufbxi_ascii_push_output(ua, 2);
				if (pos == ~0u) return 0;
				ua->dst[pos] = 'C';
				ua->dst[pos + 1] = 0;
			}

		} else if (ufbxi_ascii_accept(ua, '*')) {
			if (in_array) {
				return ufbxi_ascii_error(ua, "Nested array values");
			}
			if (!ufbxi_ascii_accept(ua, UFBXI_ASCII_INT)) {
				return ufbxi_ascii_error(ua, "Expected array size");
			}
			if (ufbxi_ascii_accept(ua, '{')) {
				if (!ufbxi_ascii_accept(ua, UFBXI_ASCII_NAME)) {
					return ufbxi_ascii_error(ua, "Expected array content name");
				}

				// NOTE: This `continue` skips incrementing `num_values` and parsing
				// a comma, continuing to parse the values in the array.
				in_array = 1;
				continue;
			}
		} else {
			break;
		}

		// Add value and keep parsing if there's a comma. This part may be
		// skipped if we enter an array block.
		num_values++;
		if (!ufbxi_ascii_accept(ua, ',')) break;
	}

	if (in_array) {
		if (!ufbxi_ascii_accept(ua, '}')) {
			return ufbxi_ascii_error(ua, "Unclosed value array");
		}
	}

	size_t value_end_pos = ua->dst_pos;

	if (ufbxi_ascii_accept(ua, '{')) {
		while (!ufbxi_ascii_accept(ua, '}')) {
			if (ua->failed) return 0;
			ufbxi_ascii_parse_node(ua);
		}

		size_t null_pos = ufbxi_ascii_push_output(ua, 25);
		if (null_pos == ~0u) return 0;
		memset(ua->dst + null_pos, 0, 25);
	}

	size_t child_end_pos = ua->dst_pos;
	ufbxi_write_u64(ua->dst + node_pos + 0, child_end_pos);
	ufbxi_write_u64(ua->dst + node_pos + 8, num_values);
	ufbxi_write_u64(ua->dst + node_pos + 16, value_end_pos - value_begin_pos);

	ua->node_stack_size--;
	return !ua->failed;
}

#define UFBXI_BINARY_MAGIC_SIZE 23
static const char ufbxi_binary_magic[] = "Kaydara FBX Binary  \x00\x1a\x00";

static int ufbxi_ascii_parse(ufbxi_ascii *ua)
{
	size_t magic_pos = ufbxi_ascii_push_output(ua, UFBXI_BINARY_MAGIC_SIZE + 4);

	ufbxi_ascii_next_token(ua, &ua->token);
	while (!ufbxi_ascii_accept(ua, UFBXI_ASCII_END)) {
		if (ua->failed) return 0;
		if (!ufbxi_ascii_parse_node(ua)) return 0;
	}
	size_t null_pos = ufbxi_ascii_push_output(ua, 25);
	if (null_pos == ~0u) return 0;
	memset(ua->dst + null_pos, 0, 25);

	size_t version = ua->version ? ua->version : 7500;
	memcpy(ua->dst + magic_pos, ufbxi_binary_magic, UFBXI_BINARY_MAGIC_SIZE);
	ufbxi_write_u32(ua->dst + UFBXI_BINARY_MAGIC_SIZE, version);

	return 1;
}

// -- Parser

typedef struct {
	uint32_t hash;
	ufbx_string name;
	ufbx_property_type type;
} ufbxi_prop_type_map_entry;

typedef struct {
	uint32_t hash;
	ufbx_string name;
	ufbx_property_type type;
} ufbxi_node_type_map_entry;

// Generated by `misc/enum_type_perfect_hash.py`
#define ufbxi_prop_type_permute_hash(h) ((((h) * 51) >> 8) % 32)
static const ufbxi_prop_type_map_entry ufbxi_prop_type_map[32] = {
	{ 0xffcc7052u, { "Lcl Rotation", 12 }, UFBX_PROP_ROTATION },
	{ 0u, { 0,0 }, UFBX_PROP_UNKNOWN },
	{ 0u, { 0,0 }, UFBX_PROP_UNKNOWN },
	{ 0u, { 0,0 }, UFBX_PROP_UNKNOWN },
	{ 0x61e9eac0u, { "Number", 6 }, UFBX_PROP_NUMBER },
	{ 0xe5b43cf8u, { "Color", 5 }, UFBX_PROP_COLOR },
	{ 0u, { 0,0 }, UFBX_PROP_UNKNOWN },
	{ 0u, { 0,0 }, UFBX_PROP_UNKNOWN },
	{ 0u, { 0,0 }, UFBX_PROP_UNKNOWN },
	{ 0x604f4858u, { "String", 6 }, UFBX_PROP_STRING },
	{ 0u, { 0,0 }, UFBX_PROP_UNKNOWN },
	{ 0xec95435fu, { "Boolean", 7 }, UFBX_PROP_BOOLEAN },
	{ 0x95e97e5eu, { "int", 3 }, UFBX_PROP_INTEGER },
	{ 0x84006183u, { "KString", 7 }, UFBX_PROP_STRING },
	{ 0u, { 0,0 }, UFBX_PROP_UNKNOWN },
	{ 0x53b2b785u, { "Vector3D", 8 }, UFBX_PROP_VECTOR },
	{ 0x816cb000u, { "enum", 4 }, UFBX_PROP_INTEGER },
	{ 0x519a291fu, { "Lcl Translation", 15 }, UFBX_PROP_TRANSLATION },
	{ 0u, { 0,0 }, UFBX_PROP_UNKNOWN },
	{ 0u, { 0,0 }, UFBX_PROP_UNKNOWN },
	{ 0u, { 0,0 }, UFBX_PROP_UNKNOWN },
	{ 0u, { 0,0 }, UFBX_PROP_UNKNOWN },
	{ 0xd9a953e5u, { "Integer", 7 }, UFBX_PROP_INTEGER },
	{ 0x679a6399u, { "Lcl Scaling", 11 }, UFBX_PROP_SCALING },
	{ 0x9bec7490u, { "DateTime", 8 }, UFBX_PROP_DATE_TIME },
	{ 0u, { 0,0 }, UFBX_PROP_UNKNOWN },
	{ 0u, { 0,0 }, UFBX_PROP_UNKNOWN },
	{ 0xc894953du, { "bool", 4 }, UFBX_PROP_BOOLEAN },
	{ 0u, { 0,0 }, UFBX_PROP_UNKNOWN },
	{ 0xbc50ad22u, { "Vector", 6 }, UFBX_PROP_VECTOR },
	{ 0xa0eb0f08u, { "double", 6 }, UFBX_PROP_NUMBER },
	{ 0xff873b9bu, { "ColorRGB", 8 }, UFBX_PROP_COLOR },
};
#define ufbxi_node_type_permute_hash(h) ((((h) * 3) >> 2) % 8)
static const ufbxi_node_type_map_entry ufbxi_node_type_map[8] = {
	{ 0xcbd54f80u, { "Material", 8 }, UFBX_NODE_MATERIAL },
	{ 0x5431f217u, { "NodeAttribute", 13 }, UFBX_NODE_ATTRIBUTE },
	{ 0x7f64b258u, { "AnimationCurveNode", 18 }, UFBX_NODE_ANIMATION },
	{ 0x8285e8fau, { "Model", 5 }, UFBX_NODE_MODEL },
	{ 0x243eddb1u, { "Geometry", 8 }, UFBX_NODE_MESH },
	{ 0xdbe5783cu, { "AnimationCurve", 14 }, UFBX_NODE_ANIMATION_CURVE },
	{ 0xdafc83beu, { "AnimationLayer", 14 }, UFBX_NODE_ANIMATION_LAYER },
	{ 0x994c5594u, { "Texture", 7 }, UFBX_NODE_TEXTURE },
};
// End of generated code

// Resolve an FBX property type name into a enum
static ufbx_property_type ufbxi_get_prop_type(ufbx_string name)
{
	uint32_t hash = ufbxi_hash_string(name);
	uint32_t index = ufbxi_prop_type_permute_hash(hash);
	const ufbxi_prop_type_map_entry *entry = &ufbxi_prop_type_map[index];
	if (hash == entry->hash && ufbxi_streq_str(name, entry->name)) {
		return entry->type;
	} else {
		return UFBX_PROP_UNKNOWN;
	}
}

// Resolve an FBX node type name into a enum
static ufbx_node_type ufbxi_get_node_type(ufbx_string name)
{
	uint32_t hash = ufbxi_hash_string(name);
	uint32_t index = ufbxi_node_type_permute_hash(hash);
	const ufbxi_node_type_map_entry *entry = &ufbxi_node_type_map[index];
	if (hash == entry->hash && ufbxi_streq_str(name, entry->name)) {
		return entry->type;
	} else {
		return UFBX_NODE_UNKNOWN;
	}
}

static int ufbxi_read_property(ufbxi_context *uc, ufbx_property *prop, int version)
{
	if (!ufbxi_parse_value(uc, 'S', &prop->name)) return 0;
	if (!ufbxi_parse_value(uc, 'S', &prop->type_str)) return 0;
	if (version == 70) {
		if (!ufbxi_parse_value(uc, 'S', &prop->subtype_str)) return 0;
	} else {
		prop->subtype_str.data = "";
		prop->subtype_str.length = 0;
	}
	if (!ufbxi_parse_value(uc, 'S', &prop->flags)) return 0;

	prop->name = ufbxi_push_string(uc, prop->name);
	prop->type_str = ufbxi_push_string(uc, prop->type_str);
	prop->subtype_str = ufbxi_push_string(uc, prop->subtype_str);
	prop->flags = ufbxi_push_string(uc, prop->flags);

	prop->type = ufbxi_get_prop_type(prop->type_str);
	if (prop->type == UFBX_PROP_UNKNOWN) {
		prop->type = ufbxi_get_prop_type(prop->subtype_str);
	}

	memset(&prop->value_str, 0, sizeof(prop->value_str));
	memset(prop->value_int, 0, sizeof(prop->value_int));
	memset(prop->value_float, 0, sizeof(prop->value_float));

	for (size_t i = 0; i < 4; i++) {
		if (!ufbxi_has_next_value(uc)) break;

		ufbxi_any_value val;
		if (!ufbxi_parse_value(uc, '?', &val)) return 0;

		if (val.value_class == UFBXI_VAL_INT) {
			prop->value_int[i] = val.value.i;
			prop->value_float[i] = (double)val.value.i;
		} else if (val.value_class == UFBXI_VAL_FLOAT) {
			prop->value_int[i] = (int64_t)val.value.f;
			prop->value_float[i] = val.value.f;
		} else if (val.value_class == UFBXI_VAL_STRING) {
			if (prop->value_str.data) {
				return ufbxi_error(uc, "Multiple strings in property");
			}
			prop->value_str = ufbxi_push_string(uc, val.value.str);
		} else {
			return ufbxi_errorf(uc, "Bad property value type: '%c'", val.type_code);
		}
	}

	return 1;
}

static int ufbxi_read_properties(ufbxi_context *uc, ufbx_property **p_props, size_t *p_num)
{
	int version = 0;
	if (ufbxi_find_enter(uc, "Properties70")) {
		version = 70;
	} else if (ufbxi_find_enter(uc, "Properties60")) {
		version = 60;
	} else {
		return 1;
	}

	size_t num = 0;
	while (ufbxi_next_child(uc, NULL)) {
		ufbx_property *prop = ufbxi_temp_push_uninit(uc, 0, ufbx_property);
		if (!prop) return 0;
		if (!ufbxi_read_property(uc, prop, version)) return 0;
		num++;
	}

	*p_props = ufbxi_temp_retain_n(uc, 0, ufbx_property, num);
	*p_num = num;

	ufbxi_exit_node(uc);
	return 1;
}

static int ufbxi_read_definitions(ufbxi_context *uc)
{
	ufbx_string name;

	size_t num = 0;
	while (ufbxi_next_child(uc, &name)) {
		if (ufbxi_streq(name, "ObjectType")) {
			if (!ufbxi_enter_node(uc)) return 0;

			ufbx_node *node = ufbxi_temp_push_zero(uc, 0, ufbx_node);
			if (!node) return 0;
			num++;

			if (ufbxi_find_enter(uc, "PropertyTemplate")) {
				if (!ufbxi_read_properties(uc, &node->properties, &node->num_properties)) return 0;
				ufbxi_exit_node(uc);
			}

			ufbxi_exit_node(uc);
		}
	}
	if (uc->failed) return 0;

	ufbx_node *nodes = ufbxi_temp_retain_n(uc, 0, ufbx_node, num);
	if (!nodes) return 0;

	return 1;
}

static int ufbxi_read_objects(ufbxi_context *uc)
{
	ufbx_string node_name;

	size_t num = 0;
	while (ufbxi_next_child(uc, &node_name)) {
		uint64_t id = 0;
		ufbx_string name, type, sub_type;
		if (uc->version >= 7000) {
			if (!ufbxi_parse_value(uc, 'L', &id)) return 0;
		}
		if (ufbxi_has_next_value(uc)) {
			ufbx_string type_and_name;
			if (!ufbxi_parse_values(uc, "SS", &type_and_name, &sub_type)) return 0;

			// Name and type are packed in a single property as Type::Name (in ascii)
			// or Type\x01\x02Name (in binary)
			const char *sep = uc->from_ascii ? "::" : "\x01\x02";
			size_t type_end;
			for (type_end = 0; type_end + 2 <= type_and_name.length; type_end++) {
				const char *ch = type_and_name.data + type_end;
				if (ch[0] == sep[0] && ch[1] == sep[1]) break;
			}

			type.data = type_and_name.data;
			type.length = type_end;
			if (type_end < type_and_name.length) {
				name.data = type_and_name.data + (type_end + 2);
				name.length = type_and_name.length - (type_end + 2);
			}
		} else {
			name.length = 0;
			type.length = 0;
			sub_type.length = 0;
		}

		if (!ufbxi_enter_node(uc)) return 0;

		ufbx_property *properties;
		size_t num_properties;
		ufbxi_read_properties(uc, &properties, &num_properties);

		ufbxi_exit_node(uc);
	}
	if (uc->failed) return 0;

	return 1;
}

static int ufbxi_read_root(ufbxi_context *uc)
{
	// Parse root node
	const uint64_t root_pos = 27;
	ufbxi_node root;

	// Parse the root node if it exists
	if (ufbxi_parse_node(uc, root_pos, &root) && root.name.length == 0) {
		uc->focused_node = root;
	} else {
		uc->focused_node.child_begin_pos = 27;
		uc->focused_node.next_value_pos = 27;
		uc->focused_node.end_pos = uc->size;
	}

	uc->node_stack[0].node = uc->focused_node;
	uc->node_stack[0].next_child_pos = uc->focused_node.child_begin_pos;
	uc->node_stack_top = uc->node_stack;

	// Read the header
	if (ufbxi_find_enter(uc, "FBXHeaderExtension")) {
		ufbx_string creator;
		if (ufbxi_find_value(uc, "Creator", 'S', &creator)) {
			uc->scene->metadata.creator = ufbxi_push_string(uc, creator);
		}

		ufbxi_exit_node(uc);
	}

	// Read definitions
	if (ufbxi_find_enter(uc, "Definitions")) {
		if (!ufbxi_read_definitions(uc)) return 0;
		ufbxi_exit_node(uc);
	}

	// Read objects
	if (ufbxi_find_enter(uc, "Objects")) {
		if (!ufbxi_read_objects(uc)) return 0;
		ufbxi_exit_node(uc);
	}

	return 1;
}

// -- API

ufbx_scene *ufbx_load_memory(const void *data, size_t size, ufbx_error *error)
{
	void *data_to_free = NULL;
	ufbxi_context uc = { (const char*)data, size };
	uc.error = error;

	if (size < UFBXI_BINARY_MAGIC_SIZE + 2
		|| memcmp(data, ufbxi_binary_magic, UFBXI_BINARY_MAGIC_SIZE)) {
		// Parse as ASCII
		if (size == 0) {
			ufbxi_error(&uc, "Empty file");
			return NULL;
		}

		const char *src = (const char*)data;
		ufbxi_ascii ua = { src, src + size };
		ua.error = error;

		if (!ufbxi_ascii_parse(&ua)) {
			free(ua.dst);
			return NULL;
		}

		uc.data = ua.dst;
		uc.size = ua.dst_pos;
		uc.from_ascii = 1;
		uc.version = ua.version;
		data_to_free = ua.dst;
	} else {
		uc.version = ufbxi_read_u32((const char*)data + 23);
	}

	ufbx_scene *result = NULL;
	uc.scene_imp = ufbxi_push_zero(&uc, ufbxi_scene_imp);
	if (uc.scene_imp) {
		uc.scene = &uc.scene_imp->scene;
		uc.scene->metadata.ascii = uc.from_ascii;
		uc.scene->metadata.version = uc.version;
		if (ufbxi_read_root(&uc)) {
			if (!uc.failed) {
				result = uc.scene;
			}
		}
	}

	// Free temporary memory
	free(data_to_free);
	free(uc.decompress_buffer);
	for (uint32_t si = 0; si < UFBXI_MAX_TEMP_STACKS; si++) {
		ufbxi_temp_stack *stack = &uc.temp_stacks[si];
		ufbx_assert(stack->page_index == 0);
		for (uint32_t i = 0; i < UFBXI_MAX_TEMP_STACK_PAGES; i++) {
			ufbx_assert(stack->pages[i].offset == 0);
			if (stack->pages[i].data) free(stack->pages[i].data);
		}
	}
	if (!result) {
		ufbxi_free_result(uc.result_data);
	}

	return result;
}

void ufbx_free_scene(ufbx_scene *scene)
{
	ufbxi_scene_imp *imp = (ufbxi_scene_imp*)scene;
	ufbxi_free_result(imp->memory);
}

#ifdef __cplusplus
}
#endif

#endif
