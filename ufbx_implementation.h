#ifndef UFBX_UFBX_H_IMPLEMENTED
#define UFBX_UFBX_H_IMPLEMENTED

#include "ufbx.h"
#include <stdarg.h>
#include <stdint.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// -- Platform

#if defined(_MSC_VER)
	#define ufbxi_noinline __declspec(noinline)
	#define ufbxi_forceinline __forceinline
#elif defined(__GNUC__) || defined(__clang__)
	#define ufbxi_noinline __attribute__((noinline))
	#define ufbxi_forceinline inline __attribute__((always_inline))
#else
	#define ufbxi_noinline
	#define ufbxi_forceinline
#endif

#define ufbxi_arraycount(arr) (sizeof(arr) / sizeof(*(arr)))

// -- Debugging

#if !defined(ufbx_assert)
	#define ufbx_assert(cond) (void)0
#endif

// -- Utility

typedef struct {
	const char *data;
	size_t length;
} ufbxi_string;

static ufbxi_forceinline int
ufbxi_streq(ufbxi_string str, const char *ref)
{
	size_t length = strlen(ref);
	return str.length == length && !memcmp(str.data, ref, length);
}

// TODO: Unaligned loads for some platforms
#define ufbxi_read_u8(ptr) (*(const uint8_t*)(ptr))
#define ufbxi_read_u16(ptr) (*(const uint16_t*)(ptr))
#define ufbxi_read_u32(ptr) (*(const uint32_t*)(ptr))
#define ufbxi_read_u64(ptr) (*(const uint64_t*)(ptr))
#define ufbxi_read_f32(ptr) (*(const float*)(ptr))
#define ufbxi_read_f64(ptr) (*(const double*)(ptr))
#define ufbxi_read_i8(ptr) (int8_t)(ufbxi_read_u8(ptr))
#define ufbxi_read_i16(ptr) (int16_t)(ufbxi_read_u16(ptr))
#define ufbxi_read_i32(ptr) (int32_t)(ufbxi_read_u32(ptr))
#define ufbxi_read_i64(ptr) (int64_t)(ufbxi_read_u64(ptr))

#define ufbxi_write_u8(ptr, val) (*(uint8_t*)(ptr) = (uint8_t)(val))
#define ufbxi_write_u16(ptr, val) (*(uint16_t*)(ptr) = (uint16_t)(val))
#define ufbxi_write_u32(ptr, val) (*(uint32_t*)(ptr) = (uint32_t)(val))
#define ufbxi_write_u64(ptr, val) (*(uint64_t*)(ptr) = (uint64_t)(val))
#define ufbxi_write_f32(ptr, val) (*(float*)(ptr) = (float)(val))
#define ufbxi_write_f64(ptr, val) (*(double*)(ptr) = (double)(val))
#define ufbxi_write_i8(ptr, val) ufbxi_write_u8(ptr, val)
#define ufbxi_write_i16(ptr, val) ufbxi_write_u16(ptr, val)
#define ufbxi_write_i32(ptr, val) ufbxi_write_u32(ptr, val)
#define ufbxi_write_i64(ptr, val) ufbxi_write_u64(ptr, val)

// -- DEFLATE implementation
// Pretty much based on Sean Barrett's `stb_image` deflate

#if !defined(ufbx_inflate)

// Lookup data: [0:13] extra mask [13:17] extra bits [17:32] base value
// Generated by `misc/deflate_lut.py`
static const uint32_t ufbxi_deflate_length_lut[] = {
	0x00060000, 0x00080000, 0x000a0000, 0x000c0000, 0x000e0000, 0x00100000, 0x00120000, 0x00140000, 
	0x00162001, 0x001a2001, 0x001e2001, 0x00222001, 0x00264003, 0x002e4003, 0x00364003, 0x003e4003, 
	0x00466007, 0x00566007, 0x00666007, 0x00766007, 0x0086800f, 0x00a6800f, 0x00c6800f, 0x00e6800f, 
	0x0106a01f, 0x0146a01f, 0x0186a01f, 0x01c6a01f, 0x02040000, 0x00000000, 0x00000000, 
};
static const uint32_t ufbxi_deflate_dist_lut[] = {
	0x00020000, 0x00040000, 0x00060000, 0x00080000, 0x000a2001, 0x000e2001, 0x00124003, 0x001a4003, 
	0x00226007, 0x00326007, 0x0042800f, 0x0062800f, 0x0082a01f, 0x00c2a01f, 0x0102c03f, 0x0182c03f, 
	0x0202e07f, 0x0302e07f, 0x040300ff, 0x060300ff, 0x080321ff, 0x0c0321ff, 0x100343ff, 0x180343ff, 
	0x200367ff, 0x300367ff, 0x40038fff, 0x60038fff, 0x8003bfff, 0xc003bfff, 
};

static const uint8_t ufbxi_deflate_code_length_permutation[] = {
	16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15,
};

#define UFBXI_HUFF_MAX_BITS 16
#define UFBXI_HUFF_MAX_VALUE 288
#define UFBXI_HUFF_FAST_BITS 9
#define UFBXI_HUFF_FAST_SIZE (1 << UFBXI_HUFF_FAST_BITS)
#define UFBXI_HUFF_FAST_MASK (UFBXI_HUFF_FAST_SIZE - 1)

typedef struct {
	uint64_t fast_begin_bits, fast_size_bits;
	const uint64_t *fast_data;
	const char *data;
	size_t size;
	uint64_t prefix[2], suffix[2];
} ufbxi_bit_stream;

typedef struct {
	uint32_t num_symbols;

	uint16_t sorted_to_sym[UFBXI_HUFF_MAX_VALUE]; // < Sorted symbol index to symbol
	uint16_t past_max_code[UFBXI_HUFF_MAX_BITS];  // < One past maximum code value per bit length
	int16_t code_to_sorted[UFBXI_HUFF_MAX_BITS];  // < Code to sorted symbol index per bit length
	uint16_t fast_sym[UFBXI_HUFF_FAST_SIZE];      // < Fast symbol lookup [0:12] symbol [12:16] bits
} ufbxi_huff_tree;

typedef struct {
	ufbxi_bit_stream stream;
	ufbxi_huff_tree huff_lit_length;
	ufbxi_huff_tree huff_dist;

	char *out_begin;
	char *out_ptr;
	char *out_end;
} ufbxi_deflate_context;

static ufbxi_noinline void
ufbxi_bit_init(ufbxi_bit_stream *s, const void *data, size_t size)
{
	uintptr_t fast_begin_addr = ((uintptr_t)data + ((8 - (uintptr_t)data) & 7u));
	uintptr_t fast_end_addr = ((uintptr_t)data + size) & ~(uintptr_t)7u;
	const char *bytes = (const char*)data;

	s->data = bytes;
	s->size = size;

	if ((ptrdiff_t)(fast_end_addr - fast_begin_addr) >= 16) {
		uint64_t fast_begin_offset = fast_begin_addr - (uintptr_t)data;
		s->fast_begin_bits = fast_begin_offset * 8;
		s->fast_size_bits = (fast_end_addr - fast_begin_addr) * 8 - 64;
		s->fast_data = (const uint64_t*)((const char*)data + fast_begin_offset);
	} else {
		s->fast_begin_bits = 0;
		s->fast_size_bits = 0;
		s->fast_data = NULL;
	}

	s->prefix[0] = s->prefix[1] = 0;
	s->suffix[0] = s->suffix[1] = 0;
	for (size_t i = 0; i < 8; i++) {
		if (i < size) {
			s->prefix[0] |= (uint64_t)(uint8_t)bytes[i] << (i * 8);
			s->suffix[1] |= (uint64_t)(uint8_t)bytes[size - i - 1] << (56 - i * 8);
		}
		if (i + 8 < size) {
			s->prefix[1] |= (uint64_t)(uint8_t)bytes[i + 8] << (i * 8);
			s->suffix[0] |= (uint64_t)(uint8_t)bytes[size - i - 9] << (56 - i * 8);
		}
	}
}

static ufbxi_noinline uint64_t
ufbxi_bit_read_slow(ufbxi_bit_stream *s, uint64_t offset_bits)
{
	if (offset_bits < 64) {
		return s->prefix[0] >> offset_bits | (s->prefix[1] << 1) << (63 - offset_bits);
	} else {
		uint64_t suffix_shift = (uint64_t)offset_bits - ((uint64_t)s->size * 8 - 128);
		if (suffix_shift < 64) {
			return s->suffix[0] >> suffix_shift | (s->suffix[1] << 1) << (63 - suffix_shift);
		} else if (suffix_shift < 128) {
			return s->suffix[1] >> (suffix_shift - 64);
		} else {
			return 0;
		}
	}
}

static ufbxi_forceinline uint64_t
ufbxi_bit_read(ufbxi_bit_stream *s, uint64_t offset_bits)
{
	uint64_t fast_pos_bits = offset_bits - s->fast_begin_bits;
	unsigned shift = fast_pos_bits & 63;
	if (fast_pos_bits < s->fast_size_bits) {
		uint64_t word = fast_pos_bits >> 6;
		uint64_t a = s->fast_data[word];
		uint64_t b = s->fast_data[word + 1];
		return a >> shift | (b << 1) << (63 - shift);
	} else {
		return ufbxi_bit_read_slow(s, offset_bits);
	}
}

// 0: Success
// -1: Overfull
// -2: Underfull
static ufbxi_noinline ptrdiff_t
ufbxi_huff_build(ufbxi_huff_tree *tree, uint8_t *sym_bits, uint32_t sym_count)
{
	ufbx_assert(sym_count <= UFBXI_HUFF_MAX_VALUE);
	tree->num_symbols = sym_count;

	uint32_t bits_counts[UFBXI_HUFF_MAX_BITS];
	memset(bits_counts, 0, sizeof(bits_counts));
	for (uint32_t i = 0; i < sym_count; i++) {
		uint32_t bits = sym_bits[i];
		ufbx_assert(bits <= UFBXI_HUFF_MAX_BITS);
		bits_counts[bits]++;
	}
	uint32_t nonzero_sym_count = sym_count - bits_counts[0];

	uint32_t total_syms[UFBXI_HUFF_MAX_BITS];
	uint32_t first_code[UFBXI_HUFF_MAX_BITS];

	tree->code_to_sorted[0] = INT16_MAX;
	tree->past_max_code[0] = 0;
	total_syms[0] = 0;

	int num_codes_left = 1;
	uint32_t code = 0;
	uint32_t prev_count = 0;
	for (uint32_t bits = 1; bits < UFBXI_HUFF_MAX_BITS; bits++) {
		uint32_t count = bits_counts[bits];
		code = (code + prev_count) << 1;
		first_code[bits] = code;
		tree->past_max_code[bits] = (uint16_t)(code + count);

		uint32_t prev_syms = total_syms[bits - 1];
		total_syms[bits] = prev_syms + count;

		// Each bit level doubles the amount of codes and potentially removes some
		num_codes_left = (num_codes_left << 1) - count;
		if (num_codes_left < 0) {
			return -1;
		}

		if (count > 0) {
			tree->code_to_sorted[bits] = (int16_t)((int)prev_syms - (int)code);
		} else {
			tree->code_to_sorted[bits] = INT16_MAX;
		}
		prev_count = count;
	}

	// All codes should be used if there's more than one symbol
	if (nonzero_sym_count > 1 && num_codes_left != 0) {
		return -2;
	}

	memset(tree->fast_sym, 0, sizeof(tree->fast_sym));

	uint32_t bits_index[UFBXI_HUFF_MAX_BITS];
	memset(bits_index, 0, sizeof(bits_index));
	memset(tree->sorted_to_sym, 0xff, sizeof(tree->sorted_to_sym));
	for (uint32_t i = 0; i < sym_count; i++) {
		uint32_t bits = sym_bits[i];
		if (bits == 0) continue;

		uint32_t index = bits_index[bits]++;
		uint32_t sorted = total_syms[bits - 1] + index;
		tree->sorted_to_sym[sorted] = i;

		uint32_t code = first_code[bits] + index;
		uint32_t rev_code = 0;
		for (uint32_t bit = 0; bit < bits; bit++) {
			if (code & (1 << bit)) rev_code |= 1 << (bits - bit - 1);
		}

		if (bits <= UFBXI_HUFF_FAST_BITS) {
			uint16_t fast_sym = i | bits << 12;
			uint32_t hi_max = 1 << (UFBXI_HUFF_FAST_BITS - bits);
			for (uint32_t hi = 0; hi < hi_max; hi++) {
				ufbx_assert(tree->fast_sym[rev_code | hi << bits] == 0);
				tree->fast_sym[rev_code | hi << bits] = fast_sym;
			}
		}
	}

	return 0;
}

static ufbxi_forceinline uint32_t
ufbxi_huff_decode_bits(const ufbxi_huff_tree *tree, uint64_t *p_bits, uint64_t *p_pos)
{
	uint32_t fast_sym_bits = tree->fast_sym[*p_bits & UFBXI_HUFF_FAST_MASK];
	if (fast_sym_bits != 0) {
		uint32_t bits = fast_sym_bits >> 12;
		*p_pos += bits;
		*p_bits >>= bits;
		return fast_sym_bits & 0x3ff;
	}

	uint32_t code = 0;
	for (uint32_t bits = 1; bits < UFBXI_HUFF_MAX_BITS; bits++) {
		code = code << 1 | (*p_bits & 1);
		*p_bits >>= 1;
		*p_pos += 1;
		if (code < tree->past_max_code[bits]) {
			uint32_t sorted = code + tree->code_to_sorted[bits];
			if (sorted >= tree->num_symbols) return ~0u;
			return tree->sorted_to_sym[sorted];
		}
	}

	return ~0u;
}

static void
ufbxi_init_static_huff(ufbxi_deflate_context *dc)
{
	ptrdiff_t err = 0;

	uint8_t lit_length_bits[288];
	memset(lit_length_bits +   0, 8, 144 -   0);
	memset(lit_length_bits + 144, 9, 256 - 144);
	memset(lit_length_bits + 256, 7, 280 - 256);
	memset(lit_length_bits + 280, 8, 288 - 280);
	err |= ufbxi_huff_build(&dc->huff_lit_length, lit_length_bits, sizeof(lit_length_bits));

	uint8_t dist_bits[32];
	memset(dist_bits + 0, 5, 32 - 0);
	err |= ufbxi_huff_build(&dc->huff_dist, dist_bits, sizeof(dist_bits));

	ufbx_assert(err == 0);
}

// 0: Success
// -1: Huffman Overfull
// -2: Huffman Underfull
// -3: Code 16 repeat overflow
// -4: Code 17 repeat overflow
// -5: Code 18 repeat overflow
// -6: Bad length code
static ufbxi_noinline ptrdiff_t
ufbxi_init_dynamic_huff_tree(ufbxi_deflate_context *dc, const ufbxi_huff_tree *huff_code_length,
	ufbxi_huff_tree *tree, uint32_t num_symbols, uint64_t *p_pos)
{
	uint8_t code_lengths[UFBXI_HUFF_MAX_VALUE];
	ufbx_assert(num_symbols <= UFBXI_HUFF_MAX_VALUE);
	uint64_t pos = *p_pos;

	uint32_t symbol_index = 0;
	uint8_t prev = 0;
	while (symbol_index < num_symbols) {
		uint64_t bits = ufbxi_bit_read(&dc->stream, pos);

		uint32_t inst = ufbxi_huff_decode_bits(huff_code_length, &bits, &pos);
		if (inst <= 15) {
			prev = (uint8_t)inst;
			code_lengths[symbol_index++] = (uint8_t)inst;
		} else if (inst == 16) {
			uint32_t num = 3 + ((uint32_t)bits & 0x3);
			pos += 2;
			if (symbol_index + num > num_symbols) return -3;
			memset(code_lengths + symbol_index, prev, num);
			symbol_index += num;
		} else if (inst == 17) {
			uint32_t num = 3 + ((uint32_t)bits & 0x7);
			pos += 3;
			if (symbol_index + num > num_symbols) return -4;
			memset(code_lengths + symbol_index, 0, num);
			symbol_index += num;
			prev = 0;
		} else if (inst == 18) {
			uint32_t num = 11 + ((uint32_t)bits & 0x7f);
			pos += 7;
			if (symbol_index + num > num_symbols) return -5;
			memset(code_lengths + symbol_index, 0, num);
			symbol_index += num;
			prev = 0;
		} else {
			return -6;
		}
	}

	ptrdiff_t err = ufbxi_huff_build(tree, code_lengths, num_symbols);
	if (err != 0) return err;

	*p_pos = pos;
	return 0;
}

static ptrdiff_t
ufbxi_init_dynamic_huff(ufbxi_deflate_context *dc, uint64_t *p_pos)
{
	uint64_t pos = *p_pos;
	uint64_t bits = ufbxi_bit_read(&dc->stream, pos);
	pos += 14;

	uint32_t num_lit_lengths = 257 + (bits & 0x1f);
	uint32_t num_dists = 1 + (bits >> 5 & 0x1f);
	uint32_t num_code_lengths = 4 + (bits >> 10 & 0xf);

	uint8_t code_lengths[19];
	memset(code_lengths, 0, sizeof(code_lengths));

	bits = ufbxi_bit_read(&dc->stream, pos);
	for (uint32_t i = 0; i < num_code_lengths; i++) {
		code_lengths[ufbxi_deflate_code_length_permutation[i]] = (uint32_t)bits & 0x7;
		bits >>= 3;
	}
	pos += num_code_lengths * 3;

	ufbxi_huff_tree huff_code_length;
	ptrdiff_t err;
	err = ufbxi_huff_build(&huff_code_length, code_lengths, ufbxi_arraycount(code_lengths));
	if (err) return -14 + 1 + err;
	err = ufbxi_init_dynamic_huff_tree(dc, &huff_code_length, &dc->huff_lit_length, num_lit_lengths, &pos);
	if (err) return -16 + 1 + err;
	err = ufbxi_init_dynamic_huff_tree(dc, &huff_code_length, &dc->huff_dist, num_dists, &pos);
	if (err) return -22 + 1 + err;

	*p_pos = pos;
	return 0;
}

static uint32_t
ufbxi_adler32(const void *data, size_t size)
{
	size_t a = 1, b = 0;
	const size_t num_before_wrap = sizeof(size_t) == 8 ? 380368439u : 5552u;

	const char *p = (const char*)data;

	size_t size_left = size;
	while (size_left > 0) {
		size_t num = size_left <= num_before_wrap ? size_left : num_before_wrap;
		size_left -= num;
		const char *end = p + num;

		while (end - p >= 8) {
			a += (size_t)(uint8_t)p[0]; b += a;
			a += (size_t)(uint8_t)p[1]; b += a;
			a += (size_t)(uint8_t)p[2]; b += a;
			a += (size_t)(uint8_t)p[3]; b += a;
			a += (size_t)(uint8_t)p[4]; b += a;
			a += (size_t)(uint8_t)p[5]; b += a;
			a += (size_t)(uint8_t)p[6]; b += a;
			a += (size_t)(uint8_t)p[7]; b += a;
			p += 8;
		}

		while (p != end) {
			a += (size_t)(uint8_t)p[0]; b += a;
			p++;
		}

		a %= 65521u;
		b %= 65521u;
	}

	return (uint32_t)((b << 16) | (a & 0xffff));
}

static int
ufbxi_inflate_block(ufbxi_deflate_context *dc, uint64_t *p_pos)
{
	uint64_t pos = *p_pos;
	char *out_ptr = dc->out_ptr;
	char *const out_begin = dc->out_begin;
	char *const out_end = dc->out_end;

	for (;;) {
		uint64_t bits = ufbxi_bit_read(&dc->stream, pos); // 64 bits

		// Decode literal/length value from input stream
		uint32_t lit_length = ufbxi_huff_decode_bits(&dc->huff_lit_length, &bits, &pos); // 49 bits

		// If value < 256: copy value (literal byte) to output stream
		if (lit_length < 256) {
			if (out_ptr == out_end) {
				return -10;
			}
			*out_ptr++ = (char)lit_length;
		} else if (lit_length - 257 <= 285 - 257) {
			// If value = 257..285: Decode extra length and distance
			uint32_t length, distance;

			// Length
			{
				uint32_t lut = ufbxi_deflate_length_lut[lit_length - 257];
				uint32_t base = lut >> 17;
				uint32_t offset = ((uint32_t)bits & lut & 0x1fff); // 34 bits
				uint32_t offset_bits = (lut >> 13) & 0xf;
				bits >>= offset_bits;
				pos += offset_bits;
				length = base + offset;
			}

			// Distance
			{
				uint32_t dist = ufbxi_huff_decode_bits(&dc->huff_dist, &bits, &pos); // 19 bits
				if (dist >= 30) {
					return -11;
				}
				uint32_t lut = ufbxi_deflate_dist_lut[dist];
				uint32_t base = lut >> 17;
				uint32_t offset = ((uint32_t)bits & lut & 0x1fff); // 6 bits
				uint32_t offset_bits = (lut >> 13) & 0xf;
				bits >>= offset_bits;
				pos += offset_bits;
				distance = base + offset;
			}

			if (distance > out_ptr - out_begin || length > out_end - out_ptr) {
				return -12;
			}

			// TODO: Do something better than per-byte copy
			const char *src_ptr = out_ptr - distance;
			char *end = out_ptr + length;
			ufbx_assert(length > 0);
			do {
				char c = *src_ptr++;
				*out_ptr++ = c;
			} while (out_ptr != end);
		} else if (lit_length == 256) {
			break;
		} else {
			return -13;
		}
	}

	dc->out_ptr = out_ptr;
	*p_pos = pos;
	return 0;
}

// TODO: Error codes should have a quick test if the destination buffer overflowed
// Returns actual number of decompressed bytes or negative error:
// -1: Bad compression method (ZLIB header)
// -2: Requires dictionary (ZLIB header)
// -3: Bad FCHECK (ZLIB header)
// -4: Bad NLEN (Uncompressed LEN != ~NLEN)
// -5: Uncompressed source overflow
// -6: Uncompressed destination overflow
// -7: Bad block type
// -8: Truncated checksum
// -9: Checksum mismatch
// -10: Literal destination overflow
// -11: Bad distance code or distance of (30..31)
// -12: Match out of bounds
// -13: Bad lit/length code
// -14: Codelen Huffman Overfull
// -15: Codelen Huffman Underfull
// -16 - -21: Litlen Huffman: Overfull / Underfull / Repeat 16/17/18 overflow / Bad length code
// -22 - -27: Distance Huffman: Overfull / Underfull / Repeat 16/17/18 overflow / Bad length code
static ptrdiff_t
ufbxi_inflate(void *dst, uint32_t dst_size, const void *src, uint32_t src_size)
{
	ptrdiff_t err;
	ufbxi_deflate_context dc;
	ufbxi_bit_init(&dc.stream, src, src_size);
	dc.out_begin = (char*)dst;
	dc.out_ptr = (char*)dst;
	dc.out_end = (char*)dst + dst_size;
	const char *null_error;

	uint64_t pos = 0;
	uint64_t bits = ufbxi_bit_read(&dc.stream, pos);

	// Zlib header
	{
		size_t cmf = (size_t)(bits & 0xff);
		size_t flg = (size_t)(bits >> 8) & 0xff;
		bits >>= 16;
		pos += 16;

		if ((cmf & 0xf) != 0x8) return -1;
		if ((flg & 0x20) != 0) return -2;
		if ((cmf << 8 | flg) % 31u != 0) return -3;
	}

	for (;;) { 
		bits = ufbxi_bit_read(&dc.stream, pos);

		// Block header: [0:1] BFINAL [1:3] BTYPE
		size_t header = (size_t)bits & 0x7;
		bits >>= 3;
		pos += 3;

		size_t type = header >> 1;
		if (type == 0) {
			// 0b00 - no compression
			// Round up to the next byte
			size_t byte_pos = (size_t)((pos + 7) >> 3);
			bits >>= ((uint64_t)byte_pos << 3) - pos;

			// Literal header: [0:2] LEN [2:4] NLEN = ~LEN
			const uint8_t *src_pos = (const uint8_t*)src + byte_pos;
			size_t len = (size_t)(bits & 0xffff);
			size_t nlen = (size_t)((bits >> 16) & 0xffff);
			if ((len ^ nlen) != 0xffff) return -4;
			if (byte_pos + len + 4 > src_size) return -5;
			if (dc.out_end - dc.out_ptr < len) return -6;

			// Copy literal data (skipping header) and advance
			memcpy(dc.out_ptr, src_pos + 4, len);
			dc.out_ptr += len;
			pos = (byte_pos + 4 + len) << 3;
		} else if (type <= 2) {
			if (type == 1) {
				// TODO: Cache the trees?
				ufbxi_init_static_huff(&dc);
			} else { 
				err = ufbxi_init_dynamic_huff(&dc, &pos);
				if (err) return err;
			}

			err = ufbxi_inflate_block(&dc, &pos);
			if (err) return err;
		} else {
			// 0b11 - reserved (error)
			return -7;
		}

		// BFINAL: End of stream
		if (header & 1) break;
	}

	// Check Adler-32
	{
		// Round up to the next byte
		size_t byte_pos = (size_t)((pos + 7) >> 3);
		if (src_size < byte_pos + 4) {
			return -8;
		}
		const uint8_t *p = (const uint8_t*)src + byte_pos;
		uint32_t ref = p[0] << 24 | p[1] << 16 | p[2] << 8 | p[3];
		uint32_t checksum = ufbxi_adler32(dc.out_begin, dc.out_ptr - dc.out_begin);
		if (ref != checksum) {
			return -9;
		}
	}

	return dc.out_ptr - dc.out_begin;
}

#define ufbx_inflate ufbxi_inflate

#endif // !defined(ufbx_inflate)

// -- Binary parsing

typedef struct {
	ufbxi_string name;
	size_t value_begin_pos;
	size_t child_begin_pos;
	size_t end_pos;

	size_t next_value_pos;
	size_t next_child_pos;
} ufbxi_node;

#define UFBXI_NODE_STACK_SIZE 16

typedef struct {
	const char *data;
	size_t size;

	uint32_t version;
	int from_ascii;

	// Currently focused (via find or iteration) node.
	ufbxi_node focused_node;

	// Entered node stack.
	ufbxi_node node_stack[UFBXI_NODE_STACK_SIZE];
	ufbxi_node *node_stack_top;

	// Error status
	int failed;
	ufbx_error *error;
} ufbxi_context;

typedef enum {
	ufbxi_val_int,    // < I,L,Y,C
	ufbxi_val_float,  // < F,D
	ufbxi_val_string, // < S
	ufbxi_val_array,  // < i,l,f,d,b
} ufbxi_val_class;

typedef enum {
	ufbxi_encoding_basic = 0,
	ufbxi_encoding_deflate = 1,

	// Custom array encoding for older FBX compatability. Concatenates multiple
	// individual values into a single array. Magic number 'UFmv' (little endian)
	// chosen to minimize risk of colliding with other custom encodings.
	ufbxi_encoding_multivalue = 0x766d4655,
} ufbxi_array_encoding;

typedef struct {
	size_t num_elements;
	ufbxi_array_encoding encoding;  
	size_t encoded_size;
	size_t data_offset;
	char src_type;
	char dst_type;
} ufbxi_array;

typedef struct {
	char type_code;
	ufbxi_val_class value_class;
	union {
		uint64_t i;
		double f;
		ufbxi_string str;
		ufbxi_array arr;
	} value;
} ufbxi_any_value;

static int ufbxi_do_error(ufbxi_context *uc, uint32_t line, const char *desc)
{
	if (uc->failed) return 0;
	uc->failed = 1;
	size_t length = strlen(desc);
	if (length > UFBX_ERROR_DESC_MAX_LENGTH) length = UFBX_ERROR_DESC_MAX_LENGTH;
	if (uc->error) {
		uc->error->source_line = line;
		memcpy(uc->error->desc, desc, length);
		uc->error->desc[length] = '\0';
	}
	return 0;
}

static int ufbxi_do_errorf(ufbxi_context *uc, uint32_t line, const char *fmt, ...)
{
	if (uc->failed) return 0;
	uc->failed = 1;
	va_list args;
	va_start(args, fmt);
	if (uc->error) {
		uc->error->source_line = line;
		vsnprintf(uc->error->desc, sizeof(uc->error->desc), fmt, args);
	}
	va_end(args);
	return 0;
}

#define ufbxi_error(uc, desc) ufbxi_do_error((uc), __LINE__, (desc))
#define ufbxi_errorf(uc, fmt, ...) ufbxi_do_errorf((uc), __LINE__, (fmt), __VA_ARGS__)

// Prepare `dst` as an multivalue encoded array. Does not parse the data yet,
// only counts the number of elements, checks types, and skips the array data.
static int ufbxi_convert_multivalue_array(ufbxi_context *uc, ufbxi_array *dst, char dst_type)
{
	size_t begin = uc->focused_node.next_value_pos;
	uint32_t num_elements = 0;
	while (uc->focused_node.next_value_pos < uc->focused_node.child_begin_pos) {
		char src_type = uc->data[uc->focused_node.next_value_pos];
		uint32_t size;
		switch (src_type) {
		case 'I': size = 4; break;
		case 'L': size = 8; break;
		case 'Y': size = 2; break;
		case 'C': size = 1; break;
		case 'F': size = 4; break;
		case 'D': size = 8; break;
		default: return ufbxi_errorf(uc, "Bad multivalue array type '%c'", src_type);
		}
		uc->focused_node.next_value_pos += 1 + size;
		num_elements++;
	}
	if (uc->focused_node.next_value_pos != uc->focused_node.child_begin_pos) {
		return ufbxi_error(uc, "Multivalue array overrun");
	}

	dst->num_elements = num_elements;
	dst->data_offset = begin;
	dst->encoding = ufbxi_encoding_multivalue;
	dst->encoded_size = uc->focused_node.next_value_pos - begin;
	// NOTE: Multivalue arrays can be heterogenous, just use `dst_type` as `src_type`
	dst->src_type = dst_type; 
	dst->dst_type = dst_type;
	return 1;
}
// Parse the next node value in the input stream.
// `dst_type` is a FBX-like type string:
//   Numbers: "I" u/int32_t  "L" u/int64_t  "B" char (bool)  "F" float  "D" double
//   Data: "SR" ufbxi_string  "ilfdb" ufbxi_val_array (matching upper-case type)
//   Misc: "." (ignore)  "?" ufbxi_any_value
// Performs implicit conversions:
//   FDILY -> FD, ILYC -> ILB, ILFDYilfd -> fd, ILYCilb -> ilb
static int ufbxi_parse_value(ufbxi_context *uc, char dst_type, void *dst)
{
	// An FBX file must end in a 13 or 25-byte NULL node. Due to this a valid
	// FBX file must always have space for the largest possible property header.
	if (uc->size - uc->focused_node.next_value_pos < 13) {
		return ufbxi_error(uc, "Reading value at the end of file");
	}

	size_t pos = uc->focused_node.next_value_pos;
	char src_type = uc->data[pos];
	const char *src = uc->data + pos + 1;

	// Read the next value locally
	size_t val_size = 1;
	ufbxi_val_class val_class;
	int64_t val_int;
	double val_float;
	size_t val_num_elements;
	uint32_t val_encoding;
	size_t val_encoded_size;
	size_t val_data_offset;
	switch (src_type) {
	case 'I': val_class = ufbxi_val_int; val_int = ufbxi_read_i32(src); val_size += 4; break;
	case 'L': val_class = ufbxi_val_int; val_int = ufbxi_read_i64(src); val_size += 8; break;
	case 'Y': val_class = ufbxi_val_int; val_int = ufbxi_read_i16(src); val_size += 2; break;
	case 'C': val_class = ufbxi_val_int; val_int = (ufbxi_read_u8(src) ? 1 : 0); val_size += 1; break;
	case 'F': val_class = ufbxi_val_float; val_float = ufbxi_read_f32(src); val_size += 4; break;
	case 'D': val_class = ufbxi_val_float; val_float = ufbxi_read_f64(src); val_size += 8; break;
	case 'S': case 'R':
		val_class = ufbxi_val_string;
		val_num_elements = ufbxi_read_u32(src);
		if (val_num_elements > 0x1000000) {
			return ufbxi_errorf(uc, "String is too large: %u bytes", val_num_elements);
		}
		val_size += 4 + val_num_elements;
		val_data_offset = pos + 5;
		break;
	case 'i': case 'l': case 'f': case 'd': case 'b':
		val_class = ufbxi_val_array;
		val_num_elements = ufbxi_read_u32(src + 0);
		val_encoding = ufbxi_read_u32(src + 4);
		val_encoded_size = ufbxi_read_u32(src + 8);
		if (val_encoded_size > 0x1000000) {
			return ufbxi_errorf(uc, "Array is too large: %u bytes", val_encoded_size);
		}
		val_size += 12 + val_encoded_size;
		val_data_offset = pos + 13;
		break;
	default:
		return ufbxi_errorf(uc, "Invalid type code '%c'", src_type);
	}

	size_t val_end = pos + val_size;
	if (val_end < pos || val_end > uc->focused_node.child_begin_pos) {
		return ufbxi_errorf(uc, "Value overflows data block: %u bytes", val_size);
	}
	uc->focused_node.next_value_pos = val_end;

	// Early return: Ignore the data
	if (dst_type == '.') return 1;
	ufbxi_any_value *any = NULL;
	if (dst_type == '?') {
		any = (ufbxi_any_value*)dst;
		any->type_code = src_type;
		any->value_class = val_class;
	}

	// Interpret the read value into the user pointer, potentially applying the
	// implicit conversion rules.
	if (val_class == ufbxi_val_int) {
		switch (dst_type) {
		case 'I': *(int32_t*)dst = (int32_t)val_int; break;
		case 'L': *(int64_t*)dst = val_int; break;
		case 'B': *(char*)dst = val_int ? 1 : 0; break;
		case 'F': *(float*)dst = (float)val_int; break;
		case 'D': *(double*)dst = (double)val_int; break;
		case '?': any->value.i = val_int; break;
		case 'i': case 'l': case 'f': case 'd': case 'b':
			// Early return: Parse as multivalue array. Reset position to beginning and rescan.
			uc->focused_node.next_value_pos = pos;
			return ufbxi_convert_multivalue_array(uc, (ufbxi_array*)dst, dst_type);
		default:
			return ufbxi_errorf(uc, "Cannot convert from int '%c' to '%c'", src_type, dst_type);
		}

	} else if (val_class == ufbxi_val_float) {
		switch (dst_type) {
		case 'F': *(float*)dst = (float)val_float; break;
		case 'D': *(double*)dst = val_float; break;
		case '?': any->value.f = val_float; break;
		case 'f': case 'd':
			// Early return: Parse as multivalue array. Reset position to beginning and rescan.
			uc->focused_node.next_value_pos = pos;
			return ufbxi_convert_multivalue_array(uc, (ufbxi_array*)dst, dst_type);
		default:
			return ufbxi_errorf(uc, "Cannot convert from float '%c' to '%c'", src_type, dst_type);
		}

	} else if (val_class == ufbxi_val_string) {
		ufbxi_string *str;
		switch (dst_type) {
		case 'S': str = (ufbxi_string*)dst; break;
		case '?': str = &any->value.str; break;
		default:
			return ufbxi_errorf(uc, "Cannot convert from string '%c' to '%c'", src_type, dst_type);
		}

		str->data = uc->data + val_data_offset;
		str->length = val_num_elements;
	} else if (val_class == ufbxi_val_array) {
		ufbxi_array *arr;
		switch (dst_type) {
		case 'i': case 'l': case 'f': case 'd': case 'b':
			arr = (ufbxi_array*)dst;
			arr->dst_type = dst_type;
			break;
		case '?':
			arr = &any->value.arr;
			arr->dst_type = src_type;
			break;
		default:
			return ufbxi_errorf(uc, "Cannot convert from array '%c' to '%c'", src_type, dst_type);
		}

		arr->src_type = src_type;
		arr->num_elements = val_num_elements;
		arr->encoding = (ufbxi_array_encoding)val_encoding;
		arr->encoded_size = val_encoded_size;
		arr->data_offset = val_data_offset;
		if (val_encoding != ufbxi_encoding_basic && val_encoding != ufbxi_encoding_deflate) {
			return ufbxi_errorf(uc, "Unknown array encoding: %u", val_encoding);
		}
	}

	return 1;
}

// VA-list version of `ufbxi_parse_values()`
static int ufbxi_parse_values_va(ufbxi_context *uc, const char *fmt, va_list args)
{
	const char *fmt_ptr = fmt;
	char ch;
	while ((ch = *fmt_ptr) != '\0') {
		void *dst = NULL;
		if (ch != '.') dst = va_arg(args, void*);
		if (!ufbxi_parse_value(uc, ch, dst)) {
			va_end(args);
			return 0;
		}
		fmt_ptr++;
	}
	return 1;
}

// Parse multiple values, works like `scanf()`.
// See `ufbxi_parse_value()` for more information.
static int ufbxi_parse_values(ufbxi_context *uc, const char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	int ret = ufbxi_parse_values_va(uc, fmt, args);
	va_end(args);
	return ret;
}

// Decode the data of an multivalue array into memory. Requires the array to be
// prepared with `ufbxi_convert_multivalue_array()`.
static int ufbxi_decode_multivalue_array(ufbxi_context *uc, ufbxi_array *arr, void *dst)
{
	if (arr->encoding != ufbxi_encoding_multivalue) {
		return ufbxi_error(uc, "Internal: Bad multivalue encoding");
	}

	// HACK: Create a virtual node for the multivalue array and set it as
	// the current one.
	ufbxi_node focused_node = uc->focused_node;
	memset(&uc->focused_node, 0, sizeof(ufbxi_node));

	size_t arr_begin = arr->data_offset;
	size_t arr_end = arr_begin + arr->encoded_size;
	uc->focused_node.value_begin_pos = arr_begin;
	uc->focused_node.next_value_pos = arr_begin;
	uc->focused_node.child_begin_pos = arr_end;
	uc->focused_node.next_child_pos = arr_end;
	uc->focused_node.end_pos = arr_end;

	char dst_elem_type;
	uint32_t dst_elem_size;
	switch (arr->dst_type) {
	case 'i': dst_elem_type = 'I'; dst_elem_size = 4; break;
	case 'l': dst_elem_type = 'L'; dst_elem_size = 8; break;
	case 'f': dst_elem_type = 'F'; dst_elem_size = 4; break;
	case 'd': dst_elem_type = 'D'; dst_elem_size = 8; break;
	case 'b': dst_elem_type = 'B'; dst_elem_size = 1; break;
	}

	char *dst_ptr = (char*)dst;
	while (uc->focused_node.next_value_pos < uc->focused_node.child_begin_pos) {
		if (!ufbxi_parse_value(uc, dst_elem_type, dst_ptr)) return 0;
		dst_ptr += dst_elem_size;
	}
	if (uc->focused_node.next_value_pos != uc->focused_node.child_begin_pos) {
		return ufbxi_error(uc, "Multivalue array overrun");
	}
	if (dst_ptr != (char*)dst + arr->num_elements * dst_elem_size) {
		return ufbxi_error(uc, "Internal: Multivalue array read failed");
	}

	uc->focused_node = focused_node;
	return 1;
}

// Decode the contents of an array into memory. Performs potential type conversion
// and decoding of the data. Should not fail for a non-decoding failure reason.
static int ufbxi_decode_array(ufbxi_context *uc, ufbxi_array *arr, void *dst)
{
	uint32_t elem_size;
	switch (arr->dst_type) {
	case 'i': case 'f': elem_size = 4; break;
	case 'l': case 'd': elem_size = 8; break;
	case 'b': elem_size = 1; break;
	default: return ufbxi_error(uc, "Internal: Invalid array type");
	}

	size_t arr_size = arr->num_elements * elem_size;

	if (arr->dst_type == arr->src_type) {
		const void *src = uc->data + arr->data_offset;

		// Fast path: Source is memory-compatible with destination, decode directly to
		// the destination memory.
		switch (arr->encoding) {
		case ufbxi_encoding_basic:
			if (arr->encoded_size != arr_size) {
				return ufbxi_errorf(uc, "Array size mismatch, encoded %u bytes, decoded %u bytes",
					arr->encoded_size, arr_size);
			}
			memcpy(dst, src, arr_size);
			break;
		case ufbxi_encoding_deflate:
			return ufbxi_error(uc, "Internal: Unimplemented.");
		case ufbxi_encoding_multivalue:
			// Early return: Defer to multivalue implementation.
			return ufbxi_decode_multivalue_array(uc, arr, dst);
		default: return ufbxi_error(uc, "Internal: Bad array encoding");
		}
	} else {
		const char *src_ptr;

		// Slow path: Need to do conversion, allocate temporary buffer if necessary
		switch (arr->encoding) {
		case ufbxi_encoding_basic:
			src_ptr = uc->data + arr->data_offset;
			break;
		case ufbxi_encoding_deflate:
			return ufbxi_error(uc, "Internal: Unimplemented.");
			break;
		case ufbxi_encoding_multivalue:
			// Multivalue arrays should always have `src_type == dst_type`.
			return ufbxi_error(uc, "Internal: Multivalue array has invalid type");
		default: return ufbxi_error(uc, "Internal: Bad array encoding");
		}

		uint32_t src_elem_size;
		switch (arr->src_type) {
		case 'i': case 'f': src_elem_size = 4; break;
		case 'l': case 'd': src_elem_size = 8; break;
		case 'b': src_elem_size = 1; break;
		default: return ufbxi_error(uc, "Internal: Invalid array type");
		}

		if (arr->num_elements * src_elem_size != arr->encoded_size) {
			return ufbxi_errorf(uc, "Array size mismatch, encoded %u bytes, decoded %u bytes",
				arr->encoded_size, arr->num_elements * src_elem_size);
		}
		const char *src_end = src_ptr + arr->encoded_size;

		// Try to perform type conversion.
		const char *sp = src_ptr, *ep = src_end;
		int failed = 0;
		if (arr->dst_type == 'i') {
			int32_t *dp = (int32_t*)dst;
			switch (arr->src_type) {
			case 'l': for (; sp!=ep; sp+=8) *dp++ = (int32_t)*(uint64_t*)sp; break;
			case 'b': for (; sp!=ep; sp+=1) *dp++ = *sp != 0 ? 1 : 0; break;
			default: failed = 1; break;
			}
		} else if (arr->dst_type == 'l') {
			int64_t *dp = (int64_t*)dst;
			switch (arr->src_type) {
			case 'i': for (; sp!=ep; sp+=4) *dp++ = *(int32_t*)sp; break;
			case 'b': for (; sp!=ep; sp+=1) *dp++ = *sp != 0 ? 1 : 0; break;
			default: failed = 1; break;
			}
		} else if (arr->dst_type == 'f') {
			float *dp = (float*)dst;
			switch (arr->src_type) {
			case 'i': for (; sp!=ep; sp+=4) *dp++ = (float)*(int32_t*)sp; break;
			case 'l': for (; sp!=ep; sp+=8) *dp++ = (float)*(int64_t*)sp; break;
			case 'd': for (; sp!=ep; sp+=8) *dp++ = (float)*(double*)sp; break;
			default: failed = 1; break;
			}
		} else if (arr->dst_type == 'd') {
			double *dp = (double*)dst;
			switch (arr->src_type) {
			case 'i': for (; sp!=ep; sp+=4) *dp++ = (double)*(int32_t*)sp; break;
			case 'l': for (; sp!=ep; sp+=8) *dp++ = (double)*(int64_t*)sp; break;
			case 'f': for (; sp!=ep; sp+=4) *dp++ = *(float*)sp; break;
			default: failed = 1; break;
			}
		} else if (arr->dst_type == 'b') {
			char *dp = (char*)dst;
			switch (arr->src_type) {
			case 'i': for (; sp!=ep; sp+=4) *dp++ = *(uint32_t*)sp != 0 ? 1 : 0; break;
			case 'l': for (; sp!=ep; sp+=8) *dp++ = *(uint64_t*)sp != 0 ? 1 : 0; break;
			default: failed = 1; break;
			}
		} else {
			return ufbxi_error(uc, "Internal: Unexpected array type");
		}

		if (failed) {
			return ufbxi_errorf(uc, "Bad array conversion: '%c' -> '%c'",
				arr->src_type, arr->dst_type);
		}
	}

	return 1;
}

// Enter the currently focused node. Pushes the node to stack and allows inspecting its
// children. Does not fail if the node is empty.
static int ufbxi_enter_node(ufbxi_context *uc)
{
	if (uc->node_stack_top == uc->node_stack + UFBXI_NODE_STACK_SIZE) {
		return ufbxi_error(uc, "Node stack overflow: Too many nested nodes");
	}

	uc->node_stack_top++;
	*uc->node_stack_top = uc->focused_node;
	return 1;
}

// Exit a node previously entered using `ufbxi_enter_node()`. Future child node
// iteration and find queries will be done to the parent node.
static int ufbxi_exit_node(ufbxi_context *uc)
{
	if (uc->node_stack_top == uc->node_stack) {
		return ufbxi_error(uc, "Internal: Trying to pop root node");
	}

	uc->focused_node = *uc->node_stack_top;
	uc->node_stack_top--;
	return 1;
}

// Parse the node starting from `pos` to `node`. Does not modify `node` if the
// function fails. Returns zero when parsing a NULL-record without failure.
static int ufbxi_parse_node(ufbxi_context *uc, uint64_t pos, ufbxi_node *node)
{
	uint64_t end_pos, values_len, name_pos;
	uint8_t name_len;

	if (uc->version >= 7500 || uc->from_ascii) {
		if (pos > uc->size - 25) {
			return ufbxi_error(uc, "Internal: Trying to read node out of bounds");
		}
		end_pos = ufbxi_read_u64(uc->data + pos + 0);
		values_len = ufbxi_read_u64(uc->data + pos + 16);
		name_len = ufbxi_read_u8(uc->data + pos + 24);
		name_pos = pos + 25;
	} else {
		if (pos > uc->size - 13) {
			return ufbxi_error(uc, "Internal: Trying to read node out of bounds");
		}
		end_pos = ufbxi_read_u32(uc->data + pos + 0);
		values_len = ufbxi_read_u32(uc->data + pos + 8);
		name_len = ufbxi_read_u8(uc->data + pos + 12);
		name_pos = pos + 13;
	}

	if (end_pos == 0) {
		// NULL-record: Return without failure
		return 0;
	}

	uint64_t value_pos = name_pos + name_len;
	uint64_t child_pos = value_pos + values_len;

	// Check for integer overflow and out-of-bounds at the same time. `name_pos`
	// cannot overflow due to the precondition check.
	if (value_pos < name_pos || value_pos > uc->size) {
		return ufbxi_error(uc, "Node name out of bounds");
	}
	if (child_pos < value_pos || child_pos > uc->size) {
		return ufbxi_error(uc, "Node values out of bounds");
	}
	if (end_pos < child_pos || end_pos > uc->size) {
		return ufbxi_error(uc, "Node children out of bounds");
	}

	if (value_pos > (uint64_t)SIZE_MAX || child_pos > (uint64_t)SIZE_MAX
		|| end_pos > (uint64_t)SIZE_MAX) {
		return ufbxi_error(uc, "The file requires 64-bit build");
	}

	node->name.data = uc->data + name_pos;
	node->name.length = name_len;
	node->value_begin_pos = (size_t)value_pos;
	node->next_value_pos = (size_t)value_pos;
	node->child_begin_pos = (size_t)child_pos;
	node->end_pos = (size_t)end_pos;
	node->next_child_pos = (size_t)child_pos;
	return 1;
}

// Move the focus to the next child of the currently entered node.
static int ufbxi_next_child(ufbxi_context *uc, ufbxi_string *name)
{
	ufbxi_node *top = uc->node_stack_top;
	uint64_t pos = top->next_child_pos;
	if (pos == top->end_pos) return 0;

	// Parse the node to be focused. If we encounter a NULL-record here
	// it will be reported as not having found the next child without error.
	if (!ufbxi_parse_node(uc, pos, &uc->focused_node)) return 0;

	top->next_child_pos = uc->focused_node.end_pos;
	if (name) *name = uc->focused_node.name;
	return 1;
}

// Move the focus to the first node matching a name in the currently entered node.
// Does not affect iteration with `ufbxi_next_child()`
static int ufbxi_find_node_str(ufbxi_context *uc, ufbxi_string str)
{
	// TODO
	return 0;
}

// Move to the nth node matching a name in the currently entered node.
// In/out `index`, finds the next node following `index`. Specify `-1` to
// find the first node. Call with the same variable pointer to step through
// all the found matching nodes.
// Does not affect iteration with `ufbxi_next_child()`
static int ufbxi_find_node_str_nth(ufbxi_context *uc, ufbxi_string str, int32_t *index)
{
	// TODO
	return 0;
}

// Convenient shorthands for the above functions.

static ufbxi_forceinline int
ufbxi_find_node(ufbxi_context *uc, const char *name)
{
	ufbxi_string str = { name, strlen(name) };
	return ufbxi_find_node_str(uc, str);
}

static ufbxi_forceinline int
ufbxi_find_node_nth(ufbxi_context *uc, const char *name, int32_t *index)
{
	ufbxi_string str = { name, strlen(name) };
	return ufbxi_find_node_str_nth(uc, str, index);
}

static ufbxi_forceinline int
ufbxi_find_value_str(ufbxi_context *uc, ufbxi_string str, char dst_type, void *dst)
{
	if (!ufbxi_find_node_str(uc, str)) return 0;
	return ufbxi_parse_value(uc, dst_type, dst);
}

static ufbxi_forceinline int
ufbxi_find_value(ufbxi_context *uc, const char *name, char dst_type, void *dst)
{
	ufbxi_string str = { name, strlen(name) };
	if (!ufbxi_find_node_str(uc, str)) return 0;
	return ufbxi_parse_value(uc, dst_type, dst);
}

static ufbxi_forceinline int
ufbxi_find_values_str(ufbxi_context *uc, ufbxi_string str, const char *fmt, ...)
{
	if (!ufbxi_find_node_str(uc, str)) return 0;
	va_list args;
	va_start(args, fmt);
	int ret = ufbxi_parse_values_va(uc, fmt, args);
	va_end(args);
	return ret;
}

static ufbxi_forceinline int
ufbxi_find_values(ufbxi_context *uc, const char *name, const char *fmt, ...)
{
	ufbxi_string str = { name, strlen(name) };
	if (!ufbxi_find_node_str(uc, str)) return 0;
	va_list args;
	va_start(args, fmt);
	int ret = ufbxi_parse_values_va(uc, fmt, args);
	va_end(args);
	return ret;
}

// ASCII format parsing

#define UFBXI_ASCII_END '\0'
#define UFBXI_ASCII_NAME 'N'
#define UFBXI_ASCII_BARE_WORD 'B'
#define UFBXI_ASCII_INT 'I'
#define UFBXI_ASCII_FLOAT 'F'
#define UFBXI_ASCII_STRING 'S'

#define UFBXI_ASCII_MAX_STACK_SIZE 64

typedef struct {
	ufbxi_string str;
	char type;
	union {
		double f64;
		int64_t i64;
		uint32_t name_len;
	} value;
} ufbxi_ascii_token;

typedef struct {
	const char *src;
	const char *src_end;

	char *dst;
	size_t dst_pos;
	size_t dst_size;

	ufbxi_ascii_token prev_token;
	ufbxi_ascii_token token;

	ufbxi_string node_stack[UFBXI_ASCII_MAX_STACK_SIZE];
	uint32_t node_stack_size;

	uint32_t version;

	int failed;
	ufbx_error *error;
} ufbxi_ascii;

static int ufbxi_ascii_do_error(ufbxi_ascii *ua, uint32_t line, const char *desc)
{
	if (ua->failed) return 0;
	ua->failed = 1;
	size_t length = strlen(desc);
	if (length > UFBX_ERROR_DESC_MAX_LENGTH) length = UFBX_ERROR_DESC_MAX_LENGTH;
	if (ua->error) {
		ua->error->source_line = line;
		memcpy(ua->error->desc, desc, length);
		ua->error->desc[length] = '\0';
	}
	return 0;
}

#define ufbxi_ascii_error(ua, desc) ufbxi_ascii_do_error((ua), __LINE__, (desc))

static char ufbxi_ascii_peek(ufbxi_ascii *ua)
{
	return ua->src != ua->src_end ? *ua->src : '\0';
}

static char ufbxi_ascii_next(ufbxi_ascii *ua)
{
	if (ua->src != ua->src_end) ua->src++;
	return ua->src != ua->src_end ? *ua->src : '\0';
}

static char ufbxi_ascii_skip_whitespace(ufbxi_ascii *ua)
{
	// Ignore whitespace
	char c = ufbxi_ascii_peek(ua);
	for (;;) {
		while (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
			c = ufbxi_ascii_next(ua);
		}
		if (c == ';') {
			c = ufbxi_ascii_next(ua);
			while (c != '\n' && c != '\0') {
				c = ufbxi_ascii_next(ua);
			}
		} else {
			break;
		}
	}
	return c;
}

static int ufbxi_ascii_next_token(ufbxi_ascii *ua, ufbxi_ascii_token *token)
{
	char c = ufbxi_ascii_skip_whitespace(ua);
	token->str.data = ua->src;

	if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '_') {
		token->type = UFBXI_ASCII_BARE_WORD;
		uint32_t len = 0;
		while ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')
			|| (c >= '0' && c <= '9') || c == '_') {
			len++;
			c = ufbxi_ascii_next(ua);
		}

		// Skip whitespace to find if there's a following ':'
		c = ufbxi_ascii_skip_whitespace(ua);
		if (c == ':') {
			token->value.name_len = len;
			token->type = UFBXI_ASCII_NAME;
			ufbxi_ascii_next(ua);
		}
	} else if ((c >= '0' && c <= '9') || c == '-' || c == '+' || c == '.') {
		token->type = UFBXI_ASCII_INT;

		char buf[128];
		uint32_t len = 0;
		while ((c >= '0' && c <= '9') || c == '-' || c == '+' || c == '.' || c == 'e' || c == 'E') {
			if (c == '.' || c == 'e' || c == 'E') {
				token->type = UFBXI_ASCII_FLOAT;
			}
			if (len == sizeof(buf) - 1) {
				return ufbxi_ascii_error(ua, "Number is too long");
			}
			buf[len++] = c;
			c = ufbxi_ascii_next(ua);
		}
		buf[len] = '\0';

		char *end;
		if (token->type == UFBXI_ASCII_INT) {
			token->value.i64 = strtoll(buf, &end, 10);
			if (end != buf + len) {
				return ufbxi_ascii_error(ua, "Bad integer constant");
			}
		} else if (token->type == UFBXI_ASCII_FLOAT) {
			token->value.f64 = strtod(buf, &end);
			if (end != buf + len) {
				return ufbxi_ascii_error(ua, "Bad float constant");
			}
		}
	} else if (c == '"') {
		token->type = UFBXI_ASCII_STRING;
		c = ufbxi_ascii_next(ua);
		while (c != '"') {
			c = ufbxi_ascii_next(ua);
			if (c == '\0') {
				return ufbxi_ascii_error(ua, "Unclosed string");
			}
		}
		// Skip closing quote
		ufbxi_ascii_next(ua);
	} else {
		token->type = c;
		ufbxi_ascii_next(ua);
	}

	token->str.length = ua->src - token->str.data;
	return 1;
}

static int ufbxi_ascii_accept(ufbxi_ascii *ua, char type)
{
	if (ua->token.type == type) {
		ua->prev_token = ua->token;
		if (!ufbxi_ascii_next_token(ua, &ua->token)) return 0;
		return 1;
	} else {
		return 0;
	}
}

static size_t ufbxi_ascii_push_output(ufbxi_ascii *ua, size_t size)
{
	if (ua->dst_size - ua->dst_pos < size) {
		size_t new_size = 2 * ua->dst_size;
		if (new_size < 1024) new_size = 1024;
		if (new_size < size) new_size = size;
		char *new_dst = (char*)realloc(ua->dst, new_size);
		if (!new_dst) return ~0u;
		ua->dst = new_dst;
		ua->dst_size = new_size;
	}
	size_t pos = ua->dst_pos;
	ua->dst_pos += size;
	return pos;
}

static int ufbxi_ascii_parse_node(ufbxi_ascii *ua)
{
	if (ua->node_stack_size >= UFBXI_ASCII_MAX_STACK_SIZE) {
		return ufbxi_ascii_error(ua, "Too many nested nodes");
	}

	if (!ufbxi_ascii_accept(ua, UFBXI_ASCII_NAME)) {
		return ufbxi_ascii_error(ua, "Expected node name");
	}

	uint32_t name_len = ua->prev_token.value.name_len;
	if (name_len > 0xff) {
		return ufbxi_ascii_error(ua, "Node name is too long");
	}

	ua->node_stack[ua->node_stack_size].data = ua->prev_token.str.data;
	ua->node_stack[ua->node_stack_size].length = name_len;
	ua->node_stack_size++;

	size_t node_pos = ufbxi_ascii_push_output(ua, 25 + name_len);
	if (node_pos == ~0u) return 0;
	ufbxi_write_u8(ua->dst + node_pos + 24, name_len);
	memcpy(ua->dst + node_pos + 25, ua->prev_token.str.data, name_len);

	size_t value_begin_pos = ua->dst_pos;

	int in_array = 0;
	size_t num_values = 0;

	// NOTE: Infinite loop to allow skipping the comma parsing via `continue`.
	for (;;) {
		ufbxi_ascii_token *tok = &ua->prev_token;
		if (ufbxi_ascii_accept(ua, UFBXI_ASCII_STRING)) {
			// The ASCII format supports escaping quotes via "&quot;". There seems
			// to be no way to escape "&quot;" itself. Exporting and importing converts
			// strings with "&quot;" to "\"". Append worst-case data and rewind the
			// write position in case we find "&quot;" escapes.
			size_t string_len = tok->str.length - 2;
			size_t pos = ufbxi_ascii_push_output(ua, 5 + string_len);
			if (pos == ~0u) return 0;
			char *dst = ua->dst + pos + 5;
			size_t bytes_escaped = 0;
			for (size_t i = 0; i < string_len; i++) {
				char c = tok->str.data[1 + i];
				if (c == '&' && i + 6 <= string_len) {
					if (!memcmp(tok->str.data + 1 + i, "&quot;", 6)) {
						bytes_escaped += 5;
						i += 5;
						c = '\"';
					}
				}
				*dst++ = c;
			}

			ua->dst_pos -= bytes_escaped;
			string_len -= bytes_escaped;
			ua->dst[pos + 0] = 'S';
			ufbxi_write_u32(ua->dst + pos + 1, string_len);

		} else if (ufbxi_ascii_accept(ua, UFBXI_ASCII_INT)) {
			int64_t val = tok->value.i64;
			if (val >= INT16_MIN && val <= INT16_MAX) {
				size_t pos = ufbxi_ascii_push_output(ua, 3);
				if (pos == ~0u) return 0;
				ua->dst[pos] = 'Y';
				ufbxi_write_i16(ua->dst + pos + 1, val);
			} else if (val >= INT32_MIN && val <= INT32_MAX) {
				size_t pos = ufbxi_ascii_push_output(ua, 5);
				if (pos == ~0u) return 0;
				ua->dst[pos] = 'I';
				ufbxi_write_i32(ua->dst + pos + 1, val);
			} else {
				size_t pos = ufbxi_ascii_push_output(ua, 9);
				if (pos == ~0u) return 0;
				ua->dst[pos] = 'L';
				ufbxi_write_i64(ua->dst + pos + 1, val);
			}

			// Try to guesstimate the FBX version
			if (!ua->version
				&& ua->node_stack_size == 2
				&& val > 0 && val < INT32_MAX
				&& ufbxi_streq(ua->node_stack[0], "FBXHeaderExtension")
				&& ufbxi_streq(ua->node_stack[1], "FBXVersion")) {
				ua->version = (uint32_t)val;
			}

		} else if (ufbxi_ascii_accept(ua, UFBXI_ASCII_FLOAT)) {
			double val = tok->value.f64;
			if ((double)(float)val == val) {
				size_t pos = ufbxi_ascii_push_output(ua, 5);
				if (pos == ~0u) return 0;
				ua->dst[pos] = 'F';
				ufbxi_write_f32(ua->dst + pos + 1, val);
			} else {
				size_t pos = ufbxi_ascii_push_output(ua, 9);
				if (pos == ~0u) return 0;
				ua->dst[pos] = 'D';
				ufbxi_write_f64(ua->dst + pos + 1, val);
			}

		} else if (ufbxi_ascii_accept(ua, UFBXI_ASCII_BARE_WORD)) {
			if (ufbxi_streq(tok->str, "Y") || ufbxi_streq(tok->str, "T")) {
				size_t pos = ufbxi_ascii_push_output(ua, 2);
				if (pos == ~0u) return 0;
				ua->dst[pos] = 'C';
				ua->dst[pos + 1] = 1;
			} else if (ufbxi_streq(tok->str, "N") || ufbxi_streq(tok->str, "F")) {
				size_t pos = ufbxi_ascii_push_output(ua, 2);
				if (pos == ~0u) return 0;
				ua->dst[pos] = 'C';
				ua->dst[pos + 1] = 0;
			}

		} else if (ufbxi_ascii_accept(ua, '*')) {
			if (in_array) {
				return ufbxi_ascii_error(ua, "Nested array values");
			}
			if (!ufbxi_ascii_accept(ua, UFBXI_ASCII_INT)) {
				return ufbxi_ascii_error(ua, "Expected array size");
			}
			if (ufbxi_ascii_accept(ua, '{')) {
				if (!ufbxi_ascii_accept(ua, UFBXI_ASCII_NAME)) {
					return ufbxi_ascii_error(ua, "Expected array content name");
				}

				// NOTE: This `continue` skips incrementing `num_values` and parsing
				// a comma, continuing to parse the values in the array.
				in_array = 1;
				continue;
			}
		} else {
			break;
		}

		// Add value and keep parsing if there's a comma. This part may be
		// skipped if we enter an array block.
		num_values++;
		if (!ufbxi_ascii_accept(ua, ',')) break;
	}

	if (in_array) {
		if (!ufbxi_ascii_accept(ua, '}')) {
			return ufbxi_ascii_error(ua, "Unclosed value array");
		}
	}

	size_t value_end_pos = ua->dst_pos;

	if (ufbxi_ascii_accept(ua, '{')) {
		while (!ufbxi_ascii_accept(ua, '}')) {
			if (ua->failed) return 0;
			ufbxi_ascii_parse_node(ua);
		}

		size_t null_pos = ufbxi_ascii_push_output(ua, 25);
		if (null_pos == ~0u) return 0;
		memset(ua->dst + null_pos, 0, 25);
	}

	size_t child_end_pos = ua->dst_pos;
	ufbxi_write_u64(ua->dst + node_pos + 0, child_end_pos);
	ufbxi_write_u64(ua->dst + node_pos + 8, num_values);
	ufbxi_write_u64(ua->dst + node_pos + 16, value_end_pos - value_begin_pos);

	ua->node_stack_size--;
	return !ua->failed;
}

#define UFBXI_BINARY_MAGIC_SIZE 23
static const char ufbxi_binary_magic[] = "Kaydara FBX Binary  \x00\x1a\x00";

static int ufbxi_ascii_parse(ufbxi_ascii *ua)
{
	size_t magic_pos = ufbxi_ascii_push_output(ua, UFBXI_BINARY_MAGIC_SIZE + 4);

	ufbxi_ascii_next_token(ua, &ua->token);
	while (!ufbxi_ascii_accept(ua, UFBXI_ASCII_END)) {
		if (ua->failed) return 0;
		if (!ufbxi_ascii_parse_node(ua)) return 0;
	}
	size_t null_pos = ufbxi_ascii_push_output(ua, 25);
	if (null_pos == ~0u) return 0;
	memset(ua->dst + null_pos, 0, 25);

	size_t version = ua->version ? ua->version : 7500;
	memcpy(ua->dst + magic_pos, ufbxi_binary_magic, UFBXI_BINARY_MAGIC_SIZE);
	ufbxi_write_u32(ua->dst + UFBXI_BINARY_MAGIC_SIZE, version);

	return 1;
}

#endif
